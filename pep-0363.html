<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">363</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Syntax For Dynamic Attribute Access</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0363.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ben North &lt;ben&#32;&#97;t&#32;redfrontdoor.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">29-Jan-2007</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">12-Feb-2007</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a></li>
<li><a class="reference internal" href="#impact-on-existing-code" id="id9">Impact On Existing Code</a></li>
<li><a class="reference internal" href="#performance-impact" id="id10">Performance Impact</a></li>
<li><a class="reference internal" href="#error-cases" id="id11">Error Cases</a></li>
<li><a class="reference internal" href="#draft-implementation" id="id12">Draft Implementation</a></li>
<li><a class="reference internal" href="#mailing-lists-discussion" id="id13">Mailing Lists Discussion</a></li>
<li><a class="reference internal" href="#references" id="id14">References</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>Dynamic attribute access is currently possible using the &quot;getattr&quot;
and &quot;setattr&quot; builtins.  The present PEP suggests a new syntax to
make such access easier, allowing the coder for example to write:</p>
<pre class="literal-block">
x.('foo_%d' % n) += 1

z = y.('foo_%d' % n).('bar_%s' % s)
</pre>
<p>instead of:</p>
<pre class="literal-block">
attr_name = 'foo_%d' % n
setattr(x, attr_name, getattr(x, attr_name) + 1)

z = getattr(getattr(y, 'foo_%d' % n), 'bar_%s' % s)
</pre>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p>Dictionary access and indexing both have a friendly invocation
syntax: instead of <tt class="docutils literal">x.__getitem__(12)</tt> the coder can write <tt class="docutils literal">x[12]</tt>.
This also allows the use of subscripted elements in an augmented
assignment, as in &quot;x[12] += 1&quot;.  The present proposal brings this
ease-of-use to dynamic attribute access too.</p>
<p>Attribute access is currently possible in two ways:</p>
<ul>
<li><p class="first">When the attribute name is known at code-writing time, the
&quot;.NAME&quot; trailer can be used, as in:</p>
<pre class="literal-block">
x.foo = 42
y.bar += 100
</pre>
</li>
<li><p class="first">When the attribute name is computed dynamically at run-time, the
&quot;getattr&quot; and &quot;setattr&quot; builtins must be used:</p>
<pre class="literal-block">
x = getattr(y, 'foo_%d' % n)
setattr(z, 'bar_%s' % s, 99)
</pre>
<p>The &quot;getattr&quot; builtin also allows the coder to specify a default
value to be returned in the event that the object does not have
an attribute of the given name:</p>
<pre class="literal-block">
x = getattr(y, 'foo_%d' % n, 0)
</pre>
</li>
</ul>
<p>This PEP describes a new syntax for dynamic attribute access ---
&quot;x.(expr)&quot; --- with examples given in the Abstract above.</p>
<p>(The new syntax could also allow the provision of a default value in
the &quot;get&quot; case, as in:</p>
<pre class="literal-block">
x = y.('foo_%d' % n, None)
</pre>
<p>This 2-argument form of dynamic attribute access would not be
permitted as the target of an (augmented or normal) assignment.  The
&quot;Discussion&quot; section below includes opinions specifically on the
2-argument extension.)</p>
<p>Finally, the new syntax can be used with the &quot;del&quot; statement, as in:</p>
<pre class="literal-block">
del x.(attr_name)
</pre>
</div>
<div class="section" id="impact-on-existing-code">
<h1><a class="toc-backref" href="#id9">Impact On Existing Code</a></h1>
<p>The proposed new syntax is not currently valid, so no existing
well-formed programs have their meaning altered by this proposal.</p>
<p>Across all &quot;*.py&quot; files in the 2.5 distribution, there are around
600 uses of &quot;getattr&quot;, &quot;setattr&quot; or &quot;delattr&quot;.  They break down as
follows (figures have some room for error because they were
arrived at by partially-manual inspection):</p>
<pre class="literal-block">
c.300 uses of plain &quot;getattr(x, attr_name)&quot;, which could be
      replaced with the new syntax;

c.150 uses of the 3-argument form, i.e., with the default
      value; these could be replaced with the 2-argument form
      of the new syntax (the cases break down into c.125 cases
      where the attribute name is a literal string, and c.25
      where it's only known at run-time);

c.5   uses of the 2-argument form with a literal string
      attribute name, which I think could be replaced with the
      standard &quot;x.attribute&quot; syntax;

c.120 uses of setattr, of which 15 use getattr to find the
      new value; all could be replaced with the new syntax,
      the 15 where getattr is also involved would show a
      particular increase in clarity;

c.5   uses which would have to stay as &quot;getattr&quot; because they
      are calls of a variable named &quot;getattr&quot; whose default
      value is the builtin &quot;getattr&quot;;

c.5   uses of the 2-argument form, inside a try/except block
      which catches AttributeError and uses a default value
      instead; these could use 2-argument form of the new
      syntax;

c.10  uses of &quot;delattr&quot;, which could use the new syntax.
</pre>
<p>As examples, the line:</p>
<pre class="literal-block">
setattr(self, attr, change_root(self.root, getattr(self, attr)))
</pre>
<p>from Lib/distutils/command/install.py could be rewritten:</p>
<pre class="literal-block">
self.(attr) = change_root(self.root, self.(attr))
</pre>
<p>and the line:</p>
<pre class="literal-block">
setattr(self, method_name, getattr(self.metadata, method_name))
</pre>
<p>from Lib/distutils/dist.py could be rewritten:</p>
<pre class="literal-block">
self.(method_name) = self.metadata.(method_name)
</pre>
</div>
<div class="section" id="performance-impact">
<h1><a class="toc-backref" href="#id10">Performance Impact</a></h1>
<p>Initial pystone measurements are inconclusive, but suggest there may
be a performance penalty of around 1% in the pystones score with the
patched version.  One suggestion is that this is because the longer
main loop in ceval.c hurts the cache behaviour, but this has not
been confirmed.</p>
<p>On the other hand, measurements suggest a speed-up of around 40--45%
for dynamic attribute access.</p>
</div>
<div class="section" id="error-cases">
<h1><a class="toc-backref" href="#id11">Error Cases</a></h1>
<p>Only strings are permitted as attribute names, so for instance the
following error is produced:</p>
<pre class="literal-block">
&gt;&gt;&gt; x.(99) = 8
   Traceback (most recent call last):
     File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
   TypeError: attribute name must be string, not 'int'
</pre>
<p>This is handled by the existing <tt class="docutils literal">PyObject_GetAttr</tt> function.</p>
</div>
<div class="section" id="draft-implementation">
<h1><a class="toc-backref" href="#id12">Draft Implementation</a></h1>
<p>A draft implementation adds a new alternative to the &quot;trailer&quot;
clause in Grammar/Grammar; a new AST type, &quot;DynamicAttribute&quot; in
Python.asdl, with accompanying changes to symtable.c, ast.c, and
compile.c, and three new opcodes (load/store/del) with
accompanying changes to opcode.h and ceval.c.  The patch consists
of c.180 additional lines in the core code, and c.100 additional
lines of tests.  It is available as sourceforge patch #1657573 <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
</div>
<div class="section" id="mailing-lists-discussion">
<h1><a class="toc-backref" href="#id13">Mailing Lists Discussion</a></h1>
<p>Initial posting of this PEP in draft form was to python-ideas on
20070209 <a class="footnote-reference" href="#id5" id="id2">[2]</a>, and the response was generally positive.  The PEP was
then posted to python-dev on 20070212 <a class="footnote-reference" href="#id6" id="id3">[3]</a>, and an interesting
discussion ensued.  A brief summary:</p>
<p>Initially, there was reasonable (but not unanimous) support for the
idea, although the precise choice of syntax had a more mixed
reception.  Several people thought the &quot;.&quot; would be too easily
overlooked, with the result that the syntax could be confused with a
method/function call.  A few alternative syntaxes were suggested:</p>
<pre class="literal-block">
obj.(foo)
obj.[foo]
obj.{foo}
obj{foo}
obj.*foo
obj-&gt;foo
obj&lt;-foo
obj&#64;[foo]
obj.[[foo]]
</pre>
<p>with &quot;obj.[foo]&quot; emerging as the preferred one.  In this initial
discussion, the two-argument form was universally disliked, so it
was to be taken out of the PEP.</p>
<p>Discussion then took a step back to whether this particular feature
provided enough benefit to justify new syntax.  As well as requiring
coders to become familiar with the new syntax, there would also be
the problem of backward compatibility --- code using the new syntax
would not run on older pythons.</p>
<p>Instead of new syntax, a new &quot;wrapper class&quot; was proposed, with the
following specification / conceptual implementation suggested by
Martin von LÃ¶wis:</p>
<pre class="literal-block">
class attrs:
   def __init__(self, obj):
     self.obj = obj
   def __getitem__(self, name):
     return getattr(self.obj, name)
   def __setitem__(self, name, value):
     return setattr(self.obj, name, value)
   def __delitem__(self, name):
     return delattr(self, name)
   def __contains__(self, name):
     return hasattr(self, name)
</pre>
<p>This was considered a cleaner and more elegant solution to the
original problem.  (Another suggestion was a mixin class providing
dictionary-style access to an object's attributes.)</p>
<p>The decision was made that the present PEP did not meet the burden
of proof for the introduction of new syntax, a view which had been
put forward by some from the beginning of the discussion.  The
wrapper class idea was left open as a possibility for a future PEP.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id14">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Sourceforge patch #1657573
<a class="reference external" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1657573&amp;group_id=5470&amp;atid=305470">http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1657573&amp;group_id=5470&amp;atid=305470</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2007-February/000210.html">https://mail.python.org/pipermail/python-ideas/2007-February/000210.html</a>
and following posts</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-February/070939.html">https://mail.python.org/pipermail/python-dev/2007-February/070939.html</a>
and following posts</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

