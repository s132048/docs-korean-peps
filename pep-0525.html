<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">525</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Asynchronous Generators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0525.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Yury Selivanov &lt;yury&#32;&#97;t&#32;magic.io&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">&lt;<a class="reference external" href="mailto:python-dev&#64;python.org?subject=PEP%20525">python-dev&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">28-Jul-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">02-Aug-2016, 23-Aug-2016, 01-Sep-2016, 06-Sep-2016</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#rationale-and-goals" id="id8">Rationale and Goals</a></li>
<li><a class="reference internal" href="#specification" id="id9">Specification</a><ul>
<li><a class="reference internal" href="#asynchronous-generators" id="id10">Asynchronous Generators</a></li>
<li><a class="reference internal" href="#support-for-asynchronous-iteration-protocol" id="id11">Support for Asynchronous Iteration Protocol</a></li>
<li><a class="reference internal" href="#finalization" id="id12">Finalization</a></li>
<li><a class="reference internal" href="#asyncio" id="id13">asyncio</a></li>
<li><a class="reference internal" href="#asynchronous-generator-object" id="id14">Asynchronous Generator Object</a></li>
<li><a class="reference internal" href="#implementation-details" id="id15">Implementation Details</a><ul>
<li><a class="reference internal" href="#pyasyncgenasend-and-pyasyncgenathrow" id="id16">PyAsyncGenASend and PyAsyncGenAThrow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-standard-library-functions-and-types" id="id17">New Standard Library Functions and Types</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id18">Backwards Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance" id="id19">Performance</a><ul>
<li><a class="reference internal" href="#regular-generators" id="id20">Regular Generators</a></li>
<li><a class="reference internal" href="#improvements-over-asynchronous-iterators" id="id21">Improvements over asynchronous iterators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-considerations" id="id22">Design Considerations</a><ul>
<li><a class="reference internal" href="#aiter-and-anext-builtins" id="id23"><tt class="docutils literal">aiter()</tt> and <tt class="docutils literal">anext()</tt> builtins</a></li>
<li><a class="reference internal" href="#asynchronous-list-dict-set-comprehensions" id="id24">Asynchronous list/dict/set comprehensions</a></li>
<li><a class="reference internal" href="#asynchronous-yield-from" id="id25">Asynchronous <tt class="docutils literal">yield from</tt></a></li>
<li><a class="reference internal" href="#why-the-asend-and-athrow-methods-are-necessary" id="id26">Why the <tt class="docutils literal">asend()</tt> and <tt class="docutils literal">athrow()</tt> methods are necessary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example" id="id27">Example</a></li>
<li><a class="reference internal" href="#acceptance" id="id28">Acceptance</a></li>
<li><a class="reference internal" href="#implementation" id="id29">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id30">References</a></li>
<li><a class="reference internal" href="#acknowledgments" id="id31">Acknowledgments</a></li>
<li><a class="reference internal" href="#copyright" id="id32">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0492">PEP 492</a> introduced support for native coroutines and <tt class="docutils literal">async</tt>/<tt class="docutils literal">await</tt>
syntax to Python 3.5.  It is proposed here to extend Python's
asynchronous capabilities by adding support for
<em>asynchronous generators</em>.</p>
</div>
<div class="section" id="rationale-and-goals">
<h1><a class="toc-backref" href="#id8">Rationale and Goals</a></h1>
<p>Regular generators (introduced in <a class="reference external" href="/dev/peps/pep-0255">PEP 255</a>) enabled an elegant way of
writing complex <em>data producers</em> and have them behave like an iterator.</p>
<p>However, currently there is no equivalent concept for the <em>asynchronous
iteration protocol</em> (<tt class="docutils literal">async for</tt>).  This makes writing asynchronous
data producers unnecessarily complex, as one must define a class that
implements <tt class="docutils literal">__aiter__</tt> and <tt class="docutils literal">__anext__</tt> to be able to use it in
an <tt class="docutils literal">async for</tt> statement.</p>
<p>Essentially, the goals and rationale for <a class="reference external" href="/dev/peps/pep-0255">PEP 255</a>, applied to the
asynchronous execution case, hold true for this proposal as well.</p>
<p>Performance is an additional point for this proposal: in our testing of
the reference implementation, asynchronous generators are <strong>2x</strong> faster
than an equivalent implemented as an asynchronous iterator.</p>
<p>As an illustration of the code quality improvement, consider the
following class that prints numbers with a given delay once iterated:</p>
<pre class="literal-block">
class Ticker:
    &quot;&quot;&quot;Yield numbers from 0 to `to` every `delay` seconds.&quot;&quot;&quot;

    def __init__(self, delay, to):
        self.delay = delay
        self.i = 0
        self.to = to

    def __aiter__(self):
        return self

    async def __anext__(self):
        i = self.i
        if i &gt;= self.to:
            raise StopAsyncIteration
        self.i += 1
        if i:
            await asyncio.sleep(self.delay)
        return i
</pre>
<p>The same can be implemented as a much simpler asynchronous generator:</p>
<pre class="literal-block">
async def ticker(delay, to):
    &quot;&quot;&quot;Yield numbers from 0 to `to` every `delay` seconds.&quot;&quot;&quot;
    for i in range(to):
        yield i
        await asyncio.sleep(delay)
</pre>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id9">Specification</a></h1>
<p>This proposal introduces the concept of <em>asynchronous generators</em> to
Python.</p>
<p>This specification presumes knowledge of the implementation of
generators and coroutines in Python (<a class="reference external" href="/dev/peps/pep-0342">PEP 342</a>, <a class="reference external" href="/dev/peps/pep-0380">PEP 380</a> and <a class="reference external" href="/dev/peps/pep-0492">PEP 492</a>).</p>
<div class="section" id="asynchronous-generators">
<h2><a class="toc-backref" href="#id10">Asynchronous Generators</a></h2>
<p>A Python <em>generator</em> is any function containing one or more <tt class="docutils literal">yield</tt>
expressions:</p>
<pre class="literal-block">
def func():            # a function
    return

def genfunc():         # a generator function
    yield
</pre>
<p>We propose to use the same approach to define
<em>asynchronous generators</em>:</p>
<pre class="literal-block">
async def coro():      # a coroutine function
    await smth()

async def asyncgen():  # an asynchronous generator function
    await smth()
    yield 42
</pre>
<p>The result of calling an <em>asynchronous generator function</em> is
an <em>asynchronous generator object</em>, which implements the asynchronous
iteration protocol defined in <a class="reference external" href="/dev/peps/pep-0492">PEP 492</a>.</p>
<p>It is a <tt class="docutils literal">SyntaxError</tt> to have a non-empty <tt class="docutils literal">return</tt> statement in an
asynchronous generator.</p>
</div>
<div class="section" id="support-for-asynchronous-iteration-protocol">
<h2><a class="toc-backref" href="#id11">Support for Asynchronous Iteration Protocol</a></h2>
<p>The protocol requires two special methods to be implemented:</p>
<ol class="arabic simple">
<li>An <tt class="docutils literal">__aiter__</tt> method returning an <em>asynchronous iterator</em>.</li>
<li>An <tt class="docutils literal">__anext__</tt> method returning an <em>awaitable</em> object, which uses
<tt class="docutils literal">StopIteration</tt> exception to &quot;yield&quot; values, and
<tt class="docutils literal">StopAsyncIteration</tt> exception to signal the end of the iteration.</li>
</ol>
<p>Asynchronous generators define both of these methods.  Let's manually
iterate over a simple asynchronous generator:</p>
<pre class="literal-block">
async def genfunc():
    yield 1
    yield 2

gen = genfunc()

assert gen.__aiter__() is gen

assert await gen.__anext__() == 1
assert await gen.__anext__() == 2

await gen.__anext__()  # This line will raise StopAsyncIteration.
</pre>
</div>
<div class="section" id="finalization">
<h2><a class="toc-backref" href="#id12">Finalization</a></h2>
<p><a class="reference external" href="/dev/peps/pep-0492">PEP 492</a> requires an event loop or a scheduler to run coroutines.
Because asynchronous generators are meant to be used from coroutines,
they also require an event loop to run and finalize them.</p>
<p>Asynchronous generators can have <tt class="docutils literal"><span class="pre">try..finally</span></tt> blocks, as well as
<tt class="docutils literal">async with</tt>.  It is important to provide a guarantee that, even
when partially iterated, and then garbage collected, generators can
be safely finalized.  For example:</p>
<pre class="literal-block">
async def square_series(con, to):
    async with con.transaction():
        cursor = con.cursor(
            'SELECT generate_series(0, $1) AS i', to)
        async for row in cursor:
            yield row['i'] ** 2

async for i in square_series(con, 1000):
    if i == 100:
        break
</pre>
<p>The above code defines an asynchronous generator that uses
<tt class="docutils literal">async with</tt> to iterate over a database cursor in a transaction.
The generator is then iterated over with <tt class="docutils literal">async for</tt>, which interrupts
the iteration at some point.</p>
<p>The <tt class="docutils literal">square_series()</tt> generator will then be garbage collected,
and without a mechanism to asynchronously close the generator, Python
interpreter would not be able to do anything.</p>
<p>To solve this problem we propose to do the following:</p>
<ol class="arabic">
<li><p class="first">Implement an <tt class="docutils literal">aclose</tt> method on asynchronous generators
returning a special <em>awaitable</em>.  When awaited it
throws a <tt class="docutils literal">GeneratorExit</tt> into the suspended generator and
iterates over it until either a <tt class="docutils literal">GeneratorExit</tt> or
a <tt class="docutils literal">StopAsyncIteration</tt> occur.</p>
<p>This is very similar to what the <tt class="docutils literal">close()</tt> method does to regular
Python generators, except that an event loop is required to execute
<tt class="docutils literal">aclose()</tt>.</p>
</li>
<li><p class="first">Raise a <tt class="docutils literal">RuntimeError</tt>, when an asynchronous generator executes
a <tt class="docutils literal">yield</tt> expression in its <tt class="docutils literal">finally</tt> block (using <tt class="docutils literal">await</tt>
is fine, though):</p>
<pre class="literal-block">
async def gen():
    try:
        yield
    finally:
        await asyncio.sleep(1)   # Can use 'await'.

        yield                    # Cannot use 'yield',
                                 # this line will trigger a
                                 # RuntimeError.
</pre>
</li>
<li><p class="first">Add two new methods to the <tt class="docutils literal">sys</tt> module:
<tt class="docutils literal">set_asyncgen_hooks()</tt> and <tt class="docutils literal">get_asyncgen_hooks()</tt>.</p>
</li>
</ol>
<p>The idea behind <tt class="docutils literal">sys.set_asyncgen_hooks()</tt> is to allow event
loops to intercept asynchronous generators iteration and finalization,
so that the end user does not need to care about the finalization
problem, and everything just works.</p>
<p><tt class="docutils literal">sys.set_asyncgen_hooks()</tt> accepts two arguments:</p>
<ul class="simple">
<li><tt class="docutils literal">firstiter</tt>: a callable which will be called when an asynchronous
generator is iterated for the first time.</li>
<li><tt class="docutils literal">finalizer</tt>: a callable which will be called when an asynchronous
generator is about to be GCed.</li>
</ul>
<p>When an asynchronous generator is iterated for the first time,
it stores a reference to the current <em>finalizer</em>.</p>
<p>When an asynchronous generator is about to be garbage collected,
it calls its cached <em>finalizer</em>.  The assumption is that the finalizer
will schedule an <tt class="docutils literal">aclose()</tt> call with the loop that was active
when the iteration started.</p>
<p>For instance, here is how asyncio is modified to allow safe
finalization of asynchronous generators:</p>
<pre class="literal-block">
# asyncio/base_events.py

class BaseEventLoop:

    def run_forever(self):
        ...
        old_hooks = sys.get_asyncgen_hooks()
        sys.set_asyncgen_hooks(finalizer=self._finalize_asyncgen)
        try:
            ...
        finally:
            sys.set_asyncgen_hooks(*old_hooks)
            ...

    def _finalize_asyncgen(self, gen):
        self.create_task(gen.aclose())
</pre>
<p>The second argument, <tt class="docutils literal">firstiter</tt>, allows event loops to maintain
a weak set of asynchronous generators instantiated under their control.
This makes it possible to implement &quot;shutdown&quot; mechanisms to safely
finalize all open generators and close the event loop.</p>
<p><tt class="docutils literal">sys.set_asyncgen_hooks()</tt> is thread-specific, so several event
loops running in parallel threads can use it safely.</p>
<p><tt class="docutils literal">sys.get_asyncgen_hooks()</tt> returns a namedtuple-like structure
with <tt class="docutils literal">firstiter</tt> and <tt class="docutils literal">finalizer</tt> fields.</p>
</div>
<div class="section" id="asyncio">
<h2><a class="toc-backref" href="#id13">asyncio</a></h2>
<p>The asyncio event loop will use <tt class="docutils literal">sys.set_asyncgen_hooks()</tt> API to
maintain a weak set of all scheduled asynchronous generators, and to
schedule their <tt class="docutils literal">aclose()</tt> coroutine methods when it is time for
generators to be GCed.</p>
<p>To make sure that asyncio programs can finalize all scheduled
asynchronous generators reliably, we propose to add a new event loop
coroutine method <tt class="docutils literal">loop.shutdown_asyncgens()</tt>.  The method will
schedule all currently open asynchronous generators to close with an
<tt class="docutils literal">aclose()</tt> call.</p>
<p>After calling the <tt class="docutils literal">loop.shutdown_asyncgens()</tt> method, the event loop
will issue a warning whenever a new asynchronous generator is iterated
for the first time.  The idea is that after requesting all asynchronous
generators to be shutdown, the program should not execute code that
iterates over new asynchronous generators.</p>
<p>An example of how <tt class="docutils literal">shutdown_asyncgens</tt> coroutine should be used:</p>
<pre class="literal-block">
try:
    loop.run_forever()
finally:
    loop.run_until_complete(loop.shutdown_asyncgens())
    loop.close()
</pre>
</div>
<div class="section" id="asynchronous-generator-object">
<h2><a class="toc-backref" href="#id14">Asynchronous Generator Object</a></h2>
<p>The object is modeled after the standard Python generator object.
Essentially, the behaviour of asynchronous generators is designed
to replicate the behaviour of synchronous generators, with the only
difference in that the API is asynchronous.</p>
<p>The following methods and properties are defined:</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal">agen.__aiter__()</tt>: Returns <tt class="docutils literal">agen</tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal">agen.__anext__()</tt>: Returns an <em>awaitable</em>, that performs one
asynchronous generator iteration when awaited.</p>
</li>
<li><p class="first"><tt class="docutils literal">agen.asend(val)</tt>: Returns an <em>awaitable</em>, that pushes the
<tt class="docutils literal">val</tt> object in the <tt class="docutils literal">agen</tt> generator.  When the <tt class="docutils literal">agen</tt> has
not yet been iterated, <tt class="docutils literal">val</tt> must be <tt class="docutils literal">None</tt>.</p>
<p>Example:</p>
<pre class="literal-block">
async def gen():
    await asyncio.sleep(0.1)
    v = yield 42
    print(v)
    await asyncio.sleep(0.2)

g = gen()

await g.asend(None)      # Will return 42 after sleeping
                         # for 0.1 seconds.

await g.asend('hello')   # Will print 'hello' and
                         # raise StopAsyncIteration
                         # (after sleeping for 0.2 seconds.)
</pre>
</li>
<li><p class="first"><tt class="docutils literal">agen.athrow(typ, [val, <span class="pre">[tb]])</span></tt>: Returns an <em>awaitable</em>, that
throws an exception into the <tt class="docutils literal">agen</tt> generator.</p>
<p>Example:</p>
<pre class="literal-block">
async def gen():
    try:
        await asyncio.sleep(0.1)
        yield 'hello'
    except ZeroDivisionError:
        await asyncio.sleep(0.2)
        yield 'world'

g = gen()
v = await g.asend(None)
print(v)                # Will print 'hello' after
                        # sleeping for 0.1 seconds.

v = await g.athrow(ZeroDivisionError)
print(v)                # Will print 'world' after
                        $ sleeping 0.2 seconds.
</pre>
</li>
<li><p class="first"><tt class="docutils literal">agen.aclose()</tt>: Returns an <em>awaitable</em>, that throws a
<tt class="docutils literal">GeneratorExit</tt> exception into the generator.  The <em>awaitable</em> can
either return a yielded value, if <tt class="docutils literal">agen</tt> handled the exception,
or <tt class="docutils literal">agen</tt> will be closed and the exception will propagate back
to the caller.</p>
</li>
<li><p class="first"><tt class="docutils literal">agen.__name__</tt> and <tt class="docutils literal">agen.__qualname__</tt>: readable and writable
name and qualified name attributes.</p>
</li>
<li><p class="first"><tt class="docutils literal">agen.ag_await</tt>: The object that <tt class="docutils literal">agen</tt> is currently <em>awaiting</em>
on, or <tt class="docutils literal">None</tt>.  This is similar to the currently available
<tt class="docutils literal">gi_yieldfrom</tt> for generators and <tt class="docutils literal">cr_await</tt> for coroutines.</p>
</li>
<li><p class="first"><tt class="docutils literal">agen.ag_frame</tt>, <tt class="docutils literal">agen.ag_running</tt>, and <tt class="docutils literal">agen.ag_code</tt>:
defined in the same way as similar attributes of standard generators.</p>
</li>
</ol>
<p><tt class="docutils literal">StopIteration</tt> and <tt class="docutils literal">StopAsyncIteration</tt> are not propagated out of
asynchronous generators, and are replaced with a <tt class="docutils literal">RuntimeError</tt>.</p>
</div>
<div class="section" id="implementation-details">
<h2><a class="toc-backref" href="#id15">Implementation Details</a></h2>
<p>Asynchronous generator object (<tt class="docutils literal">PyAsyncGenObject</tt>) shares the
struct layout with <tt class="docutils literal">PyGenObject</tt>.  In addition to that, the
reference implementation introduces three new objects:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">PyAsyncGenASend</tt>: the awaitable object that implements
<tt class="docutils literal">__anext__</tt> and <tt class="docutils literal">asend()</tt> methods.</li>
<li><tt class="docutils literal">PyAsyncGenAThrow</tt>: the awaitable object that implements
<tt class="docutils literal">athrow()</tt> and <tt class="docutils literal">aclose()</tt> methods.</li>
<li><tt class="docutils literal">_PyAsyncGenWrappedValue</tt>: every directly yielded object from an
asynchronous generator is implicitly boxed into this structure.  This
is how the generator implementation can separate objects that are
yielded using regular iteration protocol from objects that are
yielded using asynchronous iteration protocol.</li>
</ol>
<p><tt class="docutils literal">PyAsyncGenASend</tt> and <tt class="docutils literal">PyAsyncGenAThrow</tt> are awaitables (they have
<tt class="docutils literal">__await__</tt> methods returning <tt class="docutils literal">self</tt>) and are coroutine-like objects
(implementing <tt class="docutils literal">__iter__</tt>, <tt class="docutils literal">__next__</tt>, <tt class="docutils literal">send()</tt> and <tt class="docutils literal">throw()</tt>
methods).  Essentially, they control how asynchronous generators are
iterated:</p>
<img alt="pep-0525-1.png" class="align-center" src="pep-0525-1.png" style="width: 80%;" />
<div class="section" id="pyasyncgenasend-and-pyasyncgenathrow">
<h3><a class="toc-backref" href="#id16">PyAsyncGenASend and PyAsyncGenAThrow</a></h3>
<p><tt class="docutils literal">PyAsyncGenASend</tt> is a coroutine-like object that drives <tt class="docutils literal">__anext__</tt>
and <tt class="docutils literal">asend()</tt> methods and implements the asynchronous iteration
protocol.</p>
<p><tt class="docutils literal">agen.asend(val)</tt> and <tt class="docutils literal">agen.__anext__()</tt> return instances of
<tt class="docutils literal">PyAsyncGenASend</tt> (which hold references back to the parent
<tt class="docutils literal">agen</tt> object.)</p>
<p>The data flow is defined as follows:</p>
<ol class="arabic">
<li><p class="first">When <tt class="docutils literal">PyAsyncGenASend.send(val)</tt> is called for the first time,
<tt class="docutils literal">val</tt> is pushed to the parent <tt class="docutils literal">agen</tt> object (using existing
facilities of <tt class="docutils literal">PyGenObject</tt>.)</p>
<p>Subsequent iterations over the <tt class="docutils literal">PyAsyncGenASend</tt> objects, push
<tt class="docutils literal">None</tt> to <tt class="docutils literal">agen</tt>.</p>
<p>When a <tt class="docutils literal">_PyAsyncGenWrappedValue</tt> object is yielded, it
is unboxed, and a <tt class="docutils literal">StopIteration</tt> exception is raised with the
unwrapped value as an argument.</p>
</li>
<li><p class="first">When <tt class="docutils literal"><span class="pre">PyAsyncGenASend.throw(*exc)</span></tt> is called for the first time,
<tt class="docutils literal">*exc</tt> is throwed into the parent <tt class="docutils literal">agen</tt> object.</p>
<p>Subsequent iterations over the <tt class="docutils literal">PyAsyncGenASend</tt> objects, push
<tt class="docutils literal">None</tt> to <tt class="docutils literal">agen</tt>.</p>
<p>When a <tt class="docutils literal">_PyAsyncGenWrappedValue</tt> object is yielded, it
is unboxed, and a <tt class="docutils literal">StopIteration</tt> exception is raised with the
unwrapped value as an argument.</p>
</li>
<li><p class="first"><tt class="docutils literal">return</tt> statements in asynchronous generators raise
<tt class="docutils literal">StopAsyncIteration</tt> exception, which is propagated through
<tt class="docutils literal">PyAsyncGenASend.send()</tt> and <tt class="docutils literal">PyAsyncGenASend.throw()</tt> methods.</p>
</li>
</ol>
<p><tt class="docutils literal">PyAsyncGenAThrow</tt> is very similar to <tt class="docutils literal">PyAsyncGenASend</tt>.  The only
difference is that <tt class="docutils literal">PyAsyncGenAThrow.send()</tt>, when called first time,
throws an exception into the parent <tt class="docutils literal">agen</tt> object (instead of pushing
a value into it.)</p>
</div>
</div>
<div class="section" id="new-standard-library-functions-and-types">
<h2><a class="toc-backref" href="#id17">New Standard Library Functions and Types</a></h2>
<ol class="arabic simple">
<li><tt class="docutils literal">types.AsyncGeneratorType</tt> -- type of asynchronous generator
object.</li>
<li><tt class="docutils literal">sys.set_asyncgen_hooks()</tt> and <tt class="docutils literal">sys.get_asyncgen_hooks()</tt>
methods to set up asynchronous generators finalizers and iteration
interceptors in event loops.</li>
<li><tt class="docutils literal">inspect.isasyncgen()</tt> and <tt class="docutils literal">inspect.isasyncgenfunction()</tt>
introspection functions.</li>
<li>New method for asyncio event loop: <tt class="docutils literal">loop.shutdown_asyncgens()</tt>.</li>
<li>New <tt class="docutils literal">collections.abc.AsyncGenerator</tt> abstract base class.</li>
</ol>
</div>
<div class="section" id="backwards-compatibility">
<h2><a class="toc-backref" href="#id18">Backwards Compatibility</a></h2>
<p>The proposal is fully backwards compatible.</p>
<p>In Python 3.5 it is a <tt class="docutils literal">SyntaxError</tt> to define an <tt class="docutils literal">async def</tt>
function with a <tt class="docutils literal">yield</tt> expression inside, therefore it's safe to
introduce asynchronous generators in 3.6.</p>
</div>
</div>
<div class="section" id="performance">
<h1><a class="toc-backref" href="#id19">Performance</a></h1>
<div class="section" id="regular-generators">
<h2><a class="toc-backref" href="#id20">Regular Generators</a></h2>
<p>There is no performance degradation for regular generators.
The following micro benchmark runs at the same speed on CPython with
and without asynchronous generators:</p>
<pre class="literal-block">
def gen():
    i = 0
    while i &lt; 100000000:
        yield i
        i += 1

list(gen())
</pre>
</div>
<div class="section" id="improvements-over-asynchronous-iterators">
<h2><a class="toc-backref" href="#id21">Improvements over asynchronous iterators</a></h2>
<p>The following micro-benchmark shows that asynchronous generators
are about <strong>2.3x faster</strong> than asynchronous iterators implemented in
pure Python:</p>
<pre class="literal-block">
N = 10 ** 7

async def agen():
    for i in range(N):
        yield i

class AIter:
    def __init__(self):
        self.i = 0

    def __aiter__(self):
        return self

    async def __anext__(self):
        i = self.i
        if i &gt;= N:
            raise StopAsyncIteration
        self.i += 1
        return i
</pre>
</div>
</div>
<div class="section" id="design-considerations">
<h1><a class="toc-backref" href="#id22">Design Considerations</a></h1>
<div class="section" id="aiter-and-anext-builtins">
<h2><a class="toc-backref" href="#id23"><tt class="docutils literal">aiter()</tt> and <tt class="docutils literal">anext()</tt> builtins</a></h2>
<p>Originally, <a class="reference external" href="/dev/peps/pep-0492">PEP 492</a> defined <tt class="docutils literal">__aiter__</tt> as a method that should
return an <em>awaitable</em> object, resulting in an asynchronous iterator.</p>
<p>However, in CPython 3.5.2, <tt class="docutils literal">__aiter__</tt> was redefined to return
asynchronous iterators directly.  To avoid breaking backwards
compatibility, it was decided that Python 3.6 will support both
ways: <tt class="docutils literal">__aiter__</tt> can still return an <em>awaitable</em> with
a <tt class="docutils literal">DeprecationWarning</tt> being issued.</p>
<p>Because of this dual nature of <tt class="docutils literal">__aiter__</tt> in Python 3.6, we cannot
add a synchronous implementation of <tt class="docutils literal">aiter()</tt> built-in.  Therefore,
it is proposed to wait until Python 3.7.</p>
</div>
<div class="section" id="asynchronous-list-dict-set-comprehensions">
<h2><a class="toc-backref" href="#id24">Asynchronous list/dict/set comprehensions</a></h2>
<p>Syntax for asynchronous comprehensions is unrelated to the asynchronous
generators machinery, and should be considered in a separate PEP.</p>
</div>
<div class="section" id="asynchronous-yield-from">
<h2><a class="toc-backref" href="#id25">Asynchronous <tt class="docutils literal">yield from</tt></a></h2>
<p>While it is theoretically possible to implement <tt class="docutils literal">yield from</tt> support
for asynchronous generators, it would require a serious redesign of the
generators implementation.</p>
<p><tt class="docutils literal">yield from</tt> is also less critical for asynchronous generators, since
there is no need provide a mechanism of implementing another coroutines
protocol on top of coroutines.  And to compose asynchronous generators a
simple <tt class="docutils literal">async for</tt> loop can be used:</p>
<pre class="literal-block">
async def g1():
    yield 1
    yield 2

async def g2():
    async for v in g1():
        yield v
</pre>
</div>
<div class="section" id="why-the-asend-and-athrow-methods-are-necessary">
<h2><a class="toc-backref" href="#id26">Why the <tt class="docutils literal">asend()</tt> and <tt class="docutils literal">athrow()</tt> methods are necessary</a></h2>
<p>They make it possible to implement concepts similar to
<tt class="docutils literal">contextlib.contextmanager</tt> using asynchronous generators.
For instance, with the proposed design, it is possible to implement
the following pattern:</p>
<pre class="literal-block">
&#64;async_context_manager
async def ctx():
    await open()
    try:
        yield
    finally:
        await close()

async with ctx():
    await ...
</pre>
<p>Another reason is that it is possible to push data and throw exceptions
into asynchronous generators using the object returned from
<tt class="docutils literal">__anext__</tt> object, but it is hard to do that correctly.  Adding
explicit <tt class="docutils literal">asend()</tt> and <tt class="docutils literal">athrow()</tt> will pave a safe way to
accomplish that.</p>
<p>In terms of implementation, <tt class="docutils literal">asend()</tt> is a slightly more generic
version of <tt class="docutils literal">__anext__</tt>, and <tt class="docutils literal">athrow()</tt> is very similar to
<tt class="docutils literal">aclose()</tt>.  Therefore having these methods defined for asynchronous
generators does not add any extra complexity.</p>
</div>
</div>
<div class="section" id="example">
<h1><a class="toc-backref" href="#id27">Example</a></h1>
<p>A working example with the current reference implementation (will
print numbers from 0 to 9 with one second delay):</p>
<pre class="literal-block">
async def ticker(delay, to):
    for i in range(to):
        yield i
        await asyncio.sleep(delay)


async def run():
    async for i in ticker(1, 10):
        print(i)


import asyncio
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(run())
finally:
    loop.close()
</pre>
</div>
<div class="section" id="acceptance">
<h1><a class="toc-backref" href="#id28">Acceptance</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0525">PEP 525</a> was accepted by Guido, September 6, 2016 <a class="footnote-reference" href="#id5" id="id1">[2]</a>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id29">Implementation</a></h1>
<p>The implementation is tracked in issue 28003 <a class="footnote-reference" href="#id6" id="id2">[3]</a>.  The reference
implementation git repository is available at <a class="footnote-reference" href="#id4" id="id3">[1]</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id30">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><a class="reference external" href="https://github.com/1st1/cpython/tree/async_gen">https://github.com/1st1/cpython/tree/async_gen</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-September/146267.html">https://mail.python.org/pipermail/python-dev/2016-September/146267.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td><a class="reference external" href="http://bugs.python.org/issue28003">http://bugs.python.org/issue28003</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id31">Acknowledgments</a></h1>
<p>I thank Guido van Rossum, Victor Stinner, Elvis Pranskevichus,
Nathaniel Smith, ≈Åukasz Langa, Andrew Svetlov and many others
for their feedback, code reviews, and discussions around this
PEP.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id32">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

