<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">575</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Unifying function/method classes</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Jeroen Demeyer &lt;J.Demeyer&#32;&#97;t&#32;UGent.be&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Mar-2018</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.8</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">31-Mar-2018, 12-Apr-2018</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id12">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id13">Motivation</a></li>
<li><a class="reference internal" href="#new-classes" id="id14">New classes</a><ul>
<li><a class="reference internal" href="#base-function" id="id15">base_function</a></li>
<li><a class="reference internal" href="#builtin-function" id="id16">builtin_function</a></li>
<li><a class="reference internal" href="#defined-function" id="id17">defined_function</a></li>
<li><a class="reference internal" href="#function" id="id18">function</a></li>
<li><a class="reference internal" href="#bound-method" id="id19">bound_method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#calling-base-function-instances" id="id20">Calling base_function instances</a><ul>
<li><a class="reference internal" href="#objclass" id="id21">__objclass__</a></li>
<li><a class="reference internal" href="#flags" id="id22">Flags</a></li>
<li><a class="reference internal" href="#self-slicing" id="id23">Self slicing</a></li>
<li><a class="reference internal" href="#meth-fastcall" id="id24">METH_FASTCALL</a></li>
<li><a class="reference internal" href="#meth-arg0-function" id="id25">METH_ARG0_FUNCTION</a></li>
</ul>
</li>
<li><a class="reference internal" href="#automatic-creation-of-built-in-functions" id="id26">Automatic creation of built-in functions</a><ul>
<li><a class="reference internal" href="#built-in-unbound-methods" id="id27">Built-in unbound methods</a></li>
<li><a class="reference internal" href="#built-in-functions-of-a-module" id="id28">Built-in functions of a module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#further-changes" id="id29">Further changes</a><ul>
<li><a class="reference internal" href="#new-type-flag" id="id30">New type flag</a></li>
<li><a class="reference internal" href="#c-api-functions" id="id31">C API functions</a></li>
<li><a class="reference internal" href="#changes-to-the-types-module" id="id32">Changes to the types module</a></li>
<li><a class="reference internal" href="#changes-to-the-inspect-module" id="id33">Changes to the inspect module</a></li>
<li><a class="reference internal" href="#profiling" id="id34">Profiling</a></li>
<li><a class="reference internal" href="#user-flags-in-pycfunctiondef-ml-flags-meth-usrx" id="id35">User flags in PyCFunctionDef.ml_flags: METH_USRx</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-cpython-implementations" id="id36">Non-CPython implementations</a></li>
<li><a class="reference internal" href="#rationale" id="id37">Rationale</a><ul>
<li><a class="reference internal" href="#why-not-simply-change-existing-classes" id="id38">Why not simply change existing classes?</a></li>
<li><a class="reference internal" href="#why-text-signature-is-not-a-solution" id="id39">Why __text_signature__ is not a solution</a></li>
<li><a class="reference internal" href="#defined-function-versus-function" id="id40">defined_function versus function</a></li>
<li><a class="reference internal" href="#scope-of-this-pep-which-classes-are-involved" id="id41">Scope of this PEP: which classes are involved?</a></li>
<li><a class="reference internal" href="#not-treating-meth-static-and-meth-class" id="id42">Not treating METH_STATIC and METH_CLASS</a></li>
<li><a class="reference internal" href="#self-in-base-function" id="id43">__self__ in base_function</a></li>
<li><a class="reference internal" href="#two-implementations-of-doc" id="id44">Two implementations of __doc__</a></li>
<li><a class="reference internal" href="#subclassing" id="id45">Subclassing</a></li>
<li><a class="reference internal" href="#replacing-tp-call-meth-arg0-function" id="id46">Replacing tp_call: METH_ARG0_FUNCTION</a></li>
<li><a class="reference internal" href="#user-flags-meth-custom-and-meth-usrx" id="id47">User flags: METH_CUSTOM and METH_USRx</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id48">Backwards compatibility</a><ul>
<li><a class="reference internal" href="#changes-to-types-and-inspect" id="id49">Changes to types and inspect</a></li>
<li><a class="reference internal" href="#python-functions" id="id50">Python functions</a></li>
<li><a class="reference internal" href="#id10" id="id51">Built-in functions of a module</a></li>
<li><a class="reference internal" href="#built-in-bound-and-unbound-methods" id="id52">Built-in bound and unbound methods</a></li>
<li><a class="reference internal" href="#new-attributes" id="id53">New attributes</a></li>
<li><a class="reference internal" href="#method-descriptor-and-pydescr-newmethod" id="id54">method_descriptor and PyDescr_NewMethod</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation" id="id55">Reference Implementation</a></li>
<li><a class="reference internal" href="#appendix-current-situation" id="id56">Appendix: current situation</a><ul>
<li><a class="reference internal" href="#builtin-function-or-method-built-in-functions-and-bound-methods" id="id57">builtin_function_or_method: built-in functions and bound methods</a></li>
<li><a class="reference internal" href="#method-descriptor-built-in-unbound-methods" id="id58">method_descriptor: built-in unbound methods</a></li>
<li><a class="reference internal" href="#function-python-functions" id="id59">function: Python functions</a></li>
<li><a class="reference internal" href="#method-python-bound-methods" id="id60">method: Python bound methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id61">References</a></li>
<li><a class="reference internal" href="#copyright" id="id62">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id12">Abstract</a></h1>
<p>Reorganize the class hierarchy for functions and methods
with the goal of reducing the difference between
built-in functions (implemented in C) and Python functions.
Mainly, make built-in functions behave more like Python functions
without sacrificing performance.</p>
<p>A new base class <tt class="docutils literal">base_function</tt> is introduced and the various function
classes, as well as <tt class="docutils literal">method</tt> (renamed to <tt class="docutils literal">bound_method</tt>), inherit from it.</p>
<p>We also allow subclassing of some of these function classes.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id13">Motivation</a></h1>
<p>Currently, CPython has two different function classes:
the first is Python functions, which is what you get
when defining a function with <tt class="docutils literal">def</tt> or <tt class="docutils literal">lambda</tt>.
The second is built-in functions such as <tt class="docutils literal">len</tt>, <tt class="docutils literal">isinstance</tt> or <tt class="docutils literal">numpy.dot</tt>.
These are implemented in C.</p>
<p>These two classes are completely independent with different functionality.
In particular, it is currently not possible to implement a function efficiently in C
(only built-in functions can do that)
while still allowing introspection like <tt class="docutils literal">inspect.signature</tt> or <tt class="docutils literal">inspect.getsourcefile</tt>
(only Python functions can do that).
This is a problem for projects like Cython <a class="footnote-reference" href="#cython" id="id1">[1]</a> that want to do exactly that.</p>
<p>In Cython, this was worked around by inventing a new function class called <tt class="docutils literal">cyfunction</tt>.
Unfortunately, a new function class creates problems:
the <tt class="docutils literal">inspect</tt> module does not recognize such functions as being functions <a class="footnote-reference" href="#bpo30071" id="id2">[2]</a>
and the performance is worse
(CPython has specific optimizations for calling built-in functions).</p>
<p>A second motivation is more generally making built-in functions and methods
behave more like Python functions and methods.
For example, Python unbound methods are just functions but
unbound methods of extension types (e.g. <tt class="docutils literal">dict.get</tt>) are a distinct class.
Bound methods of Python classes have a <tt class="docutils literal">__func__</tt> attribute,
bound methods of extension types do not.</p>
</div>
<div class="section" id="new-classes">
<h1><a class="toc-backref" href="#id14">New classes</a></h1>
<p>This is the new class hierarchy for functions and methods:</p>
<pre class="literal-block">
                   object
                      |
                      |
               base_function
              /       |     \
             /        |      \
            /         |   defined_function
           /          |        \
builtin_function (*)  |         \
                      |       function
                      |
                bound_method (*)
</pre>
<p>The two classes marked with (*) do <em>not</em> allow subclassing;
the others do.</p>
<p>There is no difference between functions and unbound methods,
while bound methods are instances of <tt class="docutils literal">bound_method</tt>.</p>
<div class="section" id="base-function">
<h2><a class="toc-backref" href="#id15">base_function</a></h2>
<p>The class <tt class="docutils literal">base_function</tt> becomes a new base class for all function types.
It behaves like the existing <tt class="docutils literal">builtin_function_or_method</tt>
with some differences:</p>
<ol class="arabic simple">
<li>It acts as a descriptor implementing <tt class="docutils literal">__get__</tt> to turn a function into a method
if <tt class="docutils literal">m_self</tt> is <tt class="docutils literal">NULL</tt>.
If <tt class="docutils literal">m_self</tt> is not <tt class="docutils literal">NULL</tt>,
then this is a no-op: the existing function is returned instead.</li>
<li>A new read-only slot <tt class="docutils literal">__objclass__</tt>, represented in the C structure as <tt class="docutils literal">m_objclass</tt>.
If this attribute exists, it must be a class.
If so, the function must be called with <tt class="docutils literal">self</tt> being an instance of that class.
This is mainly meant to support unbound methods of extension types,
replacing <tt class="docutils literal">method_descriptor</tt>.
Also <tt class="docutils literal">__qualname__</tt> will use <tt class="docutils literal">__objclass__</tt> as namespace
(instead of <tt class="docutils literal">m_self</tt> before).</li>
<li>Argument Clinic <a class="footnote-reference" href="#clinic" id="id3">[6]</a> is not supported.</li>
<li>The field <tt class="docutils literal">ml_doc</tt> and the attributes <tt class="docutils literal">__doc__</tt> and <tt class="docutils literal">__text_signature__</tt>
are gone.</li>
<li>A new flag <tt class="docutils literal">METH_ARG0_FUNCTION</tt> for <tt class="docutils literal">ml_flags</tt>.
If this flag is set, the C function stored in <tt class="docutils literal">ml_meth</tt> will be called with first argument
equal to the function object instead of <tt class="docutils literal">m_self</tt>.</li>
<li>A new flag <tt class="docutils literal">METH_BINDING</tt> for <tt class="docutils literal">ml_flags</tt> which only applies to
functions of a module (not methods of a class).
If this flag is set, then <tt class="docutils literal">m_self</tt> will be set to <tt class="docutils literal">NULL</tt> instead
of the module.
This allows the function to behave more like a Python function
as it enables <tt class="docutils literal">__get__</tt>.
This flag also enables <a class="reference internal" href="#self-slicing">Self slicing</a>.</li>
<li>A new flag <tt class="docutils literal">METH_PYTHON</tt> for <tt class="docutils literal">ml_flags</tt>.
This flag indicates that this function should be treated as Python function.
Ideally, use of this flag should be avoided because it goes
against the duck typing philosophy.
It is still needed in a few places though, for example <a class="reference internal" href="#profiling">Profiling</a>.</li>
<li>A new flag <tt class="docutils literal">METH_CUSTOM</tt> for <tt class="docutils literal">ml_flags</tt> which prevents automatic
generation of a <tt class="docutils literal">builtin_function</tt>, see <a class="reference internal" href="#automatic-creation-of-built-in-functions">Automatic creation of built-in functions</a>.</li>
</ol>
<p>The goal of <tt class="docutils literal">base_function</tt> is that it supports all different ways
of calling functions and methods in just one structure.
For example, the new flag <tt class="docutils literal">METH_ARG0_FUNCTION</tt>
will be used by the implementation of Python functions.</p>
<p>It is not possible to directly create instances of <tt class="docutils literal">base_function</tt>
(<tt class="docutils literal">tp_new</tt> is <tt class="docutils literal">NULL</tt>).
However, it is legal for C code to manually create instances.</p>
<p>These are the relevant C structures:</p>
<pre class="literal-block">
PyTypeObject PyBaseFunction_Type;

typedef struct {
    PyObject_HEAD
    PyCFunctionDef *m_ml;     /* Description of the C function to call */
    PyObject *m_self;         /* __self__: anything, can be NULL; readonly */
    PyObject *m_module;       /* __module__: anything */
    PyTypeObject *m_objclass; /* __objclass__: type or NULL; readonly */
    PyObject *m_weakreflist;  /* List of weak references */
} PyBaseFunctionObject;

typedef struct {
    const char *ml_name;   /* The name of the built-in function/method */
    PyCFunction ml_meth;   /* The C function that implements it */
    int ml_flags;          /* Combination of METH_xxx flags, which mostly
                              describe the args expected by the C func */
} PyCFunctionDef;
</pre>
<p>Subclasses may extend <tt class="docutils literal">PyCFunctionDef</tt> with extra fields.</p>
<p>The Python attribute <tt class="docutils literal">__self__</tt> returns <tt class="docutils literal">m_self</tt>,
except if <tt class="docutils literal">METH_STATIC</tt> is set.
In that case, <tt class="docutils literal">None</tt> is returned.
If <tt class="docutils literal">m_self</tt> is <tt class="docutils literal">NULL</tt>, then there is no <tt class="docutils literal">__self__</tt> attribute at all.
For that reason, we write either <tt class="docutils literal">m_self</tt> or <tt class="docutils literal">__self__</tt> in this PEP
with slightly different meanings.</p>
</div>
<div class="section" id="builtin-function">
<h2><a class="toc-backref" href="#id16">builtin_function</a></h2>
<p>This is a copy of <tt class="docutils literal">base_function</tt>, with the following differences:</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal">m_ml</tt> points to a <tt class="docutils literal">PyMethodDef</tt> structure,
extending <tt class="docutils literal">PyCFunctionDef</tt> with an additional <tt class="docutils literal">ml_doc</tt>
field to implement <tt class="docutils literal">__doc__</tt> and <tt class="docutils literal">__text_signature__</tt>
as read-only attributes:</p>
<pre class="literal-block">
typedef struct {
    const char *ml_name;
    PyCFunction ml_meth;
    int ml_flags;
    const char *ml_doc;
} PyMethodDef;
</pre>
<p>Note that <tt class="docutils literal">PyMethodDef</tt> is part of the Python Stable ABI <a class="footnote-reference" href="#abi" id="id4">[5]</a>
and it is used by most extension modules,
so we absolutely cannot change this structure.</p>
</li>
<li><p class="first">Argument Clinic <a class="footnote-reference" href="#clinic" id="id5">[6]</a> is supported.</p>
</li>
</ol>
<p>The type object is <tt class="docutils literal">PyTypeObject PyCFunction_Type</tt>
and we define <tt class="docutils literal">PyCFunctionObject</tt> as alias of <tt class="docutils literal">PyBaseFunctionObject</tt>.</p>
</div>
<div class="section" id="defined-function">
<h2><a class="toc-backref" href="#id17">defined_function</a></h2>
<p>The class <tt class="docutils literal">defined_function</tt> (a subclass of <tt class="docutils literal">base_function</tt>) adds
support for various standard attributes which are used in <tt class="docutils literal">inspect</tt>.
This would be a good class to use for auto-generated C code, for example produced by Cython <a class="footnote-reference" href="#cython" id="id6">[1]</a>.</p>
<p>The layout of the C structure is as follows:</p>
<pre class="literal-block">
PyTypeObject PyDefinedFunction_Type;

typedef struct {
    PyBaseFunctionObject base;
    PyObject *func_code;        /* __code__: code */
    PyObject *func_globals;     /* __globals__: anything; readonly */
    PyObject *func_name;        /* __name__: string */
    PyObject *func_qualname;    /* __qualname__: string */
    PyObject *func_doc;         /* __doc__: can be anything or NULL */
    PyObject *func_defaults;    /* __defaults__: tuple or NULL */
    PyObject *func_kwdefaults;  /* __kwdefaults__: dict or NULL */
    PyObject *func_closure;     /* __closure__: tuple of cell objects or NULL; readonly */
    PyObject *func_annotations; /* __annotations__: dict or NULL */
    PyObject *func_dict;        /* __dict__: dict or NULL */
} PyDefinedFunctionObject;
</pre>
<p>This class adds various slots like <tt class="docutils literal">__doc__</tt> and <tt class="docutils literal">__code__</tt> to access the C attributes.
The slot <tt class="docutils literal">__name__</tt> returns <tt class="docutils literal">func_name</tt>.
When setting <tt class="docutils literal">__name__</tt>, also <tt class="docutils literal">base.m_ml.ml_name</tt> is updated
with the UTF-8 encoded name.</p>
<p>None of the attributes is required to be meaningful.
In particular, <tt class="docutils literal">__code__</tt> may not be a working code object,
possibly only a few fields may be filled in.
And <tt class="docutils literal">__defaults__</tt> is not required to be used for calling the function.</p>
<p>Apart from adding these extra attributes,
<tt class="docutils literal">defined_function</tt> behaves exactly the same as <tt class="docutils literal">base_function</tt>.</p>
</div>
<div class="section" id="function">
<h2><a class="toc-backref" href="#id18">function</a></h2>
<p>This is the class meant for functions implemented in Python,
formerly known as <tt class="docutils literal">function</tt>.
Unlike the other function types,
instances of <tt class="docutils literal">function</tt> can be created from Python code.
This is not changed, so we do not describe the details in this PEP.</p>
<p>The layout of the C structure is almost the same as <tt class="docutils literal">defined_function</tt>:</p>
<pre class="literal-block">
PyTypeObject PyFunction_Type;

typedef struct {
    PyBaseFunctionObject base;
    PyObject *func_code;        /* __code__: code */
    PyObject *func_globals;     /* __globals__: dict; readonly */
    PyObject *func_name;        /* __name__: string */
    PyObject *func_qualname;    /* __qualname__: string */
    PyObject *func_doc;         /* __doc__: can be anything or NULL */
    PyObject *func_defaults;    /* __defaults__: tuple or NULL */
    PyObject *func_kwdefaults;  /* __kwdefaults__: dict or NULL */
    PyObject *func_closure;     /* __closure__: tuple of cell objects or NULL; readonly */
    PyObject *func_annotations; /* __annotations__: dict or NULL */
    PyObject *func_dict;        /* __dict__: dict or NULL */
    PyCFunctionDef _ml;         /* Storage for base.m_ml */
} PyFunctionObject;
</pre>
<p>The only difference is an <tt class="docutils literal">_ml</tt> field
which reserves space to be used by <tt class="docutils literal">base.m_ml</tt>.</p>
<p>When constructing an instance of <tt class="docutils literal">function</tt> from <tt class="docutils literal">code</tt> and <tt class="docutils literal">globals</tt>,
an instance is created with <tt class="docutils literal">base.m_ml = &amp;_ml</tt>,
<tt class="docutils literal">base.m_self = NULL</tt> and with the <tt class="docutils literal">METH_PYTHON</tt> flag set.</p>
<p>To make subclassing easier, we also add a copy constructor:
if <tt class="docutils literal">f</tt> is an instance of <tt class="docutils literal">defined_function</tt> with the <tt class="docutils literal">METH_PYTHON</tt>
flag set, then <tt class="docutils literal">types.FunctionType(f)</tt> copies <tt class="docutils literal">f</tt>.</p>
</div>
<div class="section" id="bound-method">
<h2><a class="toc-backref" href="#id19">bound_method</a></h2>
<p>The class <tt class="docutils literal">bound_method</tt> is used for all bound methods,
regardless of the class of the underlying function.
It adds one new attribute on top of <tt class="docutils literal">base_function</tt>:
<tt class="docutils literal">__func__</tt> points to that function.</p>
<p><tt class="docutils literal">bound_method</tt> replaces the old <tt class="docutils literal">method</tt> class
which was used only for Python functions bound as method.</p>
<p>There is a complication because we want to allow
constructing a method from an arbitrary callable.
This may be an already-bound method or simply not an instance of <tt class="docutils literal">base_function</tt>.
Therefore, in practice there are two kinds of methods:</p>
<ul class="simple">
<li>For arbitrary callables, we use a single fixed <tt class="docutils literal">PyCFunctionDef</tt>
structure with the <tt class="docutils literal">METH_ARG0_FUNCTION</tt> flag set.
The C function then calls <tt class="docutils literal">__func__</tt> with the correct arguments.</li>
<li>For methods which bind instances of <tt class="docutils literal">base_function</tt>
(more precisely, which have the <tt class="docutils literal">Py_TPFLAGS_BASEFUNCTION</tt> flag set)
that allow self slicing,
we instead use the <tt class="docutils literal">PyCFunctionDef</tt> from the original function.
In this case, the <tt class="docutils literal">__func__</tt> attribute is only used to implement
various attributes but not for calling the method.</li>
</ul>
<p>When constructing a new method from a <tt class="docutils literal">base_function</tt>,
we check that the <tt class="docutils literal">self</tt> object is an instance of <tt class="docutils literal">__objclass__</tt>
(if such a class was specified) and raise a <tt class="docutils literal">TypeError</tt> otherwise.</p>
<p>The C structure is:</p>
<pre class="literal-block">
PyTypeObject PyMethod_Type;

typedef struct {
    PyBaseFunctionObject base;
    PyObject *im_func;  /* __func__: function implementing the method; readonly */
} PyMethodObject;
</pre>
</div>
</div>
<div class="section" id="calling-base-function-instances">
<h1><a class="toc-backref" href="#id20">Calling base_function instances</a></h1>
<p>We specify the implementation of <tt class="docutils literal">__call__</tt> for instances of <tt class="docutils literal">base_function</tt>.</p>
<div class="section" id="objclass">
<h2><a class="toc-backref" href="#id21">__objclass__</a></h2>
<p>First of all, if the function has an <tt class="docutils literal">__objclass__</tt> attribute but
<tt class="docutils literal">m_self</tt> is <tt class="docutils literal">NULL</tt> (this is the case for unbound methods of extension types),
then the function must be called with at least one positional argument
and the first (typically called <tt class="docutils literal">self</tt>) must be an instance of <tt class="docutils literal">__objclass__</tt>.
If not, a <tt class="docutils literal">TypeError</tt> is raised.</p>
</div>
<div class="section" id="flags">
<h2><a class="toc-backref" href="#id22">Flags</a></h2>
<p>For convenience, we define a new constant:
<tt class="docutils literal">METH_CALLSIGNATURE</tt> combines all flags from <tt class="docutils literal">PyCFunctionDef.ml_flags</tt>
which specify the signature of the C function to be called.
It is equal to</p>
<pre class="literal-block">
METH_VARARGS | METH_FASTCALL | METH_NOARGS | METH_O | METH_KEYWORDS
</pre>
<p>Exactly one of the first four flags above must be set
and only <tt class="docutils literal">METH_VARARGS</tt> and <tt class="docutils literal">METH_FASTCALL</tt> may be combined with <tt class="docutils literal">METH_KEYWORDS</tt>.
Violating these rules is undefined behaviour.</p>
<p>There is one new flag which affects calling functions,
namely <tt class="docutils literal">METH_ARG0_FUNCTION</tt>.
Some flags are already documented in <a class="footnote-reference" href="#methoddoc" id="id7">[7]</a>.
We explain the other two shortly.</p>
</div>
<div class="section" id="self-slicing">
<h2><a class="toc-backref" href="#id23">Self slicing</a></h2>
<p>If the function has <tt class="docutils literal">m_self == NULL</tt>
and the flag <tt class="docutils literal">METH_ARG0_FUNCTION</tt> is not set,
then the first positional argument (if any)
is removed from <tt class="docutils literal">*args</tt> and instead passed as first argument to the C function.
Effectively, the first positional argument is treated as <tt class="docutils literal">__self__</tt>.
This process is called &quot;self slicing&quot; and is meant to support unbound methods.
This does not affect keyword arguments.</p>
</div>
<div class="section" id="meth-fastcall">
<h2><a class="toc-backref" href="#id24">METH_FASTCALL</a></h2>
<p>This is an existing but undocumented flag.
We suggest to officially support and document it.</p>
<p>If the flag <tt class="docutils literal">METH_FASTCALL</tt> is set without <tt class="docutils literal">METH_KEYWORDS</tt>,
then the <tt class="docutils literal">ml_meth</tt> field is of type <tt class="docutils literal">PyCFunctionFast</tt>
which takes the arguments <tt class="docutils literal">(PyObject *arg0, PyObject *const *args, Py_ssize_t nargs)</tt>.
Such a function takes only positional arguments and they are passed as plain C array
<tt class="docutils literal">args</tt> of length <tt class="docutils literal">nargs</tt>.</p>
<p>If the flags <tt class="docutils literal">METH_FASTCALL | METH_KEYWORDS</tt> are set,
then the <tt class="docutils literal">ml_meth</tt> field is of type <tt class="docutils literal">PyCFunctionFastWithKeywords</tt>
which takes the arguments <tt class="docutils literal">(PyObject *arg0, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)</tt>.
The positional arguments are passed as C array <tt class="docutils literal">args</tt> of length <tt class="docutils literal">nargs</tt>.
The <em>values</em> of the keyword arguments follow in that array,
starting at position <tt class="docutils literal">nargs</tt>.
The <em>keys</em> (names) of the keyword arguments are passed as a <tt class="docutils literal">tuple</tt> in <tt class="docutils literal">kwnames</tt>.
As an example, assume that 3 positional and 2 keyword arguments are given.
Then <tt class="docutils literal">args</tt> is an array of length 3 + 2 = 5, <tt class="docutils literal">nargs</tt> equals 3 and <tt class="docutils literal">kwnames</tt> is a 2-tuple.</p>
</div>
<div class="section" id="meth-arg0-function">
<h2><a class="toc-backref" href="#id25">METH_ARG0_FUNCTION</a></h2>
<p>If this flag is set, then the first argument to the C function
is the function itself (the <tt class="docutils literal">base_function</tt> instance) instead of <tt class="docutils literal">m_self</tt>.
In this case, the C function should deal with <tt class="docutils literal">__self__</tt>
by getting it from the function, for example using <tt class="docutils literal">PyBaseFunction_GET_SELF</tt>.</p>
</div>
</div>
<div class="section" id="automatic-creation-of-built-in-functions">
<h1><a class="toc-backref" href="#id26">Automatic creation of built-in functions</a></h1>
<p>Python automatically generates instances of <tt class="docutils literal">builtin_function</tt>
for extension types (using the <tt class="docutils literal">PyTypeObject.tp_methods</tt> field) and modules
(using the <tt class="docutils literal">PyModuleDef.m_methods</tt> field).
The arrays <tt class="docutils literal">PyTypeObject.tp_methods</tt> and <tt class="docutils literal">PyModuleDef.m_methods</tt>
must be arrays of <tt class="docutils literal">PyMethodDef</tt> structures.</p>
<p>If the <tt class="docutils literal">METH_CUSTOM</tt> flag is set for an element of such an array,
then no <tt class="docutils literal">builtin_function</tt> will be generated.
This allows an application to customize the creation of functions
in an extension type or module.
If <tt class="docutils literal">METH_CUSTOM</tt> is set, then <tt class="docutils literal">METH_STATIC</tt> and <tt class="docutils literal">METH_CLASS</tt> are ignored.</p>
<div class="section" id="built-in-unbound-methods">
<h2><a class="toc-backref" href="#id27">Built-in unbound methods</a></h2>
<p>The type of unbound methods changes from <tt class="docutils literal">method_descriptor</tt>
to <tt class="docutils literal">builtin_function</tt>.
The object which appears as unbound method is the same object which
appears in the class <tt class="docutils literal">__dict__</tt>.
Python automatically sets the <tt class="docutils literal">__objclass__</tt> attribute.</p>
</div>
<div class="section" id="built-in-functions-of-a-module">
<h2><a class="toc-backref" href="#id28">Built-in functions of a module</a></h2>
<p>For the case of functions of a module,
<tt class="docutils literal">__self__</tt> will be set to the module unless the flag <tt class="docutils literal">METH_BINDING</tt> is set.</p>
<p>An important consequence is that such functions by default
do not become methods when used as attribute
(<tt class="docutils literal">base_function.__get__</tt> only does that if <tt class="docutils literal">m_self</tt> was <tt class="docutils literal">NULL</tt>).
One could consider this a bug, but this was done for backwards compatibility reasons:
in an initial post on python-ideas <a class="footnote-reference" href="#proposal" id="id8">[8]</a> the concensus was to keep this
misfeature of built-in functions.</p>
<p>However, to allow this anyway for specific or newly implemented
built-in functions, the <tt class="docutils literal">METH_BINDING</tt> flag prevents setting <tt class="docutils literal">__self__</tt>.</p>
</div>
</div>
<div class="section" id="further-changes">
<h1><a class="toc-backref" href="#id29">Further changes</a></h1>
<div class="section" id="new-type-flag">
<h2><a class="toc-backref" href="#id30">New type flag</a></h2>
<p>A new <tt class="docutils literal">PyTypeObject</tt> flag (for <tt class="docutils literal">tp_flags</tt>) is added:
<tt class="docutils literal">Py_TPFLAGS_BASEFUNCTION</tt> to indicate that instances of this type are
functions which can be called as a <tt class="docutils literal">base_function</tt>.
In other words, subclasses of <tt class="docutils literal">base_function</tt>
which follow the implementation from <a class="reference internal" href="#calling-base-function-instances">Calling base_function instances</a>.</p>
<p>This is different from flags like <tt class="docutils literal">Py_TPFLAGS_LIST_SUBCLASS</tt>
because it indicates more than just a subclass:
it also indicates a default implementation of <tt class="docutils literal">__call__</tt>.
This flag is never inherited.
However, extension types can explicitly specify it if they
do not override <tt class="docutils literal">__call__</tt> or if they override <tt class="docutils literal">__call__</tt> in a compatible way.
The flag <tt class="docutils literal">Py_TPFLAGS_BASEFUNCTION</tt> must never be set for a heap type
because that would not be safe (heap types can be changed dynamically).</p>
</div>
<div class="section" id="c-api-functions">
<h2><a class="toc-backref" href="#id31">C API functions</a></h2>
<p>We list some relevant Python/C API macros and functions.
Some of these are existing (possibly changed) functions, some are new:</p>
<ul class="simple">
<li><tt class="docutils literal">int PyBaseFunction_CheckFast(PyObject *op)</tt>: return true if <tt class="docutils literal">op</tt>
is an instance of a class with the <tt class="docutils literal">Py_TPFLAGS_BASEFUNCTION</tt> set.
This is the function that you need to use to determine
whether you can safely access the <tt class="docutils literal">base_function</tt> internals.</li>
<li><tt class="docutils literal">int PyBaseFunction_Check(PyObject *op)</tt>: return true if <tt class="docutils literal">op</tt>
is an instance of <tt class="docutils literal">base_function</tt>.</li>
<li><tt class="docutils literal">PyObject *PyBaseFunction_New(PyTypeObject *cls, PyCFunctionDef *ml, PyObject *self, PyObject *module, PyTypeObject *objclass)</tt>:
create a new instance of <tt class="docutils literal">cls</tt> (which must be a subclass of <tt class="docutils literal">base_function</tt>)
from the given data.</li>
<li><tt class="docutils literal">int PyCFunction_Check(PyObject *op)</tt>: return true if <tt class="docutils literal">op</tt>
is an instance of <tt class="docutils literal">builtin_function</tt>.</li>
<li><tt class="docutils literal">int PyCFunction_NewEx(PyMethodDef* ml, PyObject *self, PyObject* module)</tt>:
create a new instance of <tt class="docutils literal">builtin_function</tt>.
As special case, if <tt class="docutils literal">self</tt> is <tt class="docutils literal">NULL</tt>,
then set <tt class="docutils literal">self = Py_None</tt> instead (for backwards compatibility).</li>
<li>For many existing <tt class="docutils literal"><span class="pre">PyCFunction_...</span></tt> and <tt class="docutils literal">PyMethod_</tt> functions,
we define a new function <tt class="docutils literal"><span class="pre">PyBaseFunction_...</span></tt>
acting on <tt class="docutils literal">base_function</tt> instances.
For backwards compatibility,
the old functions are kept as aliases of the new functions.</li>
<li><tt class="docutils literal">int PyFunction_Check(PyObject *op)</tt>: return true if <tt class="docutils literal">op</tt>
is an instance of <tt class="docutils literal">defined_function</tt>.</li>
<li><tt class="docutils literal">PyObject *PyFunction_NewPython(PyTypeObject *cls, PyObject *code, PyObject *globals, PyObject *name, PyObject *qualname)</tt>:
create a new instance of <tt class="docutils literal">cls</tt> (which must be a sublass of <tt class="docutils literal">function</tt>)
from the given data.</li>
<li><tt class="docutils literal">PyObject *PyFunction_New(PyObject *code, PyObject *globals)</tt>:
create a new instance of <tt class="docutils literal">function</tt>.</li>
<li><tt class="docutils literal">PyObject *PyFunction_NewWithQualName(PyObject *code, PyObject *globals, PyObject *qualname)</tt>:
create a new instance of <tt class="docutils literal">function</tt>.</li>
<li><tt class="docutils literal">PyObject *PyFunction_Copy(PyTypeObject *cls, PyObject *func)</tt>:
create a new instance of <tt class="docutils literal">cls</tt> (which must be a sublass of <tt class="docutils literal">function</tt>)
by copying a given <tt class="docutils literal">defined_function</tt>.</li>
<li>All other existing <tt class="docutils literal"><span class="pre">PyFunction_...</span></tt> functions now act on <tt class="docutils literal">defined_function</tt>
instances (instead of <tt class="docutils literal">function</tt>).</li>
</ul>
</div>
<div class="section" id="changes-to-the-types-module">
<h2><a class="toc-backref" href="#id32">Changes to the types module</a></h2>
<p>Two types are added: <tt class="docutils literal">types.BaseFunctionType</tt> corresponding to
<tt class="docutils literal">base_function</tt> and <tt class="docutils literal">types.DefinedFunctionType</tt> corresponding to
<tt class="docutils literal">defined_function</tt>.</p>
<p>Apart from that, no changes to the <tt class="docutils literal">types</tt> module are made.
In particular, <tt class="docutils literal">types.FunctionType</tt> refers to <tt class="docutils literal">function</tt>.
However, the actual types will change:
for example, <tt class="docutils literal">types.BuiltinFunctionType</tt> will no longer be the same
as <tt class="docutils literal">types.BuiltinMethodType</tt>.</p>
</div>
<div class="section" id="changes-to-the-inspect-module">
<h2><a class="toc-backref" href="#id33">Changes to the inspect module</a></h2>
<p><tt class="docutils literal">inspect.isbasefunction</tt> checks for an instance of <tt class="docutils literal">base_function</tt>.</p>
<p><tt class="docutils literal">inspect.isfunction</tt> checks for an instance of <tt class="docutils literal">defined_function</tt>.</p>
<p><tt class="docutils literal">inspect.isbuiltin</tt> checks for an instance of <tt class="docutils literal">builtin_function</tt>.</p>
<p><tt class="docutils literal">inspect.isroutine</tt> checks <tt class="docutils literal">isbasefunction</tt> or <tt class="docutils literal">ismethoddescriptor</tt>.</p>
<p>Note that bpo-33261 <a class="footnote-reference" href="#bpo33261" id="id9">[3]</a> should be fixed first.</p>
</div>
<div class="section" id="profiling">
<h2><a class="toc-backref" href="#id34">Profiling</a></h2>
<p>Currently, <tt class="docutils literal">sys.setprofile</tt> supports <tt class="docutils literal">c_call</tt>, <tt class="docutils literal">c_return</tt> and <tt class="docutils literal">c_exception</tt>
events for built-in functions.
These events are generated when calling or returning from a built-in function.
By contrast, the <tt class="docutils literal">call</tt> and <tt class="docutils literal">return</tt> events are generated by the function itself.
So nothing needs to change for the <tt class="docutils literal">call</tt> and <tt class="docutils literal">return</tt> events.</p>
<p>Since we no longer make a difference between C functions and Python functions,
we need to prevent the <tt class="docutils literal">c_*</tt> events for Python functions.
This is done by not generating those events if the
<tt class="docutils literal">METH_PYTHON</tt> flag in <tt class="docutils literal">ml_flags</tt> is set.</p>
</div>
<div class="section" id="user-flags-in-pycfunctiondef-ml-flags-meth-usrx">
<h2><a class="toc-backref" href="#id35">User flags in PyCFunctionDef.ml_flags: METH_USRx</a></h2>
<p>8 consecutive bits in <tt class="docutils literal">ml_flags</tt> are reserved for the &quot;user&quot;,
meaning the person or program who implemented the function.
These are <tt class="docutils literal">METH_USR0</tt>, ..., <tt class="docutils literal">METH_USR7</tt>.
Python will ignore these flags.</p>
<p>It should be clear that different users may use these flags
for different purposes, so users should only look at those flags in
functions that they implemented (for example, by looking for those flags
in the <tt class="docutils literal">tp_methods</tt> array of an extension type).</p>
</div>
</div>
<div class="section" id="non-cpython-implementations">
<h1><a class="toc-backref" href="#id36">Non-CPython implementations</a></h1>
<p>For other implementations of Python apart from CPython,
only the classes <tt class="docutils literal">base_function</tt>, <tt class="docutils literal">bound_method</tt> and <tt class="docutils literal">function</tt> are required.
The latter two are the only classes which can be instantiated directly
from the Python interpreter.
We require <tt class="docutils literal">base_function</tt> for consistency but we put no requirements on it:
it is acceptable if this is just a copy of <tt class="docutils literal">object</tt>.
Support for the new <tt class="docutils literal">__objclass__</tt> attribute is not required.
If there is no <tt class="docutils literal">defined_function</tt> type,
then <tt class="docutils literal">types.DefinedFunctionType</tt> should be an alias of <tt class="docutils literal">types.FunctionType</tt>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id37">Rationale</a></h1>
<div class="section" id="why-not-simply-change-existing-classes">
<h2><a class="toc-backref" href="#id38">Why not simply change existing classes?</a></h2>
<p>One could try to solve the problem not by introducing a new <tt class="docutils literal">base_function</tt>
class and changing the class hierarchy, but by just changing existing classes.</p>
<p>That might look like a simpler solution but it is not:
it would require introspection support for 3 distinct classes:
<tt class="docutils literal">function</tt>, <tt class="docutils literal">builtin_function_or_method</tt> and <tt class="docutils literal">method_descriptor</tt>.
In the current PEP, there is only a single class where introspection needs
to be implemented.
It is also not clear how this would interact with <tt class="docutils literal">__text_signature__</tt>.
Having two independent kinds of <tt class="docutils literal">inspect.signature</tt> support on the same
class sounds like asking for problems.</p>
<p>And this would not fix some of the other differences between built-in functions
and Python functions that were mentioned in the <a class="reference internal" href="#motivation">Motivation</a>.</p>
</div>
<div class="section" id="why-text-signature-is-not-a-solution">
<h2><a class="toc-backref" href="#id39">Why __text_signature__ is not a solution</a></h2>
<p>Built-in functions have an attribute <tt class="docutils literal">__text_signature__</tt>,
which gives the signature of the function as plain text.
The default values are evaluated by <tt class="docutils literal">ast.literal_eval</tt>.
Because of this, it supports only a small number of standard Python classes
and not arbitrary Python objects.</p>
<p>And even if <tt class="docutils literal">__text_signature__</tt> would allow arbitrary signatures somehow,
that is only one piece of introspection:
it does not help with <tt class="docutils literal">inspect.getsourcefile</tt> for example.</p>
</div>
<div class="section" id="defined-function-versus-function">
<h2><a class="toc-backref" href="#id40">defined_function versus function</a></h2>
<p>In many places, a decision needs to be made whether the old <tt class="docutils literal">function</tt> class
should be replaced by <tt class="docutils literal">defined_function</tt> or the new <tt class="docutils literal">function</tt> class.
This is done by thinking of the most likely use case:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">types.FunctionType</tt> refers to <tt class="docutils literal">function</tt> because that
type might be used to construct instances using <tt class="docutils literal"><span class="pre">types.FunctionType(...)</span></tt>.</li>
<li><tt class="docutils literal">inspect.isfunction()</tt> refers to <tt class="docutils literal">defined_function</tt>
because this is the class where introspection is supported.</li>
<li>The C API functions <tt class="docutils literal"><span class="pre">PyFunction_New...</span></tt>
refer to <tt class="docutils literal">function</tt> simply because one cannot create instances
of <tt class="docutils literal">defined_function</tt>.</li>
<li>The C API functions <tt class="docutils literal">PyFunction_Check</tt> and <tt class="docutils literal"><span class="pre">PyFunction_Get/Set...</span></tt>
refer to <tt class="docutils literal">defined_function</tt> because all attributes exist for instances of <tt class="docutils literal">defined_function</tt>.</li>
</ol>
</div>
<div class="section" id="scope-of-this-pep-which-classes-are-involved">
<h2><a class="toc-backref" href="#id41">Scope of this PEP: which classes are involved?</a></h2>
<p>The main motivation of this PEP is fixing function classes,
so we certainly want to unify the existing classes
<tt class="docutils literal">builtin_function_or_method</tt> and <tt class="docutils literal">function</tt>.</p>
<p>Since built-in functions and methods have the same class,
it seems natural to include bound methods too.
And since there are no &quot;unbound methods&quot; for Python functions,
it makes sense to get rid of unbound methods for extension types.</p>
<p>For now, no changes are made to the classes <tt class="docutils literal">staticmethod</tt>,
<tt class="docutils literal">classmethod</tt> and <tt class="docutils literal">classmethod_descriptor</tt>.
It would certainly make sense to put these in the <tt class="docutils literal">base_function</tt>
class hierarchy and unify <tt class="docutils literal">classmethod</tt> and <tt class="docutils literal">classmethod_descriptor</tt>.
However, this PEP is already big enough
and this is left as a possible future improvement.</p>
<p>Slot wrappers for extension types like <tt class="docutils literal">__init__</tt> or <tt class="docutils literal">__eq__</tt>
are quite different from normal methods.
They are also typically not called directly because you would normally
write <tt class="docutils literal">foo[i]</tt> instead of <tt class="docutils literal">foo.__getitem__(i)</tt> for example.
So these are left outside the scope of this PEP.</p>
<p>Python also has an <tt class="docutils literal">instancemethod</tt> class, which was used in Python 2
for unbound methods.
It is not clear whether there is still a use case for it.
In any case, there is no reason to deal with it in this PEP.</p>
<p><strong>TODO</strong>: should <tt class="docutils literal">instancemethod</tt> be deprecated?
It doesn't seem used at all within CPython 3.7,
but maybe external packages use it?</p>
</div>
<div class="section" id="not-treating-meth-static-and-meth-class">
<h2><a class="toc-backref" href="#id42">Not treating METH_STATIC and METH_CLASS</a></h2>
<p>Almost nothing in this PEP refers to the flags <tt class="docutils literal">METH_STATIC</tt> and <tt class="docutils literal">METH_CLASS</tt>.
These flags are checked only by the <a class="reference internal" href="#automatic-creation-of-built-in-functions">Automatic creation of built-in functions</a>.
When a <tt class="docutils literal">staticmethod</tt>, <tt class="docutils literal">classmethod</tt> or <tt class="docutils literal">classmethod_descriptor</tt>
is bound (i.e. <tt class="docutils literal">__get__</tt> is called),
a <tt class="docutils literal">base_function</tt> instance is created with <tt class="docutils literal">m_self != NULL</tt>.
For a <tt class="docutils literal">classmethod</tt>, this is obvious since <tt class="docutils literal">m_self</tt>
is the class that the method is bound to.
For a <tt class="docutils literal">staticmethod</tt>, one can take an arbitrary Python object for <tt class="docutils literal">m_self</tt>.
For backwards compatibility, we choose <tt class="docutils literal">m_self = __objclass__</tt> for static methods
of extension types.</p>
</div>
<div class="section" id="self-in-base-function">
<h2><a class="toc-backref" href="#id43">__self__ in base_function</a></h2>
<p>It may look strange at first sight to add the <tt class="docutils literal">__self__</tt> slot
in <tt class="docutils literal">base_function</tt> as opposed to <tt class="docutils literal">bound_method</tt>.
We took this idea from the existing <tt class="docutils literal">builtin_function_or_method</tt> class.
It allows us to have a single general implementation of <tt class="docutils literal">__call__</tt> and <tt class="docutils literal">__get__</tt>
for the various function classes discussed in this PEP.</p>
<p>It also makes it easy to support existing built-in functions
which set <tt class="docutils literal">__self__</tt> to the module (for example, <tt class="docutils literal">sys.exit.__self__</tt> is <tt class="docutils literal">sys</tt>).</p>
</div>
<div class="section" id="two-implementations-of-doc">
<h2><a class="toc-backref" href="#id44">Two implementations of __doc__</a></h2>
<p><tt class="docutils literal">base_function</tt> does not support function docstrings.
Instead, the classes <tt class="docutils literal">builtin_function</tt> and <tt class="docutils literal">defined_function</tt>
each have their own way of dealing with docstrings
(and <tt class="docutils literal">bound_method</tt> just takes the <tt class="docutils literal">__doc__</tt> from the wrapped function).</p>
<p>For <tt class="docutils literal">builtin_function</tt>, the docstring is stored (together with the text signature)
as C string in the read-only <tt class="docutils literal">ml_doc</tt> field of a <tt class="docutils literal">PyMethodDef</tt>.
For <tt class="docutils literal">defined_function</tt>, the docstring is stored as a writable Python object
and it does not actually need to be a string.
This is done like this for backwards compatibility and because
it looks hard to unify these two very different ways of dealing with <tt class="docutils literal">__doc__</tt>.</p>
</div>
<div class="section" id="subclassing">
<h2><a class="toc-backref" href="#id45">Subclassing</a></h2>
<p>We disallow subclassing of <tt class="docutils literal">builtin_function</tt> and <tt class="docutils literal">bound_method</tt>
to enable fast type checks for <tt class="docutils literal">PyBuiltinFunction_Check</tt> and <tt class="docutils literal">PyMethod_Check()</tt>.</p>
<p>We allow subclassing of the other classes because there is no reason to disallow it.
For Python modules, the only relevant class to subclass is
<tt class="docutils literal">function</tt> because the others cannot be instantiated anyway.</p>
</div>
<div class="section" id="replacing-tp-call-meth-arg0-function">
<h2><a class="toc-backref" href="#id46">Replacing tp_call: METH_ARG0_FUNCTION</a></h2>
<p>The new flag <tt class="docutils literal">METH_ARG0_FUNCTION</tt> is meant to support cases where
formerly a custom <tt class="docutils literal">tp_call</tt> was used.
It would reduce the number of special fast paths in <tt class="docutils literal">Python/ceval.c</tt>
for calling objects:
instead of treating Python functions, built-in functions and methods,
there would only be a single check.</p>
<p>The signature of <tt class="docutils literal">tp_call</tt> is essentially the signature
of <tt class="docutils literal">PyBaseFunctionObject.m_ml.ml_meth</tt> with flags
<tt class="docutils literal">METH_VARARGS | METH_KEYWORDS | METH_ARG0_FUNCTION</tt>.
Therefore, it should be easy to change existing <tt class="docutils literal">tp_call</tt> slots
to use <tt class="docutils literal">METH_ARG0_FUNCTION</tt>.
There is one extra complication though: <tt class="docutils literal">__self__</tt> must be handled manually.</p>
</div>
<div class="section" id="user-flags-meth-custom-and-meth-usrx">
<h2><a class="toc-backref" href="#id47">User flags: METH_CUSTOM and METH_USRx</a></h2>
<p>These flags are meant for applications that want to use
<tt class="docutils literal">tp_methods</tt> for an extension type or <tt class="docutils literal">m_methods</tt> for a module
but that do not want the default built-in functions to be created.
Those applications would set <tt class="docutils literal">METH_CUSTOM</tt>.
The application is also free to use <tt class="docutils literal">METH_USR0</tt>, ..., <tt class="docutils literal">METH_USR7</tt>
for its own purposes,
for example to customize the creation of special function instances.</p>
<p>There is no immediate concrete use case,
but we expect that tools which auto-generate functions or extension types
may want to define custom flags.
Given that it costs essentially nothing to have these flags,
it seems like a good idea to allow it.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id48">Backwards compatibility</a></h1>
<p>While designing this PEP, great care was taken to not break
backwards compatibility too much.
In particular, Python code not using <tt class="docutils literal">inspect</tt> or type checks
should not be affected by this PEP.
For example, <tt class="docutils literal">staticmethod</tt>, <tt class="docutils literal">functools.partial</tt> or <tt class="docutils literal">operator.methodcaller</tt>
do not need to change at all.</p>
<div class="section" id="changes-to-types-and-inspect">
<h2><a class="toc-backref" href="#id49">Changes to types and inspect</a></h2>
<p>The proposed changes to <tt class="docutils literal">types</tt> and <tt class="docutils literal">inspect</tt>
are meant to minimize changes in behaviour.
However, it is unavoidable that some things change
and this can cause code which uses <tt class="docutils literal">types</tt> or <tt class="docutils literal">inspect</tt> to break.
In the Python standard library for example,
changes are needed in the <tt class="docutils literal">doctest</tt> module because of this.</p>
<p>Also, tools which take various kinds of functions as input will need to deal
with the new function hieararchy and the possibility of custom
function classes.</p>
</div>
<div class="section" id="python-functions">
<h2><a class="toc-backref" href="#id50">Python functions</a></h2>
<p>For Python functions, essentially nothing changes.
The attributes that existed before still exist and Python functions
can be initialized, called and turned into methods as before.</p>
<p>The name <tt class="docutils literal">function</tt> is kept for backwards compatibility.
While it might make sense to change the name to something more
specific like <tt class="docutils literal">python_function</tt>,
that would require a lot of annoying changes in documentation and testsuites.</p>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id51">Built-in functions of a module</a></h2>
<p>Also for built-in functions, nothing changes.
We keep the old behaviour that such functions do not bind as methods.
This is a consequence of the fact that <tt class="docutils literal">__self__</tt> is set to the module.</p>
</div>
<div class="section" id="built-in-bound-and-unbound-methods">
<h2><a class="toc-backref" href="#id52">Built-in bound and unbound methods</a></h2>
<p>The types of built-in bound and unbound methods will change.
However, this does not affect calling such methods
because the protocol in <tt class="docutils literal">base_function.__call__</tt>
(in particular the handling of <tt class="docutils literal">__objclass__</tt> and self slicing)
was specifically designed to be backwards compatible.
All attributes which existed before (like <tt class="docutils literal">__objclass__</tt> and <tt class="docutils literal">__self__</tt>)
still exist.</p>
</div>
<div class="section" id="new-attributes">
<h2><a class="toc-backref" href="#id53">New attributes</a></h2>
<p>Some objects get new special double-underscore attributes.
For example, <tt class="docutils literal">__objclass__</tt> now appears on bound methods too
and all methods get a <tt class="docutils literal">__func__</tt> attribute.
The fact that <tt class="docutils literal">__self__</tt> is now a special read-only attribute
for Python functions caused trouble in <a class="footnote-reference" href="#bpo33265" id="id11">[4]</a>.
Generally, we expect that not much will break though.</p>
</div>
<div class="section" id="method-descriptor-and-pydescr-newmethod">
<h2><a class="toc-backref" href="#id54">method_descriptor and PyDescr_NewMethod</a></h2>
<p>The classes <tt class="docutils literal">method_descriptor</tt> and the constructor <tt class="docutils literal">PyDescr_NewMethod</tt>
are deprecated and no longer used by CPython itself.
For now, they are kept for backwards compatibility.</p>
</div>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id55">Reference Implementation</a></h1>
<p>Most of this PEP has been implemented for CPython at
<a class="reference external" href="https://github.com/jdemeyer/cpython/tree/pep575">https://github.com/jdemeyer/cpython/tree/pep575</a></p>
<p>There are four steps, corresponding to the commits on that branch.
After each step, CPython is in a mostly working state.</p>
<ol class="arabic simple">
<li>Add the <tt class="docutils literal">base_function</tt> class and make it a subclass for <tt class="docutils literal">builtin_function</tt>.
This is by far the biggest step as the complete <tt class="docutils literal">__call__</tt> protocol
is implemented in this step.</li>
<li>Rename <tt class="docutils literal">method</tt> to <tt class="docutils literal">bound_method</tt> and make it a subclass of <tt class="docutils literal">base_function</tt>.
Change unbound methods of extension types to be instances of <tt class="docutils literal">builtin_function</tt>
such that bound methods of extension types are also instances of <tt class="docutils literal">bound_method</tt>.</li>
<li>Implement <tt class="docutils literal">defined_function</tt> and <tt class="docutils literal">function</tt>.</li>
<li>Changes to other parts of Python, such as the standard library and testsuite.</li>
</ol>
</div>
<div class="section" id="appendix-current-situation">
<h1><a class="toc-backref" href="#id56">Appendix: current situation</a></h1>
<p><strong>NOTE</strong>:
This section is more useful during the draft period of the PEP,
so feel free to remove this once the PEP has been accepted.</p>
<p>For reference, we describe in detail the relevant existing classes in CPython 3.7.</p>
<p>Each of the classes involved is an &quot;orphan&quot; class
(no non-trivial subclasses nor superclasses).</p>
<div class="section" id="builtin-function-or-method-built-in-functions-and-bound-methods">
<h2><a class="toc-backref" href="#id57">builtin_function_or_method: built-in functions and bound methods</a></h2>
<p>These are of type <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Objects/methodobject.c#L271">PyCFunction_Type</a>
with structure <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Include/methodobject.h#L102">PyCFunctionObject</a>:</p>
<pre class="literal-block">
typedef struct {
    PyObject_HEAD
    PyMethodDef *m_ml; /* Description of the C function to call */
    PyObject    *m_self; /* Passed as 'self' arg to the C func, can be NULL */
    PyObject    *m_module; /* The __module__ attribute, can be anything */
    PyObject    *m_weakreflist; /* List of weak references */
} PyCFunctionObject;

struct PyMethodDef {
    const char  *ml_name;   /* The name of the built-in function/method */
    PyCFunction ml_meth;    /* The C function that implements it */
    int         ml_flags;   /* Combination of METH_xxx flags, which mostly
                               describe the args expected by the C func */
    const char  *ml_doc;    /* The __doc__ attribute, or NULL */
};
</pre>
<p>where <tt class="docutils literal">PyCFunction</tt> is a C function pointer (there are various forms of this, the most basic
takes two arguments for <tt class="docutils literal">self</tt> and <tt class="docutils literal">*args</tt>).</p>
<p>This class is used both for functions and bound methods:
for a method, the <tt class="docutils literal">m_self</tt> slot points to the object:</p>
<pre class="literal-block">
&gt;&gt;&gt; dict(foo=42).get
&lt;built-in method get of dict object at 0x...&gt;
&gt;&gt;&gt; dict(foo=42).get.__self__
{'foo': 42}
</pre>
<p>In some cases, a function is considered a &quot;method&quot; of the module defining it:</p>
<pre class="literal-block">
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.kill
&lt;built-in function kill&gt;
&gt;&gt;&gt; os.kill.__self__
&lt;module 'posix' (built-in)&gt;
</pre>
</div>
<div class="section" id="method-descriptor-built-in-unbound-methods">
<h2><a class="toc-backref" href="#id58">method_descriptor: built-in unbound methods</a></h2>
<p>These are of type <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Objects/descrobject.c#L538">PyMethodDescr_Type</a>
with structure <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Include/descrobject.h#L53">PyMethodDescrObject</a>:</p>
<pre class="literal-block">
typedef struct {
    PyDescrObject d_common;
    PyMethodDef *d_method;
} PyMethodDescrObject;

typedef struct {
    PyObject_HEAD
    PyTypeObject *d_type;
    PyObject *d_name;
    PyObject *d_qualname;
} PyDescrObject;
</pre>
</div>
<div class="section" id="function-python-functions">
<h2><a class="toc-backref" href="#id59">function: Python functions</a></h2>
<p>These are of type <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Objects/funcobject.c#L592">PyFunction_Type</a>
with structure <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Include/funcobject.h#L21">PyFunctionObject</a>:</p>
<pre class="literal-block">
typedef struct {
    PyObject_HEAD
    PyObject *func_code;        /* A code object, the __code__ attribute */
    PyObject *func_globals;     /* A dictionary (other mappings won't do) */
    PyObject *func_defaults;    /* NULL or a tuple */
    PyObject *func_kwdefaults;  /* NULL or a dict */
    PyObject *func_closure;     /* NULL or a tuple of cell objects */
    PyObject *func_doc;         /* The __doc__ attribute, can be anything */
    PyObject *func_name;        /* The __name__ attribute, a string object */
    PyObject *func_dict;        /* The __dict__ attribute, a dict or NULL */
    PyObject *func_weakreflist; /* List of weak references */
    PyObject *func_module;      /* The __module__ attribute, can be anything */
    PyObject *func_annotations; /* Annotations, a dict or NULL */
    PyObject *func_qualname;    /* The qualified name */

    /* Invariant:
     *     func_closure contains the bindings for func_code-&gt;co_freevars, so
     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
     */
} PyFunctionObject;
</pre>
<p>In Python 3, there is no &quot;unbound method&quot; class:
an unbound method is just a plain function.</p>
</div>
<div class="section" id="method-python-bound-methods">
<h2><a class="toc-backref" href="#id60">method: Python bound methods</a></h2>
<p>These are of type <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Objects/classobject.c#L329">PyMethod_Type</a>
with structure <a class="reference external" href="https://github.com/python/cpython/blob/2cb4661707818cfd92556e7fdf9068a993577002/Include/classobject.h#L12">PyMethodObject</a>:</p>
<pre class="literal-block">
typedef struct {
    PyObject_HEAD
    PyObject *im_func;   /* The callable object implementing the method */
    PyObject *im_self;   /* The instance it is bound to */
    PyObject *im_weakreflist; /* List of weak references */
} PyMethodObject;
</pre>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id61">References</a></h1>
<table class="docutils footnote" frame="void" id="cython" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> Cython (<a class="reference external" href="http://cython.org/">http://cython.org/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bpo30071" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Python bug 30071, Duck-typing inspect.isfunction() (<a class="reference external" href="https://bugs.python.org/issue30071">https://bugs.python.org/issue30071</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bpo33261" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[3]</a></td><td>Python bug 33261, inspect.isgeneratorfunction fails on hand-created methods
(<a class="reference external" href="https://bugs.python.org/issue33261">https://bugs.python.org/issue33261</a> and <a class="reference external" href="https://github.com/python/cpython/pull/6448">https://github.com/python/cpython/pull/6448</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bpo33265" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[4]</a></td><td>Python bug 33265, contextlib.ExitStack abuses __self__
(<a class="reference external" href="https://bugs.python.org/issue33265">https://bugs.python.org/issue33265</a> and <a class="reference external" href="https://github.com/python/cpython/pull/6456">https://github.com/python/cpython/pull/6456</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="abi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[5]</a></td><td><a class="reference external" href="/dev/peps/pep-0384">PEP 384</a>, Defining a Stable ABI, Lwis (<a class="reference external" href="https://www.python.org/dev/peps/pep-0384">https://www.python.org/dev/peps/pep-0384</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="clinic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0436">PEP 436</a>, The Argument Clinic DSL, Hastings (<a class="reference external" href="https://www.python.org/dev/peps/pep-0436">https://www.python.org/dev/peps/pep-0436</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="methoddoc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>PyMethodDef documentation (<a class="reference external" href="https://docs.python.org/3.7/c-api/structures.html#c.PyMethodDef">https://docs.python.org/3.7/c-api/structures.html#c.PyMethodDef</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="proposal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>PEP proposal: unifying function/method classes (<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2018-March/049398.html">https://mail.python.org/pipermail/python-ideas/2018-March/049398.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id62">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

