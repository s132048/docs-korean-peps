<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">557</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Data Classes</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Eric V. Smith &lt;eric&#32;&#97;t&#32;trueblade.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">02-Jun-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">08-Sep-2017, 25-Nov-2017, 30-Nov-2017, 01-Dec-2017, 02-Dec-2017, 06-Jan-2018, 04-Mar-2018</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-December/151034.html">https://mail.python.org/pipermail/python-dev/2017-December/151034.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#notice-for-reviewers" id="id31">Notice for Reviewers</a></li>
<li><a class="reference internal" href="#abstract" id="id32">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id33">Rationale</a></li>
<li><a class="reference internal" href="#id7" id="id34">Specification</a><ul>
<li><a class="reference internal" href="#field-objects" id="id35"><tt class="docutils literal">Field</tt> objects</a></li>
<li><a class="reference internal" href="#post-init-processing" id="id36">post-init processing</a></li>
<li><a class="reference internal" href="#class-variables" id="id37">Class variables</a></li>
<li><a class="reference internal" href="#init-only-variables" id="id38">Init-only variables</a></li>
<li><a class="reference internal" href="#frozen-instances" id="id39">Frozen instances</a></li>
<li><a class="reference internal" href="#inheritance" id="id40">Inheritance</a></li>
<li><a class="reference internal" href="#default-factory-functions" id="id41">Default factory functions</a></li>
<li><a class="reference internal" href="#mutable-default-values" id="id42">Mutable default values</a></li>
<li><a class="reference internal" href="#module-level-helper-functions" id="id43">Module level helper functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10" id="id44">Discussion</a><ul>
<li><a class="reference internal" href="#python-ideas-discussion" id="id45">python-ideas discussion</a></li>
<li><a class="reference internal" href="#support-for-automatically-setting-slots" id="id46">Support for automatically setting <tt class="docutils literal">__slots__</tt>?</a></li>
<li><a class="reference internal" href="#why-not-just-use-namedtuple" id="id47">Why not just use namedtuple?</a></li>
<li><a class="reference internal" href="#why-not-just-use-typing-namedtuple" id="id48">Why not just use typing.NamedTuple?</a></li>
<li><a class="reference internal" href="#why-not-just-use-attrs" id="id49">Why not just use attrs?</a></li>
<li><a class="reference internal" href="#post-init-parameters" id="id50">post-init parameters</a></li>
<li><a class="reference internal" href="#asdict-and-astuple-function-names" id="id51">asdict and astuple function names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas" id="id52">Rejected ideas</a><ul>
<li><a class="reference internal" href="#copying-init-false-fields-after-new-object-creation-in-replace" id="id53">Copying <tt class="docutils literal">init=False</tt> fields after new object creation in replace()</a></li>
<li><a class="reference internal" href="#automatically-support-mutable-default-values" id="id54">Automatically support mutable default values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id55">Examples</a><ul>
<li><a class="reference internal" href="#custom-init-method" id="id56">Custom __init__ method</a></li>
<li><a class="reference internal" href="#a-complicated-example" id="id57">A complicated example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements" id="id58">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id59">References</a></li>
<li><a class="reference internal" href="#copyright" id="id60">Copyright</a></li>
</ul>
</div>
<div class="section" id="notice-for-reviewers">
<h1><a class="toc-backref" href="#id31">Notice for Reviewers</a></h1>
<p>This PEP and the initial implementation were drafted in a separate
repo: <a class="reference external" href="https://github.com/ericvsmith/dataclasses">https://github.com/ericvsmith/dataclasses</a>.  Before commenting in
a public forum please at least read the <a class="reference internal" href="#discussion">discussion</a> listed at the
end of this PEP.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id32">Abstract</a></h1>
<p>This PEP describes an addition to the standard library called Data
Classes.  Although they use a very different mechanism, Data Classes
can be thought of as &quot;mutable namedtuples with defaults&quot;.  Because
Data Classes use normal class definition syntax, you are free to use
inheritance, metaclasses, docstrings, user-defined methods, class
factories, and other Python class features.</p>
<p>A class decorator is provided which inspects a class definition for
variables with type annotations as defined in <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>, &quot;Syntax for
Variable Annotations&quot;.  In this document, such variables are called
fields.  Using these fields, the decorator adds generated method
definitions to the class to support instance initialization, a repr,
comparison methods, and optionally other methods as described in the
<a class="reference internal" href="#specification">Specification</a> section.  Such a class is called a Data Class, but
there's really nothing special about the class: the decorator adds
generated methods to the class and returns the same class it was
given.</p>
<p>As an example:</p>
<pre class="literal-block">
&#64;dataclass
class InventoryItem:
    '''Class for keeping track of an item in inventory.'''
    name: str
    unit_price: float
    quantity_on_hand: int = 0

    def total_cost(self) -&gt; float:
        return self.unit_price * self.quantity_on_hand
</pre>
<p>The <tt class="docutils literal">&#64;dataclass</tt> decorator will add the equivalent of these methods
to the InventoryItem class:</p>
<pre class="literal-block">
def __init__(self, name: str, unit_price: float, quantity_on_hand: int = 0) -&gt; None:
    self.name = name
    self.unit_price = unit_price
    self.quantity_on_hand = quantity_on_hand
def __repr__(self):
    return f'InventoryItem(name={self.name!r}, unit_price={self.unit_price!r}, quantity_on_hand={self.quantity_on_hand!r})'
def __eq__(self, other):
    if other.__class__ is self.__class__:
        return (self.name, self.unit_price, self.quantity_on_hand) == (other.name, other.unit_price, other.quantity_on_hand)
    return NotImplemented
def __ne__(self, other):
    if other.__class__ is self.__class__:
        return (self.name, self.unit_price, self.quantity_on_hand) != (other.name, other.unit_price, other.quantity_on_hand)
    return NotImplemented
def __lt__(self, other):
    if other.__class__ is self.__class__:
        return (self.name, self.unit_price, self.quantity_on_hand) &lt; (other.name, other.unit_price, other.quantity_on_hand)
    return NotImplemented
def __le__(self, other):
    if other.__class__ is self.__class__:
        return (self.name, self.unit_price, self.quantity_on_hand) &lt;= (other.name, other.unit_price, other.quantity_on_hand)
    return NotImplemented
def __gt__(self, other):
    if other.__class__ is self.__class__:
        return (self.name, self.unit_price, self.quantity_on_hand) &gt; (other.name, other.unit_price, other.quantity_on_hand)
    return NotImplemented
def __ge__(self, other):
    if other.__class__ is self.__class__:
        return (self.name, self.unit_price, self.quantity_on_hand) &gt;= (other.name, other.unit_price, other.quantity_on_hand)
    return NotImplemented
</pre>
<p>Data Classes save you from writing and maintaining these methods.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id33">Rationale</a></h1>
<p>There have been numerous attempts to define classes which exist
primarily to store values which are accessible by attribute lookup.
Some examples include:</p>
<ul class="simple">
<li>collection.namedtuple in the standard library.</li>
<li>typing.NamedTuple in the standard library.</li>
<li>The popular attrs <a class="footnote-reference" href="#id17" id="id1">[1]</a> project.</li>
<li>George Sakkis' recordType recipe <a class="footnote-reference" href="#id18" id="id2">[2]</a>, a mutable data type inspired
by collections.namedtuple.</li>
<li>Many example online recipes <a class="footnote-reference" href="#id19" id="id3">[3]</a>, packages <a class="footnote-reference" href="#id20" id="id4">[4]</a>, and questions <a class="footnote-reference" href="#id21" id="id5">[5]</a>.
David Beazley used a form of data classes as the motivating example
in a PyCon 2013 metaclass talk <a class="footnote-reference" href="#id22" id="id6">[6]</a>.</li>
</ul>
<p>So, why is this PEP needed?</p>
<p>With the addition of <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>, Python has a concise way to specify the
type of class members.  This PEP leverages that syntax to provide a
simple, unobtrusive way to describe Data Classes.  With two exceptions,
the specified attribute type annotation is completely ignored by Data
Classes.</p>
<p>No base classes or metaclasses are used by Data Classes.  Users of
these classes are free to use inheritance and metaclasses without any
interference from Data Classes.  The decorated classes are truly
&quot;normal&quot; Python classes.  The Data Class decorator should not
interfere with any usage of the class.</p>
<p>One main design goal of Data Classes is to support static type
checkers.  The use of <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a> syntax is one example of this, but so is
the design of the <tt class="docutils literal">fields()</tt> function and the <tt class="docutils literal">&#64;dataclass</tt>
decorator.  Due to their very dynamic nature, some of the libraries
mentioned above are difficult to use with static type checkers.</p>
<p>Data Classes are not, and are not intended to be, a replacement
mechanism for all of the above libraries.  But being in the standard
library will allow many of the simpler use cases to instead leverage
Data Classes.  Many of the libraries listed have different feature
sets, and will of course continue to exist and prosper.</p>
<p>Where is it not appropriate to use Data Classes?</p>
<ul class="simple">
<li>API compatibility with tuples or dicts is required.</li>
<li>Type validation beyond that provided by PEPs 484 and 526 is
required, or value validation or conversion is required.</li>
</ul>
</div>
<div class="section" id="id7">
<span id="specification"></span><h1><a class="toc-backref" href="#id34">Specification</a></h1>
<p>All of the functions described in this PEP will live in a module named
<tt class="docutils literal">dataclasses</tt>.</p>
<p>A function <tt class="docutils literal">dataclass</tt> which is typically used as a class decorator
is provided to post-process classes and add generated methods,
described below.</p>
<p>The <tt class="docutils literal">dataclass</tt> decorator examines the class to find <tt class="docutils literal">field</tt>s.  A
<tt class="docutils literal">field</tt> is defined as any variable identified in
<tt class="docutils literal">__annotations__</tt>.  That is, a variable that has a type annotation.
With two exceptions described below, none of the Data Class machinery
examines the type specified in the annotation.</p>
<p>Note that <tt class="docutils literal">__annotations__</tt> is guaranteed to be an ordered mapping,
in class declaration order.  The order of the fields in all of the
generated methods is the order in which they appear in the class.</p>
<p>The <tt class="docutils literal">dataclass</tt> decorator will add various &quot;dunder&quot; methods to the
class, described below.  If any of the added methods already exist on the
class, a <tt class="docutils literal">TypeError</tt> will be raised.  The decorator returns the same
class that is called on: no new class is created.</p>
<p>The <tt class="docutils literal">dataclass</tt> decorator is typically used with no parameters and
no parentheses.  However, it also supports the following logical
signature:</p>
<pre class="literal-block">
def dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)
</pre>
<p>If <tt class="docutils literal">dataclass</tt> is used just as a simple decorator with no
parameters, it acts as if it has the default values documented in this
signature.  That is, these three uses of <tt class="docutils literal">&#64;dataclass</tt> are equivalent:</p>
<pre class="literal-block">
&#64;dataclass
class C:
    ...

&#64;dataclass()
class C:
    ...

&#64;dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)
class C:
    ...
</pre>
<p>The parameters to <tt class="docutils literal">dataclass</tt> are:</p>
<ul>
<li><p class="first"><tt class="docutils literal">init</tt>: If true (the default), a <tt class="docutils literal">__init__</tt> method will be
generated.</p>
</li>
<li><p class="first"><tt class="docutils literal">repr</tt>: If true (the default), a <tt class="docutils literal">__repr__</tt> method will be
generated.  The generated repr string will have the class name and
the name and repr of each field, in the order they are defined in
the class.  Fields that are marked as being excluded from the repr
are not included.  For example:
<tt class="docutils literal"><span class="pre">InventoryItem(name='widget',</span> unit_price=3.0, quantity_on_hand=10)</tt>.</p>
<p>If the class already defines <tt class="docutils literal">__repr__</tt>, this parameter is
ignored.</p>
</li>
<li><p class="first"><tt class="docutils literal">eq</tt>: If true (the default), an <tt class="docutils literal">__eq__</tt> method will be
generated.  This method compares the class as if it were a tuple of its
fields, in order.  Both instances in the comparison must be of the
identical type.</p>
<p>If the class already defines <tt class="docutils literal">__eq__</tt>, this parameter is ignored.</p>
</li>
<li><p class="first"><tt class="docutils literal">order</tt>: If true (the default is False), <tt class="docutils literal">__lt__</tt>, <tt class="docutils literal">__le__</tt>,
<tt class="docutils literal">__gt__</tt>, and <tt class="docutils literal">__ge__</tt> methods will be generated.  These compare
the class as if it were a tuple of its fields, in order.  Both
instances in the comparison must be of the identical type.  If
<tt class="docutils literal">order</tt> is true and <tt class="docutils literal">eq</tt> is false, a <tt class="docutils literal">ValueError</tt> is raised.</p>
<p>If the class already defines any of <tt class="docutils literal">__lt__</tt>, <tt class="docutils literal">__le__</tt>,
<tt class="docutils literal">__gt__</tt>, or <tt class="docutils literal">__ge__</tt>, then <tt class="docutils literal">ValueError</tt> is raised.</p>
</li>
<li><p class="first"><tt class="docutils literal">unsafe_hash</tt>: If <tt class="docutils literal">False</tt> (the default), the <tt class="docutils literal">__hash__</tt> method
is generated according to how <tt class="docutils literal">eq</tt> and <tt class="docutils literal">frozen</tt> are set.</p>
<p>If <tt class="docutils literal">eq</tt> and <tt class="docutils literal">frozen</tt> are both true, Data Classes will generate a
<tt class="docutils literal">__hash__</tt> method for you.  If <tt class="docutils literal">eq</tt> is true and <tt class="docutils literal">frozen</tt> is
false, <tt class="docutils literal">__hash__</tt> will be set to <tt class="docutils literal">None</tt>, marking it unhashable
(which it is).  If <tt class="docutils literal">eq</tt> is false, <tt class="docutils literal">__hash__</tt> will be left
untouched meaning the <tt class="docutils literal">__hash__</tt> method of the superclass will be
used (if the superclass is <tt class="docutils literal">object</tt>, this means it will fall back
to id-based hashing).</p>
<p>Although not recommended, you can force Data Classes to create a
<tt class="docutils literal">__hash__</tt> method with <tt class="docutils literal">unsafe_hash=True</tt>. This might be the
case if your class is logically immutable but can nonetheless be
mutated. This is a specialized use case and should be considered
carefully.</p>
<p>If a class already has an explicitely defined <tt class="docutils literal">__hash__</tt> the
behavior when adding <tt class="docutils literal">__hash__</tt> is modified.  An expicitely
defined <tt class="docutils literal">__hash__</tt> is defined when:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">__eq__</tt> is defined in the class and <tt class="docutils literal">__hash__</tt> is defined
with any value other than <tt class="docutils literal">None</tt>.</li>
<li><tt class="docutils literal">__eq__</tt> is defined in the class and any non-<tt class="docutils literal">None</tt>
<tt class="docutils literal">__hash__</tt> is defined.</li>
<li><tt class="docutils literal">__eq__</tt> is not defined on the class, and any <tt class="docutils literal">__hash__</tt> is
defined.</li>
</ul>
</blockquote>
<p>If <tt class="docutils literal">unsafe_hash</tt> is true and an explicitely defined <tt class="docutils literal">__hash__</tt>
is present, then <tt class="docutils literal">ValueError</tt> is raised.</p>
<p>If <tt class="docutils literal">unsafe_hash</tt> is false and an explicitely defined <tt class="docutils literal">__hash__</tt>
is present, then no <tt class="docutils literal">__hash__</tt> is added.</p>
<p>See the Python documentation <a class="footnote-reference" href="#id23" id="id8">[7]</a> for more information.</p>
</li>
<li><p class="first"><tt class="docutils literal">frozen</tt>: If true (the default is False), assigning to fields will
generate an exception.  This emulates read-only frozen instances.
If either <tt class="docutils literal">__getattr__</tt> or <tt class="docutils literal">__setattr__</tt> is defined in the
class, then <tt class="docutils literal">ValueError</tt> is raised.  See the discussion below.</p>
</li>
</ul>
<p><tt class="docutils literal">field</tt>s may optionally specify a default value, using normal
Python syntax:</p>
<pre class="literal-block">
&#64;dataclass
class C:
    a: int       # 'a' has no default value
    b: int = 0   # assign a default value for 'b'
</pre>
<p>In this example, both <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> will be included in the added
<tt class="docutils literal">__init__</tt> method, which will be defined as:</p>
<pre class="literal-block">
def __init__(self, a: int, b: int = 0):
</pre>
<p><tt class="docutils literal">TypeError</tt> will be raised if a field without a default value
follows a field with a default value.  This is true either when this
occurs in a single class, or as a result of class inheritance.</p>
<p>For common and simple use cases, no other functionality is required.
There are, however, some Data Class features that require additional
per-field information.  To satisfy this need for additional
information, you can replace the default field value with a call to
the provided <tt class="docutils literal">field()</tt> function.  The signature of <tt class="docutils literal">field()</tt> is:</p>
<pre class="literal-block">
def field(*, default=MISSING, default_factory=MISSING, repr=True,
          hash=None, init=True, compare=True, metadata=None)
</pre>
<p>The <tt class="docutils literal">MISSING</tt> value is a sentinel object used to detect if the
<tt class="docutils literal">default</tt> and <tt class="docutils literal">default_factory</tt> parameters are provided.  This
sentinel is used because <tt class="docutils literal">None</tt> is a valid value for <tt class="docutils literal">default</tt>.</p>
<p>The parameters to <tt class="docutils literal">field()</tt> are:</p>
<ul>
<li><p class="first"><tt class="docutils literal">default</tt>: If provided, this will be the default value for this
field.  This is needed because the <tt class="docutils literal">field</tt> call itself replaces
the normal position of the default value.</p>
</li>
<li><p class="first"><tt class="docutils literal">default_factory</tt>: If provided, it must be a zero-argument
callable that will be called when a default value is needed for this
field.  Among other purposes, this can be used to specify fields
with mutable default values, as discussed below.  It is an error to
specify both <tt class="docutils literal">default</tt> and <tt class="docutils literal">default_factory</tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal">init</tt>: If true (the default), this field is included as a
parameter to the generated <tt class="docutils literal">__init__</tt> method.</p>
</li>
<li><p class="first"><tt class="docutils literal">repr</tt>: If true (the default), this field is included in the
string returned by the generated <tt class="docutils literal">__repr__</tt> method.</p>
</li>
<li><p class="first"><tt class="docutils literal">compare</tt>: If True (the default), this field is included in the
generated equality and comparison methods (<tt class="docutils literal">__eq__</tt>, <tt class="docutils literal">__gt__</tt>,
et al.).</p>
</li>
<li><p class="first"><tt class="docutils literal">hash</tt>: This can be a bool or <tt class="docutils literal">None</tt>.  If True, this field is
included in the generated <tt class="docutils literal">__hash__</tt> method.  If <tt class="docutils literal">None</tt> (the
default), use the value of <tt class="docutils literal">compare</tt>: this would normally be the
expected behavior.  A field should be considered in the hash if
it's used for comparisons.  Setting this value to anything other
than <tt class="docutils literal">None</tt> is discouraged.</p>
<p>One possible reason to set <tt class="docutils literal">hash=False</tt> but <tt class="docutils literal">compare=True</tt> would
be if a field is expensive to compute a hash value for, that field
is needed for equality testing, and there are other fields that
contribute to the type's hash value.  Even if a field is excluded
from the hash, it will still be used for comparisons.</p>
</li>
<li><p class="first"><tt class="docutils literal">metadata</tt>: This can be a mapping or None. None is treated as an
empty dict.  This value is wrapped in <tt class="docutils literal">types.MappingProxyType</tt> to
make it read-only, and exposed on the Field object. It is not used
at all by Data Classes, and is provided as a third-party extension
mechanism.  Multiple third-parties can each have their own key, to
use as a namespace in the metadata.</p>
</li>
</ul>
<p>If the default value of a field is specified by a call to <tt class="docutils literal">field()</tt>,
then the class attribute for this field will be replaced by the
specified <tt class="docutils literal">default</tt> value.  If no <tt class="docutils literal">default</tt> is provided, then the
class attribute will be deleted.  The intent is that after the
<tt class="docutils literal">dataclass</tt> decorator runs, the class attributes will all contain
the default values for the fields, just as if the default value itself
were specified.  For example, after:</p>
<pre class="literal-block">
&#64;dataclass
class C:
    x: int
    y: int = field(repr=False)
    z: int = field(repr=False, default=10)
    t: int = 20
</pre>
<p>The class attribute <tt class="docutils literal">C.z</tt> will be <tt class="docutils literal">10</tt>, the class attribute
<tt class="docutils literal">C.t</tt> will be <tt class="docutils literal">20</tt>, and the class attributes <tt class="docutils literal">C.x</tt> and <tt class="docutils literal">C.y</tt>
will not be set.</p>
<div class="section" id="field-objects">
<h2><a class="toc-backref" href="#id35"><tt class="docutils literal">Field</tt> objects</a></h2>
<p><tt class="docutils literal">Field</tt> objects describe each defined field. These objects are
created internally, and are returned by the <tt class="docutils literal">fields()</tt> module-level
method (see below).  Users should never instantiate a <tt class="docutils literal">Field</tt>
object directly.  Its documented attributes are:</p>
<ul class="simple">
<li><tt class="docutils literal">name</tt>: The name of the field.</li>
<li><tt class="docutils literal">type</tt>: The type of the field.</li>
<li><tt class="docutils literal">default</tt>, <tt class="docutils literal">default_factory</tt>, <tt class="docutils literal">init</tt>, <tt class="docutils literal">repr</tt>, <tt class="docutils literal">hash</tt>,
<tt class="docutils literal">compare</tt>, and <tt class="docutils literal">metadata</tt> have the identical meaning and values
as they do in the <tt class="docutils literal">field()</tt> declaration.</li>
</ul>
<p>Other attributes may exist, but they are private and must not be
inspected or relied on.</p>
</div>
<div class="section" id="post-init-processing">
<h2><a class="toc-backref" href="#id36">post-init processing</a></h2>
<p>The generated <tt class="docutils literal">__init__</tt> code will call a method named
<tt class="docutils literal">__post_init__</tt>, if it is defined on the class.  It will be called
as <tt class="docutils literal">self.__post_init__()</tt>.  If no <tt class="docutils literal">__init__</tt> method is generated,
then <tt class="docutils literal">__post_init__</tt> will not automatically be called.</p>
<p>Among other uses, this allows for initializing field values that
depend on one or more other fields.  For example:</p>
<pre class="literal-block">
&#64;dataclass
class C:
    a: float
    b: float
    c: float = field(init=False)

    def __post_init__(self):
        self.c = self.a + self.b
</pre>
<p>See the section below on init-only variables for ways to pass
parameters to <tt class="docutils literal">__post_init__()</tt>.  Also see the warning about how
<tt class="docutils literal">replace()</tt> handles <tt class="docutils literal">init=False</tt> fields.</p>
</div>
<div class="section" id="class-variables">
<h2><a class="toc-backref" href="#id37">Class variables</a></h2>
<p>One place where <tt class="docutils literal">dataclass</tt> actually inspects the type of a field is
to determine if a field is a class variable as defined in <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>.  It
does this by checking if the type of the field is <tt class="docutils literal">typing.ClassVar</tt>.
If a field is a <tt class="docutils literal">ClassVar</tt>, it is excluded from consideration as a
field and is ignored by the Data Class mechanisms. For more
discussion, see <a class="footnote-reference" href="#id24" id="id9">[8]</a>.  Such <tt class="docutils literal">ClassVar</tt> pseudo-fields are not
returned by the module-level <tt class="docutils literal">fields()</tt> function.</p>
</div>
<div class="section" id="init-only-variables">
<h2><a class="toc-backref" href="#id38">Init-only variables</a></h2>
<p>The other place where <tt class="docutils literal">dataclass</tt> inspects a type annotation is to
determine if a field is an init-only variable.  It does this by seeing
if the type of a field is of type <tt class="docutils literal">dataclasses.InitVar</tt>.  If a field
is an <tt class="docutils literal">InitVar</tt>, it is considered a pseudo-field called an init-only
field.  As it is not a true field, it is not returned by the
module-level <tt class="docutils literal">fields()</tt> function.  Init-only fields are added as
parameters to the generated <tt class="docutils literal">__init__</tt> method, and are passed to
the optional <tt class="docutils literal">__post_init__</tt> method.  They are not otherwise used
by Data Classes.</p>
<p>For example, suppose a field will be initialzed from a database, if a
value is not provided when creating the class:</p>
<pre class="literal-block">
&#64;dataclass
class C:
    i: int
    j: int = None
    database: InitVar[DatabaseType] = None

    def __post_init__(self, database):
        if self.j is None and database is not None:
            self.j = database.lookup('j')

c = C(10, database=my_database)
</pre>
<p>In this case, <tt class="docutils literal">fields()</tt> will return <tt class="docutils literal">Field</tt> objects for <tt class="docutils literal">i</tt> and
<tt class="docutils literal">j</tt>, but not for <tt class="docutils literal">database</tt>.</p>
</div>
<div class="section" id="frozen-instances">
<h2><a class="toc-backref" href="#id39">Frozen instances</a></h2>
<p>It is not possible to create truly immutable Python objects.  However,
by passing <tt class="docutils literal">frozen=True</tt> to the <tt class="docutils literal">&#64;dataclass</tt> decorator you can
emulate immutability.  In that case, Data Classes will add
<tt class="docutils literal">__setattr__</tt> and <tt class="docutils literal">__delattr__</tt> methods to the class.  These
methods will raise a <tt class="docutils literal">FrozenInstanceError</tt> when invoked.</p>
<p>There is a tiny performance penalty when using <tt class="docutils literal">frozen=True</tt>:
<tt class="docutils literal">__init__</tt> cannot use simple assignment to initialize fields, and
must use <tt class="docutils literal">object.__setattr__</tt>.</p>
</div>
<div class="section" id="inheritance">
<h2><a class="toc-backref" href="#id40">Inheritance</a></h2>
<p>When the Data Class is being created by the <tt class="docutils literal">&#64;dataclass</tt> decorator,
it looks through all of the class's base classes in reverse MRO (that
is, starting at <tt class="docutils literal">object</tt>) and, for each Data Class that it finds,
adds the fields from that base class to an ordered mapping of fields.
After all of the base class fields are added, it adds its own fields
to the ordered mapping.  All of the generated methods will use this
combined, calculated ordered mapping of fields.  Because the fields
are in insertion order, derived classes override base classes.  An
example:</p>
<pre class="literal-block">
&#64;dataclass
class Base:
    x: Any = 15.0
    y: int = 0

&#64;dataclass
class C(Base):
    z: int = 10
    x: int = 15
</pre>
<p>The final list of fields is, in order, <tt class="docutils literal">x</tt>, <tt class="docutils literal">y</tt>, <tt class="docutils literal">z</tt>.  The final
type of <tt class="docutils literal">x</tt> is <tt class="docutils literal">int</tt>, as specified in class <tt class="docutils literal">C</tt>.</p>
<p>The generated <tt class="docutils literal">__init__</tt> method for <tt class="docutils literal">C</tt> will look like:</p>
<pre class="literal-block">
def __init__(self, x: int = 15, y: int = 0, z: int = 10):
</pre>
</div>
<div class="section" id="default-factory-functions">
<h2><a class="toc-backref" href="#id41">Default factory functions</a></h2>
<p>If a field specifies a <tt class="docutils literal">default_factory</tt>, it is called with zero
arguments when a default value for the field is needed.  For example,
to create a new instance of a list, use:</p>
<pre class="literal-block">
l: list = field(default_factory=list)
</pre>
<p>If a field is excluded from <tt class="docutils literal">__init__</tt> (using <tt class="docutils literal">init=False</tt>) and
the field also specifies <tt class="docutils literal">default_factory</tt>, then the default factory
function will always be called from the generated <tt class="docutils literal">__init__</tt>
function.  This happens because there is no other way to give the
field an initial value.</p>
</div>
<div class="section" id="mutable-default-values">
<h2><a class="toc-backref" href="#id42">Mutable default values</a></h2>
<p>Python stores default member variable values in class attributes.
Consider this example, not using Data Classes:</p>
<pre class="literal-block">
class C:
    x = []
    def add(self, element):
        self.x += element

o1 = C()
o2 = C()
o1.add(1)
o2.add(2)
assert o1.x == [1, 2]
assert o1.x is o2.x
</pre>
<p>Note that the two instances of class <tt class="docutils literal">C</tt> share the same class
variable <tt class="docutils literal">x</tt>, as expected.</p>
<p>Using Data Classes, <em>if</em> this code was valid:</p>
<pre class="literal-block">
&#64;dataclass
class D:
    x: List = []
    def add(self, element):
        self.x += element
</pre>
<p>it would generate code similar to:</p>
<pre class="literal-block">
class D:
    x = []
    def __init__(self, x=x):
        self.x = x
    def add(self, element):
        self.x += element

assert D().x is D().x
</pre>
<p>This has the same issue as the original example using class <tt class="docutils literal">C</tt>.
That is, two instances of class <tt class="docutils literal">D</tt> that do not specify a value for
<tt class="docutils literal">x</tt> when creating a class instance will share the same copy of
<tt class="docutils literal">x</tt>.  Because Data Classes just use normal Python class creation
they also share this problem.  There is no general way for Data
Classes to detect this condition.  Instead, Data Classes will raise a
<tt class="docutils literal">TypeError</tt> if it detects a default parameter of type <tt class="docutils literal">list</tt>,
<tt class="docutils literal">dict</tt>, or <tt class="docutils literal">set</tt>.  This is a partial solution, but it does protect
against many common errors.  See <a class="reference internal" href="#automatically-support-mutable-default-values">Automatically support mutable
default values</a> in the Rejected Ideas section for more details.</p>
<p>Using default factory functions is a way to create new instances of
mutable types as default values for fields:</p>
<pre class="literal-block">
&#64;dataclass
class D:
    x: list = field(default_factory=list)

assert D().x is not D().x
</pre>
</div>
<div class="section" id="module-level-helper-functions">
<h2><a class="toc-backref" href="#id43">Module level helper functions</a></h2>
<ul>
<li><p class="first"><tt class="docutils literal">fields(class_or_instance)</tt>: Returns a tuple of <tt class="docutils literal">Field</tt> objects
that define the fields for this Data Class.  Accepts either a Data
Class, or an instance of a Data Class.  Raises <tt class="docutils literal">ValueError</tt> if not
passed a Data Class or instance of one.  Does not return
pseudo-fields which are <tt class="docutils literal">ClassVar</tt> or <tt class="docutils literal">InitVar</tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal">asdict(instance, *, dict_factory=dict)</tt>: Converts the Data Class
<tt class="docutils literal">instance</tt> to a dict (by using the factory function
<tt class="docutils literal">dict_factory</tt>).  Each Data Class is converted to a dict of its
fields, as name:value pairs.  Data Classes, dicts, lists, and tuples
are recursed into.  For example:</p>
<pre class="literal-block">
&#64;dataclass
class Point:
     x: int
     y: int

&#64;dataclass
class C:
     l: List[Point]

p = Point(10, 20)
assert asdict(p) == {'x': 10, 'y': 20}

c = C([Point(0, 0), Point(10, 4)])
assert asdict(c) == {'l': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}
</pre>
<p>Raises <tt class="docutils literal">TypeError</tt> if <tt class="docutils literal">instance</tt> is not a Data Class instance.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">astuple(*,</span> tuple_factory=tuple)</tt>: Converts the Data Class
<tt class="docutils literal">instance</tt> to a tuple (by using the factory function
<tt class="docutils literal">tuple_factory</tt>).  Each Data Class is converted to a tuple of its
field values.  Data Classes, dicts, lists, and tuples are recursed
into.</p>
<p>Continuing from the previous example:</p>
<pre class="literal-block">
assert astuple(p) == (10, 20)
assert astuple(c) == ([(0, 0), (10, 4)],)
</pre>
<p>Raises <tt class="docutils literal">TypeError</tt> if <tt class="docutils literal">instance</tt> is not a Data Class instance.</p>
</li>
<li><p class="first"><tt class="docutils literal">make_dataclass(cls_name, fields, *, <span class="pre">bases=(),</span> namespace=None)</tt>:
Creates a new Data Class with name <tt class="docutils literal">cls_name</tt>, fields as defined
in <tt class="docutils literal">fields</tt>, base classes as given in <tt class="docutils literal">bases</tt>, and initialized
with a namespace as given in <tt class="docutils literal">namespace</tt>.  <tt class="docutils literal">fields</tt> is an
iterable whose elements are either <tt class="docutils literal">name</tt>, <tt class="docutils literal">(name, type)</tt>, or
<tt class="docutils literal">(name, type, Field)</tt>.  If just <tt class="docutils literal">name</tt> is supplied,
<tt class="docutils literal">typing.Any</tt> is used for <tt class="docutils literal">type</tt>.  This function is not strictly
required, because any Python mechanism for creating a new class with
<tt class="docutils literal">__annotations__</tt> can then apply the <tt class="docutils literal">dataclass</tt> function to
convert that class to a Data Class.  This function is provided as a
convenience.  For example:</p>
<pre class="literal-block">
C = make_dataclass('C',
                   [('x', int),
                     'y',
                    ('z', int, field(default=5))],
                   namespace={'add_one': lambda self: self.x + 1})
</pre>
<p>Is equivalent to:</p>
<pre class="literal-block">
&#64;dataclass
class C:
    x: int
    y: 'typing.Any'
    z: int = 5

    def add_one(self):
        return self.x + 1
</pre>
</li>
<li><p class="first"><tt class="docutils literal">replace(instance, **changes)</tt>: Creates a new object of the same
type of <tt class="docutils literal">instance</tt>, replacing fields with values from <tt class="docutils literal">changes</tt>.
If <tt class="docutils literal">instance</tt> is not a Data Class, raises <tt class="docutils literal">TypeError</tt>.  If
values in <tt class="docutils literal">changes</tt> do not specify fields, raises <tt class="docutils literal">TypeError</tt>.</p>
<p>The newly returned object is created by calling the <tt class="docutils literal">__init__</tt>
method of the Data Class.  This ensures that
<tt class="docutils literal">__post_init__</tt>, if present, is also called.</p>
<p>Init-only variables without default values, if any exist, must be
specified on the call to <tt class="docutils literal">replace</tt> so that they can be passed to
<tt class="docutils literal">__init__</tt> and <tt class="docutils literal">__post_init__</tt>.</p>
<p>It is an error for <tt class="docutils literal">changes</tt> to contain any fields that are
defined as having <tt class="docutils literal">init=False</tt>.  A <tt class="docutils literal">ValueError</tt> will be raised
in this case.</p>
<p>Be forewarned about how <tt class="docutils literal">init=False</tt> fields work during a call to
<tt class="docutils literal">replace()</tt>.  They are not copied from the source object, but
rather are initialized in <tt class="docutils literal">__post_init__()</tt>, if they're
initialized at all.  It is expected that <tt class="docutils literal">init=False</tt> fields will
be rarely and judiciously used.  If they are used, it might be wise
to have alternate class constructors, or perhaps a custom
<tt class="docutils literal">replace()</tt> (or similarly named) method which handles instance
copying.</p>
</li>
<li><p class="first"><tt class="docutils literal">is_dataclass(class_or_instance)</tt>: Returns True if its parameter
is a dataclass or an instance of one, otherwise returns False.</p>
<p>If you need to know if a class is an instance of a dataclass (and
not a dataclass itself), then add a further check for <tt class="docutils literal">not
isinstance(obj, type)</tt>:</p>
<pre class="literal-block">
def is_dataclass_instance(obj):
    return is_dataclass(obj) and not isinstance(obj, type)
</pre>
</li>
</ul>
</div>
</div>
<div class="section" id="id10">
<span id="discussion"></span><h1><a class="toc-backref" href="#id44">Discussion</a></h1>
<div class="section" id="python-ideas-discussion">
<h2><a class="toc-backref" href="#id45">python-ideas discussion</a></h2>
<p>This discussion started on python-ideas <a class="footnote-reference" href="#id25" id="id11">[9]</a> and was moved to a GitHub
repo <a class="footnote-reference" href="#id26" id="id12">[10]</a> for further discussion.  As part of this discussion, we made
the decision to use <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a> syntax to drive the discovery of fields.</p>
</div>
<div class="section" id="support-for-automatically-setting-slots">
<h2><a class="toc-backref" href="#id46">Support for automatically setting <tt class="docutils literal">__slots__</tt>?</a></h2>
<p>At least for the initial release, <tt class="docutils literal">__slots__</tt> will not be supported.
<tt class="docutils literal">__slots__</tt> needs to be added at class creation time.  The Data
Class decorator is called after the class is created, so in order to
add <tt class="docutils literal">__slots__</tt> the decorator would have to create a new class, set
<tt class="docutils literal">__slots__</tt>, and return it.  Because this behavior is somewhat
surprising, the initial version of Data Classes will not support
automatically setting <tt class="docutils literal">__slots__</tt>.  There are a number of
workarounds:</p>
<ul class="simple">
<li>Manually add <tt class="docutils literal">__slots__</tt> in the class definition.</li>
<li>Write a function (which could be used as a decorator) that inspects
the class using <tt class="docutils literal">fields()</tt> and creates a new class with
<tt class="docutils literal">__slots__</tt> set.</li>
</ul>
<p>For more discussion, see <a class="footnote-reference" href="#id27" id="id13">[11]</a>.</p>
</div>
<div class="section" id="why-not-just-use-namedtuple">
<h2><a class="toc-backref" href="#id47">Why not just use namedtuple?</a></h2>
<ul>
<li><p class="first">Any namedtuple can be accidentally compared to any other with the
same number of fields. For example: <tt class="docutils literal">Point3D(2017, 6, 2) ==
Date(2017, 6, 2)</tt>.  With Data Classes, this would return False.</p>
</li>
<li><p class="first">A namedtuple can be accidentally compared to a tuple.  For example
<tt class="docutils literal">Point2D(1, 10) == (1, 10)</tt>.  With Data Classes, this would return
False.</p>
</li>
<li><p class="first">Instances are always iterable, which can make it difficult to add
fields.  If a library defines:</p>
<pre class="literal-block">
Time = namedtuple('Time', ['hour', 'minute'])
def get_time():
    return Time(12, 0)
</pre>
<p>Then if a user uses this code as:</p>
<pre class="literal-block">
hour, minute = get_time()
</pre>
<p>then it would not be possible to add a <tt class="docutils literal">second</tt> field to <tt class="docutils literal">Time</tt>
without breaking the user's code.</p>
</li>
<li><p class="first">No option for mutable instances.</p>
</li>
<li><p class="first">Cannot specify default values.</p>
</li>
<li><p class="first">Cannot control which fields are used for <tt class="docutils literal">__init__</tt>, <tt class="docutils literal">__repr__</tt>,
etc.</p>
</li>
<li><p class="first">Cannot support combining fields by inheritance.</p>
</li>
</ul>
</div>
<div class="section" id="why-not-just-use-typing-namedtuple">
<h2><a class="toc-backref" href="#id48">Why not just use typing.NamedTuple?</a></h2>
<p>For classes with statically defined fields, it does support similar
syntax to Data Classes, using type annotations.  This produces a
namedtuple, so it shares <tt class="docutils literal">namedtuple</tt>s benefits and some of its
downsides.  Data Classes, unlike <tt class="docutils literal">typing.NamedTuple</tt>, support
combining fields via inheritance.</p>
</div>
<div class="section" id="why-not-just-use-attrs">
<h2><a class="toc-backref" href="#id49">Why not just use attrs?</a></h2>
<ul class="simple">
<li>attrs moves faster than could be accommodated if it were moved in to
the standard library.</li>
<li>attrs supports additional features not being proposed here:
validators, converters, metadata, etc.  Data Classes makes a
tradeoff to achieve simplicity by not implementing these
features.</li>
</ul>
<p>For more discussion, see <a class="footnote-reference" href="#id28" id="id14">[12]</a>.</p>
</div>
<div class="section" id="post-init-parameters">
<h2><a class="toc-backref" href="#id50">post-init parameters</a></h2>
<p>In an earlier version of this PEP before <tt class="docutils literal">InitVar</tt> was added, the
post-init function <tt class="docutils literal">__post_init__</tt> never took any parameters.</p>
<p>The normal way of doing parameterized initialization (and not just
with Data Classes) is to provide an alternate classmethod constructor.
For example:</p>
<pre class="literal-block">
&#64;dataclass
class C:
    x: int

    &#64;classmethod
    def from_file(cls, filename):
        with open(filename) as fl:
            file_value = int(fl.read())
        return C(file_value)

c = C.from_file('file.txt')
</pre>
<p>Because the <tt class="docutils literal">__post_init__</tt> function is the last thing called in the
generated <tt class="docutils literal">__init__</tt>, having a classmethod constructor (which can
also execute code immmediately after constructing the object) is
functionally equivalent to being able to pass parameters to a
<tt class="docutils literal">__post_init__</tt> function.</p>
<p>With <tt class="docutils literal">InitVar</tt>s, <tt class="docutils literal">__post_init__</tt> functions can now take
parameters.  They are passed first to <tt class="docutils literal">__init__</tt> which passes them
to <tt class="docutils literal">__post_init__</tt> where user code can use them as needed.</p>
<p>The only real difference between alternate classmethod constructors
and <tt class="docutils literal">InitVar</tt> pseudo-fields is in regards to required non-field
parameters during object creation.  With <tt class="docutils literal">InitVar</tt>s, using
<tt class="docutils literal">__init__</tt> and the module-level <tt class="docutils literal">replace()</tt> function <tt class="docutils literal">InitVar</tt>s
must always be specified.  Consider the case where a <tt class="docutils literal">context</tt>
object is needed to create an instance, but isn't stored as a field.
With alternate classmethod constructors the <tt class="docutils literal">context</tt> parameter is
always optional, because you could still create the object by going
through <tt class="docutils literal">__init__</tt> (unless you suppress its creation).  Which
approach is more appropriate will be application-specific, but both
approaches are supported.</p>
<p>Another reason for using <tt class="docutils literal">InitVar</tt> fields is that the class author
can control the order of <tt class="docutils literal">__init__</tt> parameters.  This is especially
important with regular fields and <tt class="docutils literal">InitVar</tt> fields that have default
values, as all fields with defaults must come after all fields without
defaults.  A previous design had all init-only fields coming after
regular fields.  This meant that if any field had a default value,
then all init-only fields would have to have defaults values, too.</p>
</div>
<div class="section" id="asdict-and-astuple-function-names">
<h2><a class="toc-backref" href="#id51">asdict and astuple function names</a></h2>
<p>The names of the module-level helper functions <tt class="docutils literal">asdict()</tt> and
<tt class="docutils literal">astuple()</tt> are arguably not <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> compliant, and should be
<tt class="docutils literal">as_dict()</tt> and <tt class="docutils literal">as_tuple()</tt>, respectively.  However, after
discussion <a class="footnote-reference" href="#id29" id="id15">[13]</a> it was decided to keep consistency with
<tt class="docutils literal">namedtuple._asdict()</tt> and <tt class="docutils literal">attr.asdict()</tt>.</p>
</div>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id52">Rejected ideas</a></h1>
<div class="section" id="copying-init-false-fields-after-new-object-creation-in-replace">
<h2><a class="toc-backref" href="#id53">Copying <tt class="docutils literal">init=False</tt> fields after new object creation in replace()</a></h2>
<p>Fields that are <tt class="docutils literal">init=False</tt> are by definition not passed to
<tt class="docutils literal">__init__</tt>, but instead are initialized with a default value, or by
calling a default factory function in <tt class="docutils literal">__init__</tt>, or by code in
<tt class="docutils literal">__post_init__</tt>.</p>
<p>A previous version of this PEP specified that <tt class="docutils literal">init=False</tt> fields
would be copied from the source object to the newly created object
after <tt class="docutils literal">__init__</tt> returned, but that was deemed to be inconsistent
with using <tt class="docutils literal">__init__</tt> and <tt class="docutils literal">__post_init__</tt> to initialize the new
object.  For example, consider this case:</p>
<pre class="literal-block">
&#64;dataclass
class Square:
    length: float
    area: float = field(init=False, default=0.0)

    def __post_init__(self):
        self.area = self.length * self.length

s1 = Square(1.0)
s2 = replace(s1, length=2.0)
</pre>
<p>If <tt class="docutils literal">init=False</tt> fields were copied from the source to the
destination object after <tt class="docutils literal">__post_init__</tt> is run, then s2 would end
up begin <tt class="docutils literal">Square(length=2.0, area=1.0)</tt>, instead of the correct
<tt class="docutils literal">Square(length=2.0, area=4.0)</tt>.</p>
</div>
<div class="section" id="automatically-support-mutable-default-values">
<h2><a class="toc-backref" href="#id54">Automatically support mutable default values</a></h2>
<p>One proposal was to automatically copy defaults, so that if a literal
list <tt class="docutils literal">[]</tt> was a default value, each instance would get a new list.
There were undesirable side effects of this decision, so the final
decision is to disallow the 3 known built-in mutable types: list,
dict, and set.  For a complete discussion of this and other options,
see <a class="footnote-reference" href="#id30" id="id16">[14]</a>.</p>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id55">Examples</a></h1>
<div class="section" id="custom-init-method">
<h2><a class="toc-backref" href="#id56">Custom __init__ method</a></h2>
<p>Sometimes the generated <tt class="docutils literal">__init__</tt> method does not suffice. For
example, suppose you wanted to have an object to store <tt class="docutils literal">*args</tt> and
<tt class="docutils literal">**kwargs</tt>:</p>
<pre class="literal-block">
&#64;dataclass(init=False)
class ArgHolder:
    args: List[Any]
    kwargs: Mapping[Any, Any]

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs

a = ArgHolder(1, 2, three=3)
</pre>
</div>
<div class="section" id="a-complicated-example">
<h2><a class="toc-backref" href="#id57">A complicated example</a></h2>
<p>This code exists in a closed source project:</p>
<pre class="literal-block">
class Application:
    def __init__(self, name, requirements, constraints=None, path='', executable_links=None, executables_dir=()):
        self.name = name
        self.requirements = requirements
        self.constraints = {} if constraints is None else constraints
        self.path = path
        self.executable_links = [] if executable_links is None else executable_links
        self.executables_dir = executables_dir
        self.additional_items = []

    def __repr__(self):
        return f'Application({self.name!r},{self.requirements!r},{self.constraints!r},{self.path!r},{self.executable_links!r},{self.executables_dir!r},{self.additional_items!r})'
</pre>
<p>This can be replaced by:</p>
<pre class="literal-block">
&#64;dataclass
class Application:
    name: str
    requirements: List[Requirement]
    constraints: Dict[str, str] = field(default_factory=dict)
    path: str = ''
    executable_links: List[str] = field(default_factory=list)
    executable_dir: Tuple[str] = ()
    additional_items: List[str] = field(init=False, default_factory=list)
</pre>
<p>The Data Class version is more declarative, has less code, supports
<tt class="docutils literal">typing</tt>, and includes the other generated functions.</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id58">Acknowledgements</a></h1>
<p>The following people provided invaluable input during the development
of this PEP and code: Ivan Levkivskyi, Guido van Rossum, Hynek
Schlawack, Raymond Hettinger, and Lisa Roach.  I thank them for their
time and expertise.</p>
<p>A special mention must be made about the <tt class="docutils literal">attrs</tt> project.  It was a
true inspiration for this PEP, and I respect the design decisions they
made.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id59">References</a></h1>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>attrs project on github
(<a class="reference external" href="https://github.com/python-attrs/attrs">https://github.com/python-attrs/attrs</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>George Sakkis' recordType recipe
(<a class="reference external" href="http://code.activestate.com/recipes/576555-records/">http://code.activestate.com/recipes/576555-records/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>DictDotLookup recipe
(<a class="reference external" href="http://code.activestate.com/recipes/576586-dot-style-nested-lookups-over-dictionary-based-dat/">http://code.activestate.com/recipes/576586-dot-style-nested-lookups-over-dictionary-based-dat/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>attrdict package
(<a class="reference external" href="https://pypi.python.org/pypi/attrdict">https://pypi.python.org/pypi/attrdict</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>StackOverflow question about data container classes
(<a class="reference external" href="https://stackoverflow.com/questions/3357581/using-python-class-as-a-data-container">https://stackoverflow.com/questions/3357581/using-python-class-as-a-data-container</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>David Beazley metaclass talk featuring data classes
(<a class="reference external" href="https://www.youtube.com/watch?v=sPiWg5jSoZI">https://www.youtube.com/watch?v=sPiWg5jSoZI</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>Python documentation for __hash__
(<a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__hash__">https://docs.python.org/3/reference/datamodel.html#object.__hash__</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>ClassVar discussion in <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations">https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[9]</a></td><td>Start of python-ideas discussion
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-May/045618.html">https://mail.python.org/pipermail/python-ideas/2017-May/045618.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[10]</a></td><td>GitHub repo where discussions and initial development took place
(<a class="reference external" href="https://github.com/ericvsmith/dataclasses">https://github.com/ericvsmith/dataclasses</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[11]</a></td><td>Support __slots__?
(<a class="reference external" href="https://github.com/ericvsmith/dataclasses/issues/28">https://github.com/ericvsmith/dataclasses/issues/28</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[12]</a></td><td>why not just attrs?
(<a class="reference external" href="https://github.com/ericvsmith/dataclasses/issues/19">https://github.com/ericvsmith/dataclasses/issues/19</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[13]</a></td><td><a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> names for asdict and astuple
(<a class="reference external" href="https://github.com/ericvsmith/dataclasses/issues/110">https://github.com/ericvsmith/dataclasses/issues/110</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[14]</a></td><td>Copying mutable defaults
(<a class="reference external" href="https://github.com/ericvsmith/dataclasses/issues/3">https://github.com/ericvsmith/dataclasses/issues/3</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id60">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

