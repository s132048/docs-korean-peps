<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">293</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Codec Error Handling Callbacks</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0293.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Walter Dörwald &lt;walter&#32;&#97;t&#32;livinglogic.de&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">18-Jun-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">19-Jun-2002</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#specification" id="id6">Specification</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#implementation-notes" id="id8">Implementation Notes</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id9">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#references" id="id10">References</a></li>
<li><a class="reference internal" href="#copyright" id="id11">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>This PEP aims at extending Python's fixed codec error handling
schemes with a more flexible callback based approach.</p>
<p>Python currently uses a fixed error handling for codec error
handlers.  This PEP describes a mechanism which allows Python to
use function callbacks as error handlers.  With these more
flexible error handlers it is possible to add new functionality to
existing codecs by e.g. providing fallback solutions or different
encodings for cases where the standard codec mapping does not
apply.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id6">Specification</a></h1>
<p>Currently the set of codec error handling algorithms is fixed to
either &quot;strict&quot;, &quot;replace&quot; or &quot;ignore&quot; and the semantics of these
algorithms is implemented separately for each codec.</p>
<p>The proposed patch will make the set of error handling algorithms
extensible through a codec error handler registry which maps
handler names to handler functions.  This registry consists of the
following two C functions:</p>
<pre class="literal-block">
int PyCodec_RegisterError(const char *name, PyObject *error)

PyObject *PyCodec_LookupError(const char *name)
</pre>
<p>and their Python counterparts:</p>
<pre class="literal-block">
codecs.register_error(name, error)

codecs.lookup_error(name)
</pre>
<p><tt class="docutils literal">PyCodec_LookupError</tt> raises a <tt class="docutils literal">LookupError</tt> if no callback function
has been registered under this name.</p>
<p>Similar to the encoding name registry there is no way of
unregistering callback functions or iterating through the
available functions.</p>
<p>The callback functions will be used in the following way by the
codecs: when the codec encounters an encoding/decoding error, the
callback function is looked up by name, the information about the
error is stored in an exception object and the callback is called
with this object.  The callback returns information about how to
proceed (or raises an exception).</p>
<p>For encoding, the exception object will look like this:</p>
<pre class="literal-block">
class UnicodeEncodeError(UnicodeError):
    def __init__(self, encoding, object, start, end, reason):
        UnicodeError.__init__(self,
            &quot;encoding '%s' can't encode characters &quot; +
            &quot;in positions %d-%d: %s&quot; % (encoding,
                start, end-1, reason))
        self.encoding = encoding
        self.object = object
        self.start = start
        self.end = end
        self.reason = reason
</pre>
<p>This type will be implemented in C with the appropriate setter and
getter methods for the attributes, which have the following
meaning:</p>
<ul class="simple">
<li><tt class="docutils literal">encoding</tt>: The name of the encoding;</li>
<li><tt class="docutils literal">object</tt>: The original unicode object for which <tt class="docutils literal">encode()</tt> has
been called;</li>
<li><tt class="docutils literal">start</tt>: The position of the first unencodable character;</li>
<li><tt class="docutils literal">end</tt>: (The position of the last unencodable character)+1 (or
the length of object, if all characters from start to the end
of object are unencodable);</li>
<li><tt class="docutils literal">reason</tt>: The reason why <tt class="docutils literal">object[start:end]</tt> couldn't be encoded.</li>
</ul>
<p>If object has consecutive unencodable characters, the encoder
should collect those characters for one call to the callback if
those characters can't be encoded for the same reason.  The
encoder is not required to implement this behaviour but may call
the callback for every single character, but it is strongly
suggested that the collecting method is implemented.</p>
<p>The callback must not modify the exception object.  If the
callback does not raise an exception (either the one passed in, or
a different one), it must return a tuple:</p>
<pre class="literal-block">
(replacement, newpos)
</pre>
<p>replacement is a unicode object that the encoder will encode and
emit instead of the unencodable <tt class="docutils literal">object[start:end]</tt> part, newpos
specifies a new position within object, where (after encoding the
replacement) the encoder will continue encoding.</p>
<p>Negative values for newpos are treated as being relative to
end of object. If newpos is out of bounds the encoder will raise
an <tt class="docutils literal">IndexError</tt>.</p>
<p>If the replacement string itself contains an unencodable character
the encoder raises the exception object (but may set a different
reason string before raising).</p>
<p>Should further encoding errors occur, the encoder is allowed to
reuse the exception object for the next call to the callback.
Furthermore, the encoder is allowed to cache the result of
<tt class="docutils literal">codecs.lookup_error</tt>.</p>
<p>If the callback does not know how to handle the exception, it must
raise a <tt class="docutils literal">TypeError</tt>.</p>
<p>Decoding works similar to encoding with the following differences:</p>
<ul class="simple">
<li>The exception class is named <tt class="docutils literal">UnicodeDecodeError</tt> and the attribute
object is the original 8bit string that the decoder is currently
decoding.</li>
<li>The decoder will call the callback with those bytes that
constitute one undecodable sequence, even if there is more than
one undecodable sequence that is undecodable for the same reason
directly after the first one.  E.g. for the &quot;unicode-escape&quot;
encoding, when decoding the illegal string <tt class="docutils literal"><span class="pre">\\u00\\u01x</span></tt>, the
callback will be called twice (once for <tt class="docutils literal">\\u00</tt> and once for
<tt class="docutils literal">\\u01</tt>).  This is done to be able to generate the correct number
of replacement characters.</li>
<li>The replacement returned from the callback is a unicode object
that will be emitted by the decoder as-is without further
processing instead of the undecodable <tt class="docutils literal">object[start:end]</tt> part.</li>
</ul>
<p>There is a third API that uses the old strict/ignore/replace error
handling scheme:</p>
<pre class="literal-block">
PyUnicode_TranslateCharmap/unicode.translate
</pre>
<p>The proposed patch will enhance <tt class="docutils literal">PyUnicode_TranslateCharmap</tt>, so
that it also supports the callback registry.  This has the
additional side effect that <tt class="docutils literal">PyUnicode_TranslateCharmap</tt> will
support multi-character replacement strings (see SF feature
request #403100 <a class="footnote-reference" href="#id3" id="id1">[1]</a>).</p>
<p>For <tt class="docutils literal">PyUnicode_TranslateCharmap</tt> the exception class will be named
<tt class="docutils literal">UnicodeTranslateError</tt>.  <tt class="docutils literal">PyUnicode_TranslateCharmap</tt> will collect
all consecutive untranslatable characters (i.e. those that map to
<tt class="docutils literal">None</tt>) and call the callback with them.  The replacement returned
from the callback is a unicode object that will be put in the
translated result as-is, without further processing.</p>
<p>All encoders and decoders are allowed to implement the callback
functionality themselves, if they recognize the callback name
(i.e. if it is a system callback like &quot;strict&quot;, &quot;replace&quot; and
&quot;ignore&quot;).  The proposed patch will add two additional system
callback names: &quot;backslashreplace&quot; and &quot;xmlcharrefreplace&quot;, which
can be used for encoding and translating and which will also be
implemented in-place for all encoders and
<tt class="docutils literal">PyUnicode_TranslateCharmap</tt>.</p>
<p>The Python equivalent of these five callbacks will look like this:</p>
<pre class="literal-block">
def strict(exc):
    raise exc

def ignore(exc):
    if isinstance(exc, UnicodeError):
        return (u&quot;&quot;, exc.end)
    else:
        raise TypeError(&quot;can't handle %s&quot; % exc.__name__)

def replace(exc):
     if isinstance(exc, UnicodeEncodeError):
         return ((exc.end-exc.start)*u&quot;?&quot;, exc.end)
     elif isinstance(exc, UnicodeDecodeError):
         return (u&quot;\\ufffd&quot;, exc.end)
     elif isinstance(exc, UnicodeTranslateError):
         return ((exc.end-exc.start)*u&quot;\\ufffd&quot;, exc.end)
     else:
         raise TypeError(&quot;can't handle %s&quot; % exc.__name__)

def backslashreplace(exc):
     if isinstance(exc,
         (UnicodeEncodeError, UnicodeTranslateError)):
         s = u&quot;&quot;
         for c in exc.object[exc.start:exc.end]:
            if ord(c)&lt;=0xff:
                s += u&quot;\\x%02x&quot; % ord(c)
            elif ord(c)&lt;=0xffff:
                s += u&quot;\\u%04x&quot; % ord(c)
            else:
                s += u&quot;\\U%08x&quot; % ord(c)
         return (s, exc.end)
     else:
         raise TypeError(&quot;can't handle %s&quot; % exc.__name__)

def xmlcharrefreplace(exc):
     if isinstance(exc,
         (UnicodeEncodeError, UnicodeTranslateError)):
         s = u&quot;&quot;
         for c in exc.object[exc.start:exc.end]:
            s += u&quot;&amp;#%d;&quot; % ord(c)
         return (s, exc.end)
     else:
         raise TypeError(&quot;can't handle %s&quot; % exc.__name__)
</pre>
<p>These five callback handlers will also be accessible to Python as
<tt class="docutils literal">codecs.strict_error</tt>, <tt class="docutils literal">codecs.ignore_error</tt>, <tt class="docutils literal">codecs.replace_error</tt>,
<tt class="docutils literal">codecs.backslashreplace_error</tt> and <tt class="docutils literal">codecs.xmlcharrefreplace_error</tt>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>Most legacy encoding do not support the full range of Unicode
characters.  For these cases many high level protocols support a
way of escaping a Unicode character (e.g. Python itself supports
the <tt class="docutils literal">\x</tt>, <tt class="docutils literal">\u</tt> and <tt class="docutils literal">\U</tt> convention, XML supports character references
via &amp;#xxx; etc.).</p>
<p>When implementing such an encoding algorithm, a problem with the
current implementation of the encode method of Unicode objects
becomes apparent: For determining which characters are unencodable
by a certain encoding, every single character has to be tried,
because encode does not provide any information about the location
of the error(s), so</p>
<pre class="literal-block">
# (1)
us = u&quot;xxx&quot;
s = us.encode(encoding)
</pre>
<p>has to be replaced by</p>
<pre class="literal-block">
# (2)
us = u&quot;xxx&quot;
v = []
for c in us:
    try:
        v.append(c.encode(encoding))
    except UnicodeError:
        v.append(&quot;&amp;#%d;&quot; % ord(c))
s = &quot;&quot;.join(v)
</pre>
<p>This slows down encoding dramatically as now the loop through the
string is done in Python code and no longer in C code.</p>
<p>Furthermore, this solution poses problems with stateful encodings.
For example, UTF-16 uses a Byte Order Mark at the start of the
encoded byte string to specify the byte order.  Using (2) with
UTF-16, results in an 8 bit string with a BOM between every
character.</p>
<p>To work around this problem, a stream writer - which keeps state
between calls to the encoding function - has to be used:</p>
<pre class="literal-block">
# (3)
us = u&quot;xxx&quot;
import codecs, cStringIO as StringIO
writer = codecs.getwriter(encoding)

v = StringIO.StringIO()
uv = writer(v)
for c in us:
    try:
        uv.write(c)
    except UnicodeError:
        uv.write(u&quot;&amp;#%d;&quot; % ord(c))
s = v.getvalue()
</pre>
<p>To compare the speed of (1) and (3) the following test script has
been used:</p>
<pre class="literal-block">
# (4)
import time
us = u&quot;äa&quot;*1000000
encoding = &quot;ascii&quot;
import codecs, cStringIO as StringIO

t1 = time.time()

s1 = us.encode(encoding, &quot;replace&quot;)

t2 = time.time()

writer = codecs.getwriter(encoding)

v = StringIO.StringIO()
uv = writer(v)
for c in us:
    try:
        uv.write(c)
    except UnicodeError:
        uv.write(u&quot;?&quot;)
s2 = v.getvalue()

t3 = time.time()

assert(s1==s2)
print &quot;1:&quot;, t2-t1
print &quot;2:&quot;, t3-t2
print &quot;factor:&quot;, (t3-t2)/(t2-t1)
</pre>
<p>On Linux this gives the following output (with Python 2.3a0):</p>
<pre class="literal-block">
1: 0.274321913719
2: 51.1284689903
factor: 186.381278466
</pre>
<p>i.e. (3) is 180 times slower than (1).</p>
<p>Callbacks must be stateless, because as soon as a callback is
registered it is available globally and can be called by multiple
<tt class="docutils literal">encode()</tt> calls.  To be able to use stateful callbacks, the errors
parameter for encode/decode/translate would have to be changed
from <tt class="docutils literal">char *</tt> to <tt class="docutils literal">PyObject *</tt>, so that the callback could be used
directly, without the need to register the callback globally.  As
this requires changes to lots of C prototypes, this approach was
rejected.</p>
<p>Currently all encoding/decoding functions have arguments</p>
<pre class="literal-block">
const Py_UNICODE *p, int size
</pre>
<p>or</p>
<pre class="literal-block">
const char *p, int size
</pre>
<p>to specify the unicode characters/8bit characters to be
encoded/decoded.  So in case of an error the codec has to create a
new unicode or str object from these parameters and store it in
the exception object.  The callers of these encoding/decoding
functions extract these parameters from str/unicode objects
themselves most of the time, so it could speed up error handling
if these object were passed directly.  As this again requires
changes to many C functions, this approach has been rejected.</p>
<p>For stream readers/writers the errors attribute must be changeable
to be able to switch between different error handling methods
during the lifetime of the stream reader/writer. This is currently
the case for <tt class="docutils literal">codecs.StreamReader</tt> and <tt class="docutils literal">codecs.StreamWriter</tt> and
all their subclasses. All core codecs and probably most of the
third party codecs (e.g. <tt class="docutils literal">JapaneseCodecs</tt>) derive their stream
readers/writers from these classes so this already works,
but the attribute errors should be documented as a requirement.</p>
</div>
<div class="section" id="implementation-notes">
<h1><a class="toc-backref" href="#id8">Implementation Notes</a></h1>
<p>A sample implementation is available as SourceForge patch #432401
<a class="footnote-reference" href="#id4" id="id2">[2]</a> including a script for testing the speed of various
string/encoding/error combinations and a test script.</p>
<p>Currently the new exception classes are old style Python
classes. This means that accessing attributes results
in a dict lookup. The C API is implemented in a way
that makes it possible to switch to new style classes
behind the scene, if <tt class="docutils literal">Exception</tt> (and <tt class="docutils literal">UnicodeError</tt>) will
be changed to new style classes implemented in C for
improved performance.</p>
<p>The class <tt class="docutils literal">codecs.StreamReaderWriter</tt> uses the errors parameter for
both reading and writing.  To be more flexible this should
probably be changed to two separate parameters for reading and
writing.</p>
<p>The errors parameter of <tt class="docutils literal">PyUnicode_TranslateCharmap</tt> is not
availably to Python, which makes testing of the new functionality
of <tt class="docutils literal">PyUnicode_TranslateCharmap</tt> impossible with Python scripts.  The
patch should add an optional argument errors to unicode.translate
to expose the functionality and make testing possible.</p>
<p>Codecs that do something different than encoding/decoding from/to
unicode and want to use the new machinery can define their own
exception classes and the strict handlers will automatically work
with it. The other predefined error handlers are unicode specific
and expect to get a <tt class="docutils literal">Unicode(Encode|Decode|Translate)Error</tt>
exception object so they won't work.</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id9">Backwards Compatibility</a></h1>
<p>The semantics of unicode.encode with errors=&quot;replace&quot; has changed:
The old version always stored a ? character in the output string
even if no character was mapped to ? in the mapping.  With the
proposed patch, the replacement string from the callback will
again be looked up in the mapping dictionary.  But as all
supported encodings are ASCII based, and thus map ? to ?, this
should not be a problem in practice.</p>
<p>Illegal values for the errors argument raised <tt class="docutils literal">ValueError</tt> before,
now they will raise <tt class="docutils literal">LookupError</tt>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id10">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>SF feature request #403100
&quot;Multicharacter replacements in PyUnicode_TranslateCharmap&quot;
<a class="reference external" href="http://www.python.org/sf/403100">http://www.python.org/sf/403100</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>SF patch #432401 &quot;unicode encoding error callbacks&quot;
<a class="reference external" href="http://www.python.org/sf/432401">http://www.python.org/sf/432401</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id11">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

