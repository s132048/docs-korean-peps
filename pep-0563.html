<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">563</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Postponed Evaluation of Annotations</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0563.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">≈Åukasz Langa &lt;lukasz&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">Python-Dev &lt;<a class="reference external" href="mailto:python-dev&#64;python.org?subject=PEP%20563">python-dev&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">8-Sep-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">1-Nov-2017, 21-Nov-2017</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-December/151042.html">https://mail.python.org/pipermail/python-dev/2017-December/151042.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#rationale-and-goals" id="id2">Rationale and Goals</a><ul>
<li><a class="reference internal" href="#non-goals" id="id3">Non-goals</a></li>
<li><a class="reference internal" href="#non-typing-usage-of-annotations" id="id4">Non-typing usage of annotations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id5">Implementation</a><ul>
<li><a class="reference internal" href="#enabling-the-future-behavior-in-python-3-7" id="id6">Enabling the future behavior in Python 3.7</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resolving-type-hints-at-runtime" id="id7">Resolving Type Hints at Runtime</a><ul>
<li><a class="reference internal" href="#runtime-annotation-resolution-and-class-decorators" id="id8">Runtime annotation resolution and class decorators</a></li>
<li><a class="reference internal" href="#runtime-annotation-resolution-and-type-checking" id="id9">Runtime annotation resolution and <tt class="docutils literal">TYPE_CHECKING</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id10">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#deprecation-policy" id="id11">Deprecation policy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#forward-references" id="id12">Forward References</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id13">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#keeping-the-ability-to-use-function-local-state-when-defining-annotations" id="id14">Keeping the ability to use function local state when defining annotations</a></li>
<li><a class="reference internal" href="#disallowing-local-state-usage-for-classes-too" id="id15">Disallowing local state usage for classes, too</a></li>
<li><a class="reference internal" href="#introducing-a-new-dictionary-for-the-string-literal-form-instead" id="id16">Introducing a new dictionary for the string literal form instead</a></li>
<li><a class="reference internal" href="#dropping-annotations-with-o" id="id17">Dropping annotations with -O</a></li>
<li><a class="reference internal" href="#passing-string-literals-in-annotations-verbatim-to-annotations" id="id18">Passing string literals in annotations verbatim to <tt class="docutils literal">__annotations__</tt></a></li>
<li><a class="reference internal" href="#making-the-name-of-the-future-import-more-verbose" id="id19">Making the name of the future import more verbose</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prior-discussion" id="id20">Prior discussion</a><ul>
<li><a class="reference internal" href="#in-pep-484" id="id21">In PEP 484</a></li>
<li><a class="reference internal" href="#python-typing-400" id="id22">python/typing#400</a></li>
<li><a class="reference internal" href="#first-draft-discussion-on-python-ideas" id="id23">First draft discussion on python-ideas</a></li>
<li><a class="reference internal" href="#second-draft-discussion-on-python-dev" id="id24">Second draft discussion on python-dev</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements" id="id25">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright" id="id26">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p><a class="reference external" href="/dev/peps/pep-3107">PEP 3107</a> introduced syntax for function annotations, but the semantics
were deliberately left undefined.  <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> introduced a standard meaning
to annotations: type hints.  <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a> defined variable annotations,
explicitly tying them with the type hinting use case.</p>
<p>This PEP proposes changing function annotations and variable annotations
so that they are no longer evaluated at function definition time.
Instead, they are preserved in <tt class="docutils literal">__annotations__</tt> in string form.</p>
<p>This change is going to be introduced gradually, starting with a new
<tt class="docutils literal">__future__</tt> import in Python 3.7.</p>
</div>
<div class="section" id="rationale-and-goals">
<h1><a class="toc-backref" href="#id2">Rationale and Goals</a></h1>
<p><a class="reference external" href="/dev/peps/pep-3107">PEP 3107</a> added support for arbitrary annotations on parts of a function
definition.  Just like default values, annotations are evaluated at
function definition time.  This creates a number of issues for the type
hinting use case:</p>
<ul class="simple">
<li>forward references: when a type hint contains names that have not been
defined yet, that definition needs to be expressed as a string
literal;</li>
<li>type hints are executed at module import time, which is not
computationally free.</li>
</ul>
<p>Postponing the evaluation of annotations solves both problems.</p>
<div class="section" id="non-goals">
<h2><a class="toc-backref" href="#id3">Non-goals</a></h2>
<p>Just like in <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> and <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>, it should be emphasized that <strong>Python
will remain a dynamically typed language, and the authors have no desire
to ever make type hints mandatory, even by convention.</strong></p>
<p>This PEP is meant to solve the problem of forward references in type
annotations.  There are still cases outside of annotations where
forward references will require usage of string literals.  Those are
listed in a later section of this document.</p>
<p>Annotations without forced evaluation enable opportunities to improve
the syntax of type hints.  This idea will require its own separate PEP
and is not discussed further in this document.</p>
</div>
<div class="section" id="non-typing-usage-of-annotations">
<h2><a class="toc-backref" href="#id4">Non-typing usage of annotations</a></h2>
<p>While annotations are still available for arbitrary use besides type
checking, it is worth mentioning that the design of this PEP, as well
as its precursors (<a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> and <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>), is predominantly motivated by
the type hinting use case.</p>
<p>In Python 3.8 <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> will graduate from provisional status.  Other
enhancements to the Python programming language like <a class="reference external" href="/dev/peps/pep-0544">PEP 544</a>, <a class="reference external" href="/dev/peps/pep-0557">PEP 557</a>,
or <a class="reference external" href="/dev/peps/pep-0560">PEP 560</a>, are already being built on this basis as they depend on
type annotations and the <tt class="docutils literal">typing</tt> module as defined by <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>.
In fact, the reason <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> is staying provisional in Python 3.7 is to
enable rapid evolution for another release cycle that some of the
aforementioned enhancements require.</p>
<p>With this in mind, uses for annotations incompatible with the
aforementioned PEPs should be considered deprecated.</p>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id5">Implementation</a></h1>
<p>In Python 4.0, function and variable annotations will no longer be
evaluated at definition time.  Instead, a string form will be preserved
in the respective <tt class="docutils literal">__annotations__</tt> dictionary.  Static type checkers
will see no difference in behavior, whereas tools using annotations at
runtime will have to perform postponed evaluation.</p>
<p>The string form is obtained from the AST during the compilation step,
which means that the string form might not preserve the exact formatting
of the source.  Note: if an annotation was a string literal already, it
will still be wrapped in a string.</p>
<p>Annotations need to be syntactically valid Python expressions, also when
passed as literal strings (i.e. <tt class="docutils literal">compile(literal, '', 'eval')</tt>).
Annotations can only use names present in the module scope as postponed
evaluation using local names is not reliable (with the sole exception of
class-level names resolved by <tt class="docutils literal">typing.get_type_hints()</tt>).</p>
<p>Note that as per <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>, local variable annotations are not evaluated
at all since they are not accessible outside of the function's closure.</p>
<div class="section" id="enabling-the-future-behavior-in-python-3-7">
<h2><a class="toc-backref" href="#id6">Enabling the future behavior in Python 3.7</a></h2>
<p>The functionality described above can be enabled starting from Python
3.7 using the following special import:</p>
<pre class="literal-block">
from __future__ import annotations
</pre>
<p>A reference implementation of this functionality is available
<a class="reference external" href="https://github.com/python/cpython/pull/4390">on GitHub</a>.</p>
</div>
</div>
<div class="section" id="resolving-type-hints-at-runtime">
<h1><a class="toc-backref" href="#id7">Resolving Type Hints at Runtime</a></h1>
<p>To resolve an annotation at runtime from its string form to the result
of the enclosed expression, user code needs to evaluate the string.</p>
<p>For code that uses type hints, the
<tt class="docutils literal">typing.get_type_hints(obj, globalns=None, localns=None)</tt> function
correctly evaluates expressions back from its string form.  Note that
all valid code currently using <tt class="docutils literal">__annotations__</tt> should already be
doing that since a type annotation can be expressed as a string literal.</p>
<p>For code which uses annotations for other purposes, a regular
<tt class="docutils literal">eval(ann, globals, locals)</tt> call is enough to resolve the
annotation.</p>
<p>In both cases it's important to consider how globals and locals affect
the postponed evaluation.  An annotation is no longer evaluated at the
time of definition and, more importantly, <em>in the same scope</em> where it
was defined.  Consequently, using local state in annotations is no
longer possible in general.  As for globals, the module where the
annotation was defined is the correct context for postponed evaluation.</p>
<p>The <tt class="docutils literal">get_type_hints()</tt> function automatically resolves the correct
value of <tt class="docutils literal">globalns</tt> for functions and classes.  It also automatically
provides the correct <tt class="docutils literal">localns</tt> for classes.</p>
<p>When running <tt class="docutils literal">eval()</tt>,
the value of globals can be gathered in the following way:</p>
<ul>
<li><p class="first">function objects hold a reference to their respective globals in an
attribute called <tt class="docutils literal">__globals__</tt>;</p>
</li>
<li><p class="first">classes hold the name of the module they were defined in, this can be
used to retrieve the respective globals:</p>
<pre class="literal-block">
cls_globals = vars(sys.modules[SomeClass.__module__])
</pre>
<p>Note that this needs to be repeated for base classes to evaluate all
<tt class="docutils literal">__annotations__</tt>.</p>
</li>
<li><p class="first">modules should use their own <tt class="docutils literal">__dict__</tt>.</p>
</li>
</ul>
<p>The value of <tt class="docutils literal">localns</tt> cannot be reliably retrieved for functions
because in all likelihood the stack frame at the time of the call no
longer exists.</p>
<p>For classes, <tt class="docutils literal">localns</tt> can be composed by chaining vars of the given
class and its base classes (in the method resolution order).  Since slots
can only be filled after the class was defined, we don't need to consult
them for this purpose.</p>
<div class="section" id="runtime-annotation-resolution-and-class-decorators">
<h2><a class="toc-backref" href="#id8">Runtime annotation resolution and class decorators</a></h2>
<p>Metaclasses and class decorators that need to resolve annotations for
the current class will fail for annotations that use the name of the
current class.  Example:</p>
<pre class="literal-block">
def class_decorator(cls):
    annotations = get_type_hints(cls)  # raises NameError on 'C'
    print(f'Annotations for {cls}: {annotations}')
    return cls

&#64;class_decorator
class C:
    singleton: 'C' = None
</pre>
<p>This was already true before this PEP.  The class decorator acts on
the class before it's assigned a name in the current definition scope.</p>
</div>
<div class="section" id="runtime-annotation-resolution-and-type-checking">
<h2><a class="toc-backref" href="#id9">Runtime annotation resolution and <tt class="docutils literal">TYPE_CHECKING</tt></a></h2>
<p>Sometimes there's code that must be seen by a type checker but should
not be executed.  For such situations the <tt class="docutils literal">typing</tt> module defines a
constant, <tt class="docutils literal">TYPE_CHECKING</tt>, that is considered <tt class="docutils literal">True</tt> during type
checking but <tt class="docutils literal">False</tt> at runtime.  Example:</p>
<pre class="literal-block">
import typing

if typing.TYPE_CHECKING:
    import expensive_mod

def a_func(arg: expensive_mod.SomeClass) -&gt; None:
    a_var: expensive_mod.SomeClass = arg
    ...
</pre>
<p>This approach is also useful when handling import cycles.</p>
<p>Trying to resolve annotations of <tt class="docutils literal">a_func</tt> at runtime using
<tt class="docutils literal">typing.get_type_hints()</tt> will fail since the name <tt class="docutils literal">expensive_mod</tt>
is not defined (<tt class="docutils literal">TYPE_CHECKING</tt> variable being <tt class="docutils literal">False</tt> at runtime).
This was already true before this PEP.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id10">Backwards Compatibility</a></h1>
<p>This is a backwards incompatible change.  Applications depending on
arbitrary objects to be directly present in annotations will break
if they are not using <tt class="docutils literal">typing.get_type_hints()</tt> or <tt class="docutils literal">eval()</tt>.</p>
<p>Annotations that depend on locals at the time of the function
definition will not be resolvable later.  Example:</p>
<pre class="literal-block">
def generate():
    A = Optional[int]
    class C:
        field: A = 1
        def method(self, arg: A) -&gt; None: ...
    return C
X = generate()
</pre>
<p>Trying to resolve annotations of <tt class="docutils literal">X</tt> later by using
<tt class="docutils literal">get_type_hints(X)</tt> will fail because <tt class="docutils literal">A</tt> and its enclosing scope no
longer exists.  Python will make no attempt to disallow such annotations
since they can often still be successfully statically analyzed, which is
the predominant use case for annotations.</p>
<p>Annotations using nested classes and their respective state are still
valid.  They can use local names or the fully qualified name.  Example:</p>
<pre class="literal-block">
class C:
    field = 'c_field'
    def method(self) -&gt; C.field:  # this is OK
        ...

    def method(self) -&gt; field:  # this is OK
        ...

    def method(self) -&gt; C.D:  # this is OK
        ...

    def method(self) -&gt; D:  # this is OK
        ...

    class D:
        field2 = 'd_field'
        def method(self) -&gt; C.D.field2:  # this is OK
            ...

        def method(self) -&gt; D.field2:  # this is OK
            ...

        def method(self) -&gt; field2:  # this is OK
            ...

        def method(self) -&gt; field:  # this FAILS, class D doesn't
            ...                     # see C's attributes,  This was
                                    # already true before this PEP.
</pre>
<p>In the presence of an annotation that isn't a syntactically valid
expression, SyntaxError is raised at compile time.  However, since names
aren't resolved at that time, no attempt is made to validate whether
used names are correct or not.</p>
<div class="section" id="deprecation-policy">
<h2><a class="toc-backref" href="#id11">Deprecation policy</a></h2>
<p>Starting with Python 3.7, a <tt class="docutils literal">__future__</tt> import is required to use the
described functionality.  No warnings are raised.</p>
<p>In Python 3.8 a <tt class="docutils literal">PendingDeprecationWarning</tt> is raised by the
compiler in the presence of type annotations in modules without the
<tt class="docutils literal">__future__</tt> import.</p>
<p>Starting with Python 3.9 the warning becomes a <tt class="docutils literal">DeprecationWarning</tt>.</p>
<p>In Python 4.0 this will become the default behavior.  Use of annotations
incompatible with this PEP is no longer supported.</p>
</div>
</div>
<div class="section" id="forward-references">
<h1><a class="toc-backref" href="#id12">Forward References</a></h1>
<p>Deliberately using a name before it was defined in the module is called
a forward reference.  For the purpose of this section, we'll call
any name imported or defined within a <tt class="docutils literal">if TYPE_CHECKING:</tt> block
a forward reference, too.</p>
<p>This PEP addresses the issue of forward references in <em>type annotations</em>.
The use of string literals will no longer be required in this case.
However, there are APIs in the <tt class="docutils literal">typing</tt> module that use other syntactic
constructs of the language, and those will still require working around
forward references with string literals.  The list includes:</p>
<ul>
<li><p class="first">type definitions:</p>
<pre class="literal-block">
T = TypeVar('T', bound='&lt;type&gt;')
UserId = NewType('UserId', '&lt;type&gt;')
Employee = NamedTuple('Employee', [('name', '&lt;type&gt;'), ('id', '&lt;type&gt;')])
</pre>
</li>
<li><p class="first">aliases:</p>
<pre class="literal-block">
Alias = Optional['&lt;type&gt;']
AnotherAlias = Union['&lt;type&gt;', '&lt;type&gt;']
YetAnotherAlias = '&lt;type&gt;'
</pre>
</li>
<li><p class="first">casting:</p>
<pre class="literal-block">
cast('&lt;type&gt;', value)
</pre>
</li>
<li><p class="first">base classes:</p>
<pre class="literal-block">
class C(Tuple['&lt;type&gt;', '&lt;type&gt;']): ...
</pre>
</li>
</ul>
<p>Depending on the specific case, some of the cases listed above might be
worked around by placing the usage in a <tt class="docutils literal">if TYPE_CHECKING:</tt> block.
This will not work for any code that needs to be available at runtime,
notably for base classes and casting.  For named tuples, using the new
class definition syntax introduced in Python 3.6 solves the issue.</p>
<p>In general, fixing the issue for <em>all</em> forward references requires
changing how module instantiation is performed in Python, from the
current single-pass top-down model.  This would be a major change in the
language and is out of scope for this PEP.</p>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id13">Rejected Ideas</a></h1>
<div class="section" id="keeping-the-ability-to-use-function-local-state-when-defining-annotations">
<h2><a class="toc-backref" href="#id14">Keeping the ability to use function local state when defining annotations</a></h2>
<p>With postponed evaluation, this would require keeping a reference to
the frame in which an annotation got created.  This could be achieved
for example by storing all annotations as lambdas instead of strings.</p>
<p>This would be prohibitively expensive for highly annotated code as the
frames would keep all their objects alive. That includes predominantly
objects that won't ever be accessed again.</p>
<p>To be able to address class-level scope, the lambda approach would
require a new kind of cell in the interpreter.  This would proliferate
the number of types that can appear in <tt class="docutils literal">__annotations__</tt>, as well as
wouldn't be as introspectable as strings.</p>
<p>Note that in the case of nested classes, the functionality to get the
effective &quot;globals&quot; and &quot;locals&quot; at definition time is provided by
<tt class="docutils literal">typing.get_type_hints()</tt>.</p>
<p>If a function generates a class or a function with annotations that
have to use local variables, it can populate the given generated
object's <tt class="docutils literal">__annotations__</tt> dictionary directly, without relying on
the compiler.</p>
</div>
<div class="section" id="disallowing-local-state-usage-for-classes-too">
<h2><a class="toc-backref" href="#id15">Disallowing local state usage for classes, too</a></h2>
<p>This PEP originally proposed limiting names within annotations to only
allow names from the model-level scope, including for classes.  The
author argued this makes name resolution unambiguous, including in cases
of conflicts between local names and module-level names.</p>
<p>This idea was ultimately rejected in case of classes.  Instead,
<tt class="docutils literal">typing.get_type_hints()</tt> got modified to populate the local namespace
correctly if class-level annotations are needed.</p>
<p>The reasons for rejecting the idea were that it goes against the
intuition of how scoping works in Python, and would break enough
existing type annotations to make the transition cumbersome.  Finally,
local scope access is required for class decorators to be able to
evaluate type annotations. This is because class decorators are applied
before the class receives its name in the outer scope.</p>
</div>
<div class="section" id="introducing-a-new-dictionary-for-the-string-literal-form-instead">
<h2><a class="toc-backref" href="#id16">Introducing a new dictionary for the string literal form instead</a></h2>
<p>Yury Selivanov shared the following idea:</p>
<ol class="arabic simple">
<li>Add a new special attribute to functions: <tt class="docutils literal">__annotations_text__</tt>.</li>
<li>Make <tt class="docutils literal">__annotations__</tt> a lazy dynamic mapping, evaluating
expressions from the corresponding key in <tt class="docutils literal">__annotations_text__</tt>
just-in-time.</li>
</ol>
<p>This idea is supposed to solve the backwards compatibility issue,
removing the need for a new <tt class="docutils literal">__future__</tt> import.  Sadly, this is not
enough.  Postponed evaluation changes which state the annotation has
access to.  While postponed evaluation fixes the forward reference
problem, it also makes it impossible to access function-level locals
anymore.  This alone is a source of backwards incompatibility which
justifies a deprecation period.</p>
<p>A <tt class="docutils literal">__future__</tt> import is an obvious and explicit indicator of opting
in for the new functionality.  It also makes it trivial for external
tools to recognize the difference between a Python files using the old
or the new approach.  In the former case, that tool would recognize that
local state access is allowed, whereas in the latter case it would
recognize that forward references are allowed.</p>
<p>Finally, just-in-time evaluation in <tt class="docutils literal">__annotations__</tt> is an
unnecessary step if <tt class="docutils literal">get_type_hints()</tt> is used later.</p>
</div>
<div class="section" id="dropping-annotations-with-o">
<h2><a class="toc-backref" href="#id17">Dropping annotations with -O</a></h2>
<p>There are two reasons this is not satisfying for the purpose of this
PEP.</p>
<p>First, this only addresses runtime cost, not forward references, those
still cannot be safely used in source code.  A library maintainer would
never be able to use forward references since that would force the
library users to use this new hypothetical -O switch.</p>
<p>Second, this throws the baby out with the bath water. Now <em>no</em> runtime
annotation use can be performed.  <a class="reference external" href="/dev/peps/pep-0557">PEP 557</a> is one example of a recent
development where evaluating type annotations at runtime is useful.</p>
<p>All that being said, a granular -O option to drop annotations is
a possibility in the future, as it's conceptually compatible with
existing -O behavior (dropping docstrings and assert statements).  This
PEP does not invalidate the idea.</p>
</div>
<div class="section" id="passing-string-literals-in-annotations-verbatim-to-annotations">
<h2><a class="toc-backref" href="#id18">Passing string literals in annotations verbatim to <tt class="docutils literal">__annotations__</tt></a></h2>
<p>This PEP originally suggested directly storing the contents of a string
literal under its respective key in <tt class="docutils literal">__annotations__</tt>.  This was
meant to simplify support for runtime type checkers.</p>
<p>Mark Shannon pointed out this idea was flawed since it wasn't handling
situations where strings are only part of a type annotation.</p>
<p>The inconsistency of it was always apparent but given that it doesn't
fully prevent cases of double-wrapping strings anyway, it is not worth
it.</p>
</div>
<div class="section" id="making-the-name-of-the-future-import-more-verbose">
<h2><a class="toc-backref" href="#id19">Making the name of the future import more verbose</a></h2>
<p>Instead of requiring the following import:</p>
<pre class="literal-block">
from __future__ import annotations
</pre>
<p>the PEP could call the feature more explicitly, for example
<tt class="docutils literal">string_annotations</tt>, <tt class="docutils literal">stringify_annotations</tt>,
<tt class="docutils literal">annotation_strings</tt>, <tt class="docutils literal">annotations_as_strings</tt>, <tt class="docutils literal">lazy_anotations</tt>,
<tt class="docutils literal">static_annotations</tt>, etc.</p>
<p>The problem with those names is that they are very verbose.  Each of
them besides <tt class="docutils literal">lazy_annotations</tt> would constitute the longest future
feature name in Python.  They are long to type and harder to remember
than the single-word form.</p>
<p>There is precedence of a future import name that sounds overly generic
but in practice was obvious to users as to what it does:</p>
<pre class="literal-block">
from __future__ import division
</pre>
</div>
</div>
<div class="section" id="prior-discussion">
<h1><a class="toc-backref" href="#id20">Prior discussion</a></h1>
<div class="section" id="in-pep-484">
<h2>In <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a></h2>
<p>The forward reference problem was discussed when <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> was originally
drafted, leading to the following statement in the document:</p>
<blockquote>
<p>A compromise is possible where a <tt class="docutils literal">__future__</tt> import could enable
turning <em>all</em> annotations in a given module into string literals, as
follows:</p>
<pre class="literal-block">
from __future__ import annotations

class ImSet:
    def add(self, a: ImSet) -&gt; List[ImSet]: ...

assert ImSet.add.__annotations__ == {
    'a': 'ImSet', 'return': 'List[ImSet]'
}
</pre>
<p>Such a <tt class="docutils literal">__future__</tt> import statement may be proposed in a separate
PEP.</p>
</blockquote>
</div>
<div class="section" id="python-typing-400">
<h2><a class="toc-backref" href="#id22">python/typing#400</a></h2>
<p>The problem was discussed at length on the typing module's GitHub
project, under <a class="reference external" href="https://github.com/python/typing/issues/400">Issue 400</a>.
The problem statement there includes critique of generic types requiring
imports from <tt class="docutils literal">typing</tt>.  This tends to be confusing to
beginners:</p>
<blockquote>
<p>Why this:</p>
<pre class="literal-block">
from typing import List, Set
def dir(o: object = ...) -&gt; List[str]: ...
def add_friends(friends: Set[Friend]) -&gt; None: ...
</pre>
<p>But not this:</p>
<pre class="literal-block">
def dir(o: object = ...) -&gt; list[str]: ...
def add_friends(friends: set[Friend]) -&gt; None ...
</pre>
<p>Why this:</p>
<pre class="literal-block">
up_to_ten = list(range(10))
friends = set()
</pre>
<p>But not this:</p>
<pre class="literal-block">
from typing import List, Set
up_to_ten = List[int](range(10))
friends = Set[Friend]()
</pre>
</blockquote>
<p>While typing usability is an interesting problem, it is out of scope
of this PEP.  Specifically, any extensions of the typing syntax
standardized in <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> will require their own respective PEPs and
approval.</p>
<p>Issue 400 ultimately suggests postponing evaluation of annotations and
keeping them as strings in <tt class="docutils literal">__annotations__</tt>, just like this PEP
specifies.  This idea was received well.  Ivan Levkivskyi supported
using the <tt class="docutils literal">__future__</tt> import and suggested unparsing the AST in
<tt class="docutils literal">compile.c</tt>.  Jukka Lehtosalo pointed out that there are some cases
of forward references where types are used outside of annotations and
postponed evaluation will not help those.  For those cases using the
string literal notation would still be required.  Those cases are
discussed briefly in the &quot;Forward References&quot; section of this PEP.</p>
<p>The biggest controversy on the issue was Guido van Rossum's concern
that untokenizing annotation expressions back to their string form has
no precedent in the Python programming language and feels like a hacky
workaround.  He said:</p>
<blockquote>
One thing that comes to mind is that it's a very random change to
the language.  It might be useful to have a more compact way to
indicate deferred execution of expressions (using less syntax than
<tt class="docutils literal">lambda:</tt>).  But why would the use case of type annotations be so
all-important to change the language to do it there first (rather
than proposing a more general solution), given that there's already
a solution for this particular use case that requires very minimal
syntax?</blockquote>
<p>Eventually, Ethan Smith and schollii voiced that feedback gathered
during PyCon US suggests that the state of forward references needs
fixing.  Guido van Rossum suggested coming back to the <tt class="docutils literal">__future__</tt>
idea, pointing out that to prevent abuse, it's important for the
annotations to be kept both syntactically valid and evaluating correctly
at runtime.</p>
</div>
<div class="section" id="first-draft-discussion-on-python-ideas">
<h2><a class="toc-backref" href="#id23">First draft discussion on python-ideas</a></h2>
<p>Discussion happened largely in two threads, <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-September/thread.html#47031">the original announcement</a>
and a follow-up called <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-September/thread.html#47108">PEP 563 and expensive backwards compatibility</a>.</p>
<p>The PEP received rather warm feedback (4 strongly in favor,
2 in favor with concerns, 2 against). The biggest voice of concern on
the former thread being Steven D'Aprano's review stating that the
problem definition of the PEP doesn't justify breaking backwards
compatibility.  In this response Steven seemed mostly concerned about
Python no longer supporting evaluation of annotations that depended on
local function/class state.</p>
<p>A few people voiced concerns that there are libraries using annotations
for non-typing purposes.  However, none of the named libraries would be
invalidated by this PEP.  They do require adapting to the new
requirement to call <tt class="docutils literal">eval()</tt> on the annotation with the correct
<tt class="docutils literal">globals</tt> and <tt class="docutils literal">locals</tt> set.</p>
<p>This detail about <tt class="docutils literal">globals</tt> and <tt class="docutils literal">locals</tt> having to be correct was
picked up by a number of commenters.  Nick Coghlan benchmarked turning
annotations into lambdas instead of strings, sadly this proved to be
much slower at runtime than the current situation.</p>
<p>The latter thread was started by Jim J. Jewett who stressed that
the ability to properly evaluate annotations is an important requirement
and backwards compatibility in that regard is valuable.  After some
discussion he admitted that side effects in annotations are a code smell
and modal support to either perform or not perform evaluation is
a messy solution.  His biggest concern remained loss of functionality
stemming from the evaluation restrictions on global and local scope.</p>
<p>Nick Coghlan pointed out that some of those evaluation restrictions from
the PEP could be lifted by a clever implementation of an evaluation
helper, which could solve self-referencing classes even in the form of a
class decorator.  He suggested the PEP should provide this helper
function in the standard library.</p>
</div>
<div class="section" id="second-draft-discussion-on-python-dev">
<h2><a class="toc-backref" href="#id24">Second draft discussion on python-dev</a></h2>
<p>Discussion happened mainly in the <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-November/150062.html">announcement thread</a>,
followed by a brief discussion under <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-November/150637.html">Mark Shannon's post</a>.</p>
<p>Steven D'Aprano was concerned whether it's acceptable for typos to be
allowed in annotations after the change proposed by the PEP.  Brett
Cannon responded that type checkers and other static analyzers (like
linters or programming text editors) will catch this type of error.
Jukka Lehtosalo added that this situation is analogous to how names in
function bodies are not resolved until the function is called.</p>
<p>A major topic of discussion was Nick Coghlan's suggestion to store
annotations in &quot;thunk form&quot;, in other words as a specialized lambda
which would be able to access class-level scope (and allow for scope
customization at call time).  He presented a possible design for it
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-November/150141.html">indirect attribute cells</a>).
This was later seen as equivalent to &quot;special forms&quot; in Lisp.  Guido van
Rossum expressed worry that this sort of feature cannot be safely
implemented in twelve weeks (i.e. in time before the Python 3.7 beta
freeze).</p>
<p>After a while it became clear that the point of division between
supporters of the string form vs. supporters of the thunk form is
actually about whether annotations should be perceived as a general
syntactic element vs. something tied to the type checking use case.</p>
<p>Finally, Guido van Rossum declared he's rejecting the thunk idea
based on the fact that it would require a new building block in the
interpreter.  This block would be exposed in annotations, multiplying
possible types of values stored in <tt class="docutils literal">__annotations__</tt> (arbitrary
objects, strings, and now thunks).  Moreover, thunks aren't as
introspectable as strings.  Most importantly, Guido van Rossum
explicitly stated interest in gradually restricting the use of
annotations to static typing (with an optional runtime component).</p>
<p>Nick Coghlan got convinced to <a class="reference external" href="/dev/peps/pep-0563">PEP 563</a>, too, promptly beginning
the mandatory bike shedding session on the name of the <tt class="docutils literal">__future__</tt>
import.  Many debaters agreed that <tt class="docutils literal">annotations</tt> seems like
an overly broad name for the feature name.  Guido van Rossum briefly
decided to call it <tt class="docutils literal">string_annotations</tt> but then changed his mind,
arguing that <tt class="docutils literal">division</tt> is a precedent of a broad name with a clear
meaning.</p>
<p>The final improvement to the PEP suggested in the discussion by Mark
Shannon was the rejection of the temptation to pass string literals
through to <tt class="docutils literal">__annotations__</tt> verbatim.</p>
<p>A side-thread of discussion started around the runtime penalty of
static typing, with topic like the import time of the <tt class="docutils literal">typing</tt>
module (which is comparable to <tt class="docutils literal">re</tt> without dependencies, and
three times as heavy as <tt class="docutils literal">re</tt> when counting dependencies).</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id25">Acknowledgements</a></h1>
<p>This document could not be completed without valuable input,
encouragement and advice from Guido van Rossum, Jukka Lehtosalo, and
Ivan Levkivskyi.</p>
<p>The implementation was throroughly reviewed by Serhiy Storchaka who
found all sorts of issues, including bugs, bad readability, and
performance problems.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id26">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

