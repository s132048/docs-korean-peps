<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3154</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Pickle protocol version 4</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3154.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Antoine Pitrou &lt;solipsis&#32;&#97;t&#32;pitrou.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2011-08-11</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2011-August/112821.html">https://mail.python.org/pipermail/python-dev/2011-August/112821.html</a></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130439.html">https://mail.python.org/pipermail/python-dev/2013-November/130439.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id16">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id17">Rationale</a></li>
<li><a class="reference internal" href="#proposed-changes" id="id18">Proposed changes</a><ul>
<li><a class="reference internal" href="#framing" id="id19">Framing</a></li>
<li><a class="reference internal" href="#binary-encoding-for-all-opcodes" id="id20">Binary encoding for all opcodes</a></li>
<li><a class="reference internal" href="#serializing-more-lookupable-objects" id="id21">Serializing more &quot;lookupable&quot; objects</a></li>
<li><a class="reference internal" href="#bit-opcodes-for-large-objects" id="id22">64-bit opcodes for large objects</a></li>
<li><a class="reference internal" href="#native-opcodes-for-sets-and-frozensets" id="id23">Native opcodes for sets and frozensets</a></li>
<li><a class="reference internal" href="#calling-new-with-keyword-arguments" id="id24">Calling __new__ with keyword arguments</a></li>
<li><a class="reference internal" href="#better-string-encoding" id="id25">Better string encoding</a></li>
<li><a class="reference internal" href="#smaller-memoization" id="id26">Smaller memoization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-new-opcodes" id="id27">Summary of new opcodes</a></li>
<li><a class="reference internal" href="#alternative-ideas" id="id28">Alternative ideas</a><ul>
<li><a class="reference internal" href="#prefetching" id="id29">Prefetching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgments" id="id30">Acknowledgments</a></li>
<li><a class="reference internal" href="#references" id="id31">References</a></li>
<li><a class="reference internal" href="#copyright" id="id32">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id16">Abstract</a></h1>
<p>Data serialized using the pickle module must be portable across Python
versions.  It should also support the latest language features as well
as implementation-specific features.  For this reason, the pickle
module knows about several protocols (currently numbered from 0 to 3),
each of which appeared in a different Python version.  Using a
low-numbered protocol version allows to exchange data with old Python
versions, while using a high-numbered protocol allows access to newer
features and sometimes more efficient resource use (both CPU time
required for (de)serializing, and disk size / network bandwidth
required for data transfer).</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id17">Rationale</a></h1>
<p>The latest current protocol, coincidentally named protocol 3, appeared
with Python 3.0 and supports the new incompatible features in the
language (mainly, unicode strings by default and the new bytes
object).  The opportunity was not taken at the time to improve the
protocol in other ways.</p>
<p>This PEP is an attempt to foster a number of incremental improvements
in a new pickle protocol version.  The PEP process is used in order to
gather as many improvements as possible, because the introduction of a
new pickle protocol should be a rare occurrence.</p>
</div>
<div class="section" id="proposed-changes">
<h1><a class="toc-backref" href="#id18">Proposed changes</a></h1>
<div class="section" id="framing">
<h2><a class="toc-backref" href="#id19">Framing</a></h2>
<p>Traditionally, when unpickling an object from a stream (by calling
<tt class="docutils literal">load()</tt> rather than <tt class="docutils literal">loads()</tt>), many small <tt class="docutils literal">read()</tt>
calls can be issued on the file-like object, with a potentially huge
performance impact.</p>
<p>Protocol 4, by contrast, features binary framing.  The general structure
of a pickle is thus the following:</p>
<pre class="literal-block">
+------+------+
| 0x80 | 0x04 |              protocol header (2 bytes)
+------+------+
|  OP  |                     FRAME opcode (1 byte)
+------+------+-----------+
| MM MM MM MM MM MM MM MM |  frame size (8 bytes, little-endian)
+------+------------------+
| .... |                     first frame contents (M bytes)
+------+
|  OP  |                     FRAME opcode (1 byte)
+------+------+-----------+
| NN NN NN NN NN NN NN NN |  frame size (8 bytes, little-endian)
+------+------------------+
| .... |                     second frame contents (N bytes)
+------+
  etc.
</pre>
<p>To keep the implementation simple, it is forbidden for a pickle opcode
to straddle frame boundaries.  The pickler takes care not to produce such
pickles, and the unpickler refuses them.  Also, there is no &quot;last frame&quot;
marker.  The last frame is simply the one which ends with a STOP opcode.</p>
<p>A well-written C implementation doesn't need additional memory copies
for the framing layer, preserving general (un)pickling efficiency.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">How the pickler decides to partition the pickle stream into frames is an
implementation detail.  For example, &quot;closing&quot; a frame as soon as it
reaches ~64 KiB is a reasonable choice for both performance and pickle
size overhead.</p>
</div>
</div>
<div class="section" id="binary-encoding-for-all-opcodes">
<h2><a class="toc-backref" href="#id20">Binary encoding for all opcodes</a></h2>
<p>The GLOBAL opcode, which is still used in protocol 3, uses the
so-called &quot;text&quot; mode of the pickle protocol, which involves looking
for newlines in the pickle stream.  It also complicates the implementation
of binary framing.</p>
<p>Protocol 4 forbids use of the GLOBAL opcode and replaces it with
GLOBAL_STACK, a new opcode which takes its operand from the stack.</p>
</div>
<div class="section" id="serializing-more-lookupable-objects">
<h2><a class="toc-backref" href="#id21">Serializing more &quot;lookupable&quot; objects</a></h2>
<p>By default, pickle is only able to serialize module-global functions and
classes.  Supporting other kinds of objects, such as unbound methods <a class="footnote-reference" href="#id12" id="id1">[4]</a>,
is a common request. Actually, third-party support for some of them, such
as bound methods, is implemented in the multiprocessing module <a class="footnote-reference" href="#id13" id="id2">[5]</a>.</p>
<p>The <tt class="docutils literal">__qualname__</tt> attribute from <a class="reference external" href="/dev/peps/pep-3155">PEP 3155</a> makes it possible to
lookup many more objects by name.  Making the GLOBAL_STACK opcode accept
dot-separated names would allow the standard pickle implementation to
support all those kinds of objects.</p>
</div>
<div class="section" id="bit-opcodes-for-large-objects">
<h2><a class="toc-backref" href="#id22">64-bit opcodes for large objects</a></h2>
<p>Current protocol versions export object sizes for various built-in
types (str, bytes) as 32-bit ints.  This forbids serialization of
large data <a class="footnote-reference" href="#id9" id="id3">[1]</a>.  New opcodes are required to support very large bytes
and str objects.</p>
</div>
<div class="section" id="native-opcodes-for-sets-and-frozensets">
<h2><a class="toc-backref" href="#id23">Native opcodes for sets and frozensets</a></h2>
<p>Many common built-in types (such as str, bytes, dict, list, tuple)
have dedicated opcodes to improve resource consumption when
serializing and deserializing them; however, sets and frozensets
don't.  Adding such opcodes would be an obvious improvement.  Also,
dedicated set support could help remove the current impossibility of
pickling self-referential sets <a class="footnote-reference" href="#id10" id="id4">[2]</a>.</p>
</div>
<div class="section" id="calling-new-with-keyword-arguments">
<h2><a class="toc-backref" href="#id24">Calling __new__ with keyword arguments</a></h2>
<p>Currently, classes whose <tt class="docutils literal">__new__</tt> mandates the use of keyword-only
arguments can not be pickled (or, rather, unpickled) <a class="footnote-reference" href="#id11" id="id5">[3]</a>.  Both a new
special method (<tt class="docutils literal">__getnewargs_ex__</tt>) and a new opcode (NEWOBJ_EX)
are needed.  The <tt class="docutils literal">__getnewargs_ex__</tt> method, if it exists, must
return a two-tuple <tt class="docutils literal">(args, kwargs)</tt> where the first item is the
tuple of positional arguments and the second item is the dict of
keyword arguments for the class's <tt class="docutils literal">__new__</tt> method.</p>
</div>
<div class="section" id="better-string-encoding">
<h2><a class="toc-backref" href="#id25">Better string encoding</a></h2>
<p>Short str objects currently have their length coded as a 4-bytes
integer, which is wasteful.  A specific opcode with a 1-byte length
would make many pickles smaller.</p>
</div>
<div class="section" id="smaller-memoization">
<h2><a class="toc-backref" href="#id26">Smaller memoization</a></h2>
<p>The PUT opcodes all require an explicit index to select in which entry
of the memo dictionary the top-of-stack is memoized.  However, in practice
those numbers are allocated in sequential order.  A new opcode, MEMOIZE,
will instead store the top-of-stack in at the index equal to the current
size of the memo dictionary.  This allows for shorter pickles, since PUT
opcodes are emitted for all non-atomic datatypes.</p>
</div>
</div>
<div class="section" id="summary-of-new-opcodes">
<h1><a class="toc-backref" href="#id27">Summary of new opcodes</a></h1>
<p>These reflect the state of the proposed implementation (thanks mostly
to Alexandre Vassalotti's work):</p>
<ul class="simple">
<li><tt class="docutils literal">FRAME</tt>: introduce a new frame (followed by the 8-byte frame size
and the frame contents).</li>
<li><tt class="docutils literal">SHORT_BINUNICODE</tt>: push a utf8-encoded str object with a one-byte
size prefix (therefore less than 256 bytes long).</li>
<li><tt class="docutils literal">BINUNICODE8</tt>: push a utf8-encoded str object with an eight-byte
size prefix (for strings longer than 2**32 bytes, which therefore cannot
be serialized using <tt class="docutils literal">BINUNICODE</tt>).</li>
<li><tt class="docutils literal">BINBYTES8</tt>: push a bytes object with an eight-byte size prefix
(for bytes objects longer than 2**32 bytes, which therefore cannot be
serialized using <tt class="docutils literal">BINBYTES</tt>).</li>
<li><tt class="docutils literal">EMPTY_SET</tt>: push a new empty set object on the stack.</li>
<li><tt class="docutils literal">ADDITEMS</tt>: add the topmost stack items to the set (to be used with
<tt class="docutils literal">EMPTY_SET</tt>).</li>
<li><tt class="docutils literal">FROZENSET</tt>: create a frozenset object from the topmost stack items,
and push it on the stack.</li>
<li><tt class="docutils literal">NEWOBJ_EX</tt>: take the three topmost stack items <tt class="docutils literal">cls</tt>, <tt class="docutils literal">args</tt>
and <tt class="docutils literal">kwargs</tt>, and push the result of calling
<tt class="docutils literal"><span class="pre">cls.__new__(*args,</span> **kwargs)</tt>.</li>
<li><tt class="docutils literal">STACK_GLOBAL</tt>: take the two topmost stack items <tt class="docutils literal">module_name</tt> and
<tt class="docutils literal">qualname</tt>, and push the result of looking up the dotted <tt class="docutils literal">qualname</tt>
in the module named <tt class="docutils literal">module_name</tt>.</li>
<li><tt class="docutils literal">MEMOIZE</tt>: store the top-of-stack object in the memo dictionary with
an index equal to the current size of the memo dictionary.</li>
</ul>
</div>
<div class="section" id="alternative-ideas">
<h1><a class="toc-backref" href="#id28">Alternative ideas</a></h1>
<div class="section" id="prefetching">
<h2><a class="toc-backref" href="#id29">Prefetching</a></h2>
<p>Serhiy Storchaka suggested to replace framing with a special PREFETCH
opcode (with a 2- or 4-bytes argument) to declare known pickle chunks
explicitly. Large data may be pickled outside such chunks.  A na√Øve
unpickler should be able to skip the PREFETCH opcode and still decode
pickles properly, but good error handling would require checking that
the PREFETCH length falls on an opcode boundary.</p>
</div>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id30">Acknowledgments</a></h1>
<p>In alphabetic order:</p>
<ul class="simple">
<li>Alexandre Vassalotti, for starting the second <a class="reference external" href="/dev/peps/pep-3154">PEP 3154</a> implementation <a class="footnote-reference" href="#id14" id="id6">[6]</a></li>
<li>Serhiy Storchaka, for discussing the framing proposal <a class="footnote-reference" href="#id14" id="id7">[6]</a></li>
<li>Stefan Mihaila, for starting the first <a class="reference external" href="/dev/peps/pep-3154">PEP 3154</a> implementation as a
Google Summer of Code project mentored by Alexandre Vassalotti <a class="footnote-reference" href="#id15" id="id8">[7]</a>.</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id31">References</a></h1>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>&quot;pickle not 64-bit ready&quot;:
<a class="reference external" href="http://bugs.python.org/issue11564">http://bugs.python.org/issue11564</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>&quot;Cannot pickle self-referencing sets&quot;:
<a class="reference external" href="http://bugs.python.org/issue9269">http://bugs.python.org/issue9269</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>&quot;pickle/copyreg doesn't support keyword only arguments in __new__&quot;:
<a class="reference external" href="http://bugs.python.org/issue4727">http://bugs.python.org/issue4727</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[4]</a></td><td>&quot;pickle should support methods&quot;:
<a class="reference external" href="http://bugs.python.org/issue9276">http://bugs.python.org/issue9276</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[5]</a></td><td>Lib/multiprocessing/forking.py:
<a class="reference external" href="http://hg.python.org/cpython/file/baea9f5f973c/Lib/multiprocessing/forking.py#l54">http://hg.python.org/cpython/file/baea9f5f973c/Lib/multiprocessing/forking.py#l54</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> Implement <a class="reference external" href="/dev/peps/pep-3154">PEP 3154</a>, by Alexandre Vassalotti
<a class="reference external" href="http://bugs.python.org/issue17810">http://bugs.python.org/issue17810</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>Implement <a class="reference external" href="/dev/peps/pep-3154">PEP 3154</a>, by Stefan Mihaila
<a class="reference external" href="http://bugs.python.org/issue15642">http://bugs.python.org/issue15642</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id32">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

