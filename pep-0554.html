<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">554</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Multiple Interpreters in the Stdlib</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Eric Snow &lt;ericsnowcurrently&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2017-09-05</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.8</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">07-Sep-2017, 08-Sep-2017, 13-Sep-2017, 05-Dec-2017</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id19">Abstract</a></li>
<li><a class="reference internal" href="#proposal" id="id20">Proposal</a><ul>
<li><a class="reference internal" href="#api-summary-for-interpreters-module" id="id21">API summary for interpreters module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id22">Examples</a><ul>
<li><a class="reference internal" href="#run-isolated-code" id="id23">Run isolated code</a></li>
<li><a class="reference internal" href="#run-in-a-thread" id="id24">Run in a thread</a></li>
<li><a class="reference internal" href="#pre-populate-an-interpreter" id="id25">Pre-populate an interpreter</a></li>
<li><a class="reference internal" href="#handling-an-exception" id="id26">Handling an exception</a></li>
<li><a class="reference internal" href="#synchronize-using-a-channel" id="id27">Synchronize using a channel</a></li>
<li><a class="reference internal" href="#sharing-a-file-descriptor" id="id28">Sharing a file descriptor</a></li>
<li><a class="reference internal" href="#passing-objects-via-marshal" id="id29">Passing objects via marshal</a></li>
<li><a class="reference internal" href="#passing-objects-via-pickle" id="id30">Passing objects via pickle</a></li>
<li><a class="reference internal" href="#running-a-module" id="id31">Running a module</a></li>
<li><a class="reference internal" href="#running-as-script-including-zip-archives-directories" id="id32">Running as script (including zip archives &amp; directories)</a></li>
<li><a class="reference internal" href="#running-in-a-thread-pool-executor" id="id33">Running in a thread pool executor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale" id="id34">Rationale</a><ul>
<li><a class="reference internal" href="#concerns" id="id35">Concerns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#about-subinterpreters" id="id36">About Subinterpreters</a><ul>
<li><a class="reference internal" href="#concurrency" id="id37">Concurrency</a></li>
<li><a class="reference internal" href="#shared-data" id="id38">Shared data</a></li>
<li><a class="reference internal" href="#interpreter-isolation" id="id39">Interpreter Isolation</a></li>
<li><a class="reference internal" href="#existing-usage" id="id40">Existing Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#provisional-status" id="id41">Provisional Status</a></li>
<li><a class="reference internal" href="#alternate-python-implementations" id="id42">Alternate Python Implementations</a></li>
<li><a class="reference internal" href="#interpreters-module-api" id="id43">&quot;interpreters&quot; Module API</a><ul>
<li><a class="reference internal" href="#api-for-sharing-data" id="id44">API for sharing data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-questions" id="id45">Open Questions</a></li>
<li><a class="reference internal" href="#open-implementation-questions" id="id46">Open Implementation Questions</a><ul>
<li><a class="reference internal" href="#does-every-interpreter-think-that-their-thread-is-the-main-thread" id="id47">Does every interpreter think that their thread is the &quot;main&quot; thread?</a></li>
<li><a class="reference internal" href="#disallow-subinterpreters-in-the-main-thread" id="id48">Disallow subinterpreters in the main thread?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deferred-functionality" id="id49">Deferred Functionality</a><ul>
<li><a class="reference internal" href="#interpreter-call" id="id50">Interpreter.call()</a></li>
<li><a class="reference internal" href="#timeout-arg-to-recv-and-send" id="id51">timeout arg to recv() and send()</a></li>
<li><a class="reference internal" href="#get-main" id="id52">get_main()</a></li>
<li><a class="reference internal" href="#interpreter-run-in-thread" id="id53">Interpreter.run_in_thread()</a></li>
<li><a class="reference internal" href="#synchronization-primitives" id="id54">Synchronization Primitives</a></li>
<li><a class="reference internal" href="#csp-library" id="id55">CSP Library</a></li>
<li><a class="reference internal" href="#syntactic-support" id="id56">Syntactic Support</a></li>
<li><a class="reference internal" href="#multiprocessing" id="id57">Multiprocessing</a></li>
<li><a class="reference internal" href="#c-extension-opt-in-opt-out" id="id58">C-extension opt-in/opt-out</a></li>
<li><a class="reference internal" href="#poisoning-channels" id="id59">Poisoning channels</a></li>
<li><a class="reference internal" href="#sending-channels-over-channels" id="id60">Sending channels over channels</a></li>
<li><a class="reference internal" href="#reseting-main" id="id61">Reseting __main__</a></li>
<li><a class="reference internal" href="#support-passing-ints-in-channels" id="id62">Support passing ints in channels</a></li>
<li><a class="reference internal" href="#file-descriptors-and-sockets-in-channels" id="id63">File descriptors and sockets in channels</a></li>
<li><a class="reference internal" href="#integration-with-async" id="id64">Integration with async</a></li>
<li><a class="reference internal" href="#support-for-iteration" id="id65">Support for iteration</a></li>
<li><a class="reference internal" href="#channel-context-managers" id="id66">Channel context managers</a></li>
<li><a class="reference internal" href="#pipes-and-queues" id="id67">Pipes and Queues</a></li>
<li><a class="reference internal" href="#interpreters-runfailederror" id="id68">interpreters.RunFailedError</a></li>
<li><a class="reference internal" href="#return-a-lock-from-send" id="id69">Return a lock from send()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas" id="id70">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#explicit-channel-association" id="id71">Explicit channel association</a></li>
<li><a class="reference internal" href="#use-pipes-instead-of-channels" id="id72">Use pipes instead of channels</a></li>
<li><a class="reference internal" href="#use-queues-instead-of-channels" id="id73">Use queues instead of channels</a></li>
<li><a class="reference internal" href="#enumerate" id="id74">&quot;enumerate&quot;</a></li>
<li><a class="reference internal" href="#alternate-solutions-to-prevent-leaking-exceptions-across-interpreters" id="id75">Alternate solutions to prevent leaking exceptions across interpreters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id76">References</a></li>
<li><a class="reference internal" href="#copyright" id="id77">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id19">Abstract</a></h1>
<p>CPython has supported multiple interpreters in the same process (AKA
&quot;subinterpreters&quot;) since version 1.5.  The feature has been available
via the C-API. <a class="citation-reference" href="#c-api" id="id1">[c-api]</a> Subinterpreters operate in
<a class="reference internal" href="#interpreter-isolation">relative isolation from one another</a>, which
provides the basis for an
<a class="reference internal" href="#concurrency">alternative concurrency model</a>.</p>
<p>This proposal introduces the stdlib <tt class="docutils literal">interpreters</tt> module.  The module
will be <a class="reference internal" href="#provisional-status">provisional</a>.  It exposes the basic
functionality of subinterpreters already provided by the C-API, along
with new functionality for sharing data between interpreters.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id20">Proposal</a></h1>
<p>The <tt class="docutils literal">interpreters</tt> module will be added to the stdlib.  It will
provide a high-level interface to subinterpreters and wrap a new
low-level <tt class="docutils literal">_interpreters</tt> (in the same was as the <tt class="docutils literal">threading</tt>
module).  See the <a class="reference internal" href="#examples">Examples</a> section for concrete usage and use cases.</p>
<p>Along with exposing the existing (in CPython) subinterpreter support,
the module will also provide a mechanism for sharing data between
interpreters.  This mechanism centers around &quot;channels&quot;, which are
similar to queues and pipes.</p>
<p>Note that <em>objects</em> are not shared between interpreters since they are
tied to the interpreter in which they were created.  Instead, the
objects' <em>data</em> is passed between interpreters.  See the <a class="reference internal" href="#shared-data">Shared data</a>
section for more details about sharing between interpreters.</p>
<p>At first only the following types will be supported for sharing:</p>
<ul class="simple">
<li>None</li>
<li>bytes</li>
<li><a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> buffer objects (via <tt class="docutils literal">send_buffer()</tt>)</li>
</ul>
<p>Support for other basic types (e.g. int, Ellipsis) will be added later.</p>
<div class="section" id="api-summary-for-interpreters-module">
<h2><a class="toc-backref" href="#id21">API summary for interpreters module</a></h2>
<p>Here is a summary of the API for the <tt class="docutils literal">interpreters</tt> module.  For a
more in-depth explanation of the proposed classes and functions, see
the <a class="reference internal" href="#interpreters-module-api">&quot;interpreters&quot; Module API</a> section below.</p>
<p>For creating and using interpreters:</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="1%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" colspan="2">signature</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td colspan="2">list_all() -&gt; [Intepreter]</td>
<td>Get all existing interpreters.</td>
</tr>
<tr><td colspan="2">get_current() -&gt; Interpreter</td>
<td>Get the currently running interpreter.</td>
</tr>
<tr><td colspan="2">create() -&gt; Interpreter</td>
<td>Initialize a new (idle) Python interpreter.</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">signature</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>class Interpreter(id)</td>
<td>A single interpreter.</td>
</tr>
<tr><td>.id</td>
<td>The interpreter's ID (read-only).</td>
</tr>
<tr><td>.is_running() -&gt; Bool</td>
<td>Is the interpreter currently executing code?</td>
</tr>
<tr><td>.destroy()</td>
<td>Finalize and destroy the interpreter.</td>
</tr>
<tr><td><dl class="first last docutils">
<dt>.run(src_str, /, *,</dt>
<dd>channels=None)</dd>
</dl>
</td>
<td><div class="first last line-block">
<div class="line">Run the given source code in the interpreter.</div>
<div class="line">(This blocks the current thread until done.)</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>For sharing data between interpreters:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">signature</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>is_shareable(obj) -&gt; Bool</td>
<td><div class="first last line-block">
<div class="line">Can the object's data be shared</div>
<div class="line">between interpreters?</div>
</div>
</td>
</tr>
<tr><td><dl class="first last docutils">
<dt>create_channel() -&gt;</dt>
<dd>(RecvChannel, SendChannel)</dd>
</dl>
</td>
<td><div class="first last line-block">
<div class="line">Create a new channel for passing</div>
<div class="line">data between interpreters.</div>
</div>
</td>
</tr>
<tr><td><dl class="first last docutils">
<dt>list_all_channels() -&gt;</dt>
<dd>[(RecvChannel, SendChannel)]</dd>
</dl>
</td>
<td>Get all open channels.</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">signature</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>class RecvChannel(id)</td>
<td>The receiving end of a channel.</td>
</tr>
<tr><td>.id</td>
<td>The channel's unique ID.</td>
</tr>
<tr><td>.interpreters</td>
<td>The list of associated interpreters.</td>
</tr>
<tr><td>.recv() -&gt; object</td>
<td><div class="first last line-block">
<div class="line">Get the next object from the channel,</div>
<div class="line">and wait if none have been sent.</div>
<div class="line">Associate the interpreter with the channel.</div>
</div>
</td>
</tr>
<tr><td><dl class="first last docutils">
<dt>.recv_nowait(default=None) -&gt;</dt>
<dd>object</dd>
</dl>
</td>
<td><div class="first last line-block">
<div class="line">Like recv(), but return the default</div>
<div class="line">instead of waiting.</div>
</div>
</td>
</tr>
<tr><td>.close()</td>
<td><div class="first last line-block">
<div class="line">No longer associate the current interpreter</div>
<div class="line">with the channel (on the receiving end).</div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">signature</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>class SendChannel(id)</td>
<td>The sending end of a channel.</td>
</tr>
<tr><td>.id</td>
<td>The channel's unique ID.</td>
</tr>
<tr><td>.interpreters</td>
<td>The list of associated interpreters.</td>
</tr>
<tr><td>.send(obj)</td>
<td><div class="first last line-block">
<div class="line">Send the object (i.e. its data) to the</div>
<div class="line">receiving end of the channel and wait.</div>
<div class="line">Associate the interpreter with the channel.</div>
</div>
</td>
</tr>
<tr><td>.send_nowait(obj)</td>
<td><div class="first last line-block">
<div class="line">Like send(), but Fail if not received.</div>
</div>
</td>
</tr>
<tr><td>.send_buffer(obj)</td>
<td><div class="first last line-block">
<div class="line">Send the object's (<a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a>) buffer to the</div>
<div class="line">receiving end of the channel and wait.</div>
<div class="line">Associate the interpreter with the channel.</div>
</div>
</td>
</tr>
<tr><td>.send_buffer_nowait(obj)</td>
<td><div class="first last line-block">
<div class="line">Like send_buffer(), but fail if not received.</div>
</div>
</td>
</tr>
<tr><td>.close()</td>
<td><div class="first last line-block">
<div class="line">No longer associate the current interpreter</div>
<div class="line">with the channel (on the sending end).</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id22">Examples</a></h1>
<div class="section" id="run-isolated-code">
<h2><a class="toc-backref" href="#id23">Run isolated code</a></h2>
<pre class="literal-block">
interp = interpreters.create()
print('before')
interp.run('print(&quot;during&quot;)')
print('after')
</pre>
</div>
<div class="section" id="run-in-a-thread">
<h2><a class="toc-backref" href="#id24">Run in a thread</a></h2>
<pre class="literal-block">
interp = interpreters.create()
def run():
    interp.run('print(&quot;during&quot;)')
t = threading.Thread(target=run)
print('before')
t.start()
print('after')
</pre>
</div>
<div class="section" id="pre-populate-an-interpreter">
<h2><a class="toc-backref" href="#id25">Pre-populate an interpreter</a></h2>
<pre class="literal-block">
interp = interpreters.create()
interp.run(tw.dedent(&quot;&quot;&quot;
    import some_lib
    import an_expensive_module
    some_lib.set_up()
    &quot;&quot;&quot;))
wait_for_request()
interp.run(tw.dedent(&quot;&quot;&quot;
    some_lib.handle_request()
    &quot;&quot;&quot;))
</pre>
</div>
<div class="section" id="handling-an-exception">
<h2><a class="toc-backref" href="#id26">Handling an exception</a></h2>
<pre class="literal-block">
interp = interpreters.create()
try:
    interp.run(tw.dedent(&quot;&quot;&quot;
        raise KeyError
        &quot;&quot;&quot;))
except KeyError:
    print(&quot;got the error from the subinterpreter&quot;)
</pre>
</div>
<div class="section" id="synchronize-using-a-channel">
<h2><a class="toc-backref" href="#id27">Synchronize using a channel</a></h2>
<pre class="literal-block">
interp = interpreters.create()
r, s = interpreters.create_channel()
def run():
    interp.run(tw.dedent(&quot;&quot;&quot;
        reader.recv()
        print(&quot;during&quot;)
        reader.close()
        &quot;&quot;&quot;),
        shared=dict(
            reader=r,
            ),
        )
t = threading.Thread(target=run)
print('before')
t.start()
print('after')
s.send(b'')
s.close()
</pre>
</div>
<div class="section" id="sharing-a-file-descriptor">
<h2><a class="toc-backref" href="#id28">Sharing a file descriptor</a></h2>
<pre class="literal-block">
interp = interpreters.create()
r1, s1 = interpreters.create_channel()
r2, s2 = interpreters.create_channel()
def run():
    interp.run(tw.dedent(&quot;&quot;&quot;
        fd = int.from_bytes(
                reader.recv(), 'big')
        for line in os.fdopen(fd):
            print(line)
        writer.send(b'')
        &quot;&quot;&quot;),
        shared=dict(
            reader=r,
            writer=s2,
            ),
        )
t = threading.Thread(target=run)
t.start()
with open('spamspamspam') as infile:
    fd = infile.fileno().to_bytes(1, 'big')
    s.send(fd)
    r.recv()
</pre>
</div>
<div class="section" id="passing-objects-via-marshal">
<h2><a class="toc-backref" href="#id29">Passing objects via marshal</a></h2>
<pre class="literal-block">
interp = interpreters.create()
r, s = interpreters.create_fifo()
interp.run(tw.dedent(&quot;&quot;&quot;
    import marshal
    &quot;&quot;&quot;),
    shared=dict(
        reader=r,
        ),
    )
def run():
    interp.run(tw.dedent(&quot;&quot;&quot;
        data = reader.recv()
        while data:
            obj = marshal.loads(data)
            do_something(obj)
            data = reader.recv()
        reader.close()
        &quot;&quot;&quot;))
t = threading.Thread(target=run)
t.start()
for obj in input:
    data = marshal.dumps(obj)
    s.send(data)
s.send(None)
</pre>
</div>
<div class="section" id="passing-objects-via-pickle">
<h2><a class="toc-backref" href="#id30">Passing objects via pickle</a></h2>
<pre class="literal-block">
interp = interpreters.create()
r, s = interpreters.create_channel()
interp.run(tw.dedent(&quot;&quot;&quot;
    import pickle
    &quot;&quot;&quot;),
    shared=dict(
        reader=r,
        ),
    )
def run():
    interp.run(tw.dedent(&quot;&quot;&quot;
        data = reader.recv()
        while data:
            obj = pickle.loads(data)
            do_something(obj)
            data = reader.recv()
        reader.close()
        &quot;&quot;&quot;))
t = threading.Thread(target=run)
t.start()
for obj in input:
    data = pickle.dumps(obj)
    s.send(data)
s.send(None)
</pre>
</div>
<div class="section" id="running-a-module">
<h2><a class="toc-backref" href="#id31">Running a module</a></h2>
<pre class="literal-block">
interp = interpreters.create()
main_module = mod_name
interp.run(f'import runpy; runpy.run_module({main_module!r})')
</pre>
</div>
<div class="section" id="running-as-script-including-zip-archives-directories">
<h2><a class="toc-backref" href="#id32">Running as script (including zip archives &amp; directories)</a></h2>
<pre class="literal-block">
interp = interpreters.create()
main_script = path_name
interp.run(f&quot;import runpy; runpy.run_path({main_script!r})&quot;)
</pre>
</div>
<div class="section" id="running-in-a-thread-pool-executor">
<h2><a class="toc-backref" href="#id33">Running in a thread pool executor</a></h2>
<pre class="literal-block">
interps = [interpreters.create() for i in range(5)]
with concurrent.futures.ThreadPoolExecutor(max_workers=len(interps)) as pool:
    print('before')
    for interp in interps:
        pool.submit(interp.run, 'print(&quot;starting&quot;); print(&quot;stopping&quot;)'
    print('after')
</pre>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id34">Rationale</a></h1>
<p>Running code in multiple interpreters provides a useful level of
isolation within the same process.  This can be leveraged in a number
of ways.  Furthermore, subinterpreters provide a well-defined framework
in which such isolation may extended.</p>
<p>Nick Coghlan explained some of the benefits through a comparison with
multi-processing <a class="citation-reference" href="#benefits" id="id2">[benefits]</a>:</p>
<pre class="literal-block">
[I] expect that communicating between subinterpreters is going
to end up looking an awful lot like communicating between
subprocesses via shared memory.

The trade-off between the two models will then be that one still
just looks like a single process from the point of view of the
outside world, and hence doesn't place any extra demands on the
underlying OS beyond those required to run CPython with a single
interpreter, while the other gives much stricter isolation
(including isolating C globals in extension modules), but also
demands much more from the OS when it comes to its IPC
capabilities.

The security risk profiles of the two approaches will also be quite
different, since using subinterpreters won't require deliberately
poking holes in the process isolation that operating systems give
you by default.
</pre>
<p>CPython has supported subinterpreters, with increasing levels of
support, since version 1.5.  While the feature has the potential
to be a powerful tool, subinterpreters have suffered from neglect
because they are not available directly from Python.  Exposing the
existing functionality in the stdlib will help reverse the situation.</p>
<p>This proposal is focused on enabling the fundamental capability of
multiple isolated interpreters in the same Python process.  This is a
new area for Python so there is relative uncertainly about the best
tools to provide as companions to subinterpreters.  Thus we minimize
the functionality we add in the proposal as much as possible.</p>
<div class="section" id="concerns">
<h2><a class="toc-backref" href="#id35">Concerns</a></h2>
<ul class="simple">
<li>&quot;subinterpreters are not worth the trouble&quot;</li>
</ul>
<p>Some have argued that subinterpreters do not add sufficient benefit
to justify making them an official part of Python.  Adding features
to the language (or stdlib) has a cost in increasing the size of
the language.  So an addition must pay for itself.  In this case,
subinterpreters provide a novel concurrency model focused on isolated
threads of execution.  Furthermore, they provide an opportunity for
changes in CPython that will allow simulateous use of multiple CPU
cores (currently prevented by the GIL).</p>
<p>Alternatives to subinterpreters include threading, async, and
multiprocessing.  Threading is limited by the GIL and async isn't
the right solution for every problem (nor for every person).
Multiprocessing is likewise valuable in some but not all situations.
Direct IPC (rather than via the multiprocessing module) provides
similar benefits but with the same caveat.</p>
<p>Notably, subinterpreters are not intended as a replacement for any of
the above.  Certainly they overlap in some areas, but the benefits of
subinterpreters include isolation and (potentially) performance.  In
particular, subinterpreters provide a direct route to an alternate
concurrency model (e.g. CSP) which has found success elsewhere and
will appeal to some Python users.  That is the core value that the
<tt class="docutils literal">interpreters</tt> module will provide.</p>
<ul class="simple">
<li>&quot;stdlib support for subinterpreters adds extra burden
on C extension authors&quot;</li>
</ul>
<p>In the <a class="reference internal" href="#interpreter-isolation">Interpreter Isolation</a> section below we identify ways in
which isolation in CPython's subinterpreters is incomplete.  Most
notable is extension modules that use C globals to store internal
state.  <a class="reference external" href="/dev/peps/pep-3121">PEP 3121</a> and <a class="reference external" href="/dev/peps/pep-0489">PEP 489</a> provide a solution for most of the
problem, but one still remains. <a class="citation-reference" href="#petr-c-ext" id="id3">[petr-c-ext]</a>  Until that is resolved,
C extension authors will face extra difficulty to support
subinterpreters.</p>
<p>Consequently, projects that publish extension modules may face an
increased maintenance burden as their users start using subinterpreters,
where their modules may break.  This situation is limited to modules
that use C globals (or use libraries that use C globals) to store
internal state.  For numpy, the reported-bug rate is one every 6
months. <a class="citation-reference" href="#bug-rate" id="id4">[bug-rate]</a></p>
<p>Ultimately this comes down to a question of how often it will be a
problem in practice: how many projects would be affected, how often
their users will be affected, what the additional maintenance burden
will be for projects, and what the overall benefit of subinterpreters
is to offset those costs.  The position of this PEP is that the actual
extra maintenance burden will be small and well below the threshold at
which subinterpreters are worth it.</p>
</div>
</div>
<div class="section" id="about-subinterpreters">
<h1><a class="toc-backref" href="#id36">About Subinterpreters</a></h1>
<div class="section" id="concurrency">
<h2><a class="toc-backref" href="#id37">Concurrency</a></h2>
<p>Concurrency is a challenging area of software development.  Decades of
research and practice have led to a wide variety of concurrency models,
each with different goals.  Most center on correctness and usability.</p>
<p>One class of concurrency models focuses on isolated threads of
execution that interoperate through some message passing scheme.  A
notable example is <a class="reference internal" href="#communicating-sequential-processes">Communicating Sequential Processes</a> (CSP), upon
which Go's concurrency is based.  The isolation inherent to
subinterpreters makes them well-suited to this approach.</p>
</div>
<div class="section" id="shared-data">
<h2><a class="toc-backref" href="#id38">Shared data</a></h2>
<p>Subinterpreters are inherently isolated (with caveats explained below),
in contrast to threads.  So the same communicate-via-shared-memory
approach doesn't work.  Without an alternative, effective use of
concurrency via subinterpreters is significantly limited.</p>
<p>The key challenge here is that sharing objects between interpreters
faces complexity due to various constraints on object ownership,
visibility, and mutability.  At a conceptual level it's easier to
reason about concurrency when objects only exist in one interpreter
at a time.  At a technical level, CPython's current memory model
limits how Python <em>objects</em> may be shared safely between interpreters;
effectively objects are bound to the interpreter in which they were
created.  Furthermore the complexity of <em>object</em> sharing increases as
subinterpreters become more isolated, e.g. after GIL removal.</p>
<p>Consequently,the mechanism for sharing needs to be carefully considered.
There are a number of valid solutions, several of which may be
appropriate to support in Python.  This proposal provides a single basic
solution: &quot;channels&quot;.  Ultimately, any other solution will look similar
to the proposed one, which will set the precedent.  Note that the
implementation of <tt class="docutils literal">Interpreter.run()</tt> can be done in a way that allows
for multiple solutions to coexist, but doing so is not technically
a part of the proposal here.</p>
<p>Regarding the proposed solution, &quot;channels&quot;, it is a basic, opt-in data
sharing mechanism that draws inspiration from pipes, queues, and CSP's
channels. <a class="citation-reference" href="#fifo" id="id5">[fifo]</a></p>
<p>As simply described earlier by the API summary,
channels have two operations: send and receive.  A key characteristic
of those operations is that channels transmit data derived from Python
objects rather than the objects themselves.  When objects are sent,
their data is extracted.  When the &quot;object&quot; is received in the other
interpreter, the data is converted back into an object.</p>
<p>To make this work, the mutable shared state will be managed by the
Python runtime, not by any of the interpreters.  Initially we will
support only one type of objects for shared state: the channels provided
by <tt class="docutils literal">create_channel()</tt>.  Channels, in turn, will carefully manage
passing objects between interpreters.</p>
<p>This approach, including keeping the API minimal, helps us avoid further
exposing any underlying complexity to Python users.  Along those same
lines, we will initially restrict the types that may be passed through
channels to the following:</p>
<ul class="simple">
<li>None</li>
<li>bytes</li>
<li><a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> buffer objects (via <tt class="docutils literal">send_buffer()</tt>)</li>
</ul>
<p>Limiting the initial shareable types is a practical matter, reducing
the potential complexity of the initial implementation.  There are a
number of strategies we may pursue in the future to expand supported
objects and object sharing strategies.</p>
</div>
<div class="section" id="interpreter-isolation">
<h2><a class="toc-backref" href="#id39">Interpreter Isolation</a></h2>
<p>CPython's interpreters are intended to be strictly isolated from each
other.  Each interpreter has its own copy of all modules, classes,
functions, and variables.  The same applies to state in C, including in
extension modules.  The CPython C-API docs explain more. <a class="citation-reference" href="#caveats" id="id6">[caveats]</a></p>
<p>However, there are ways in which interpreters share some state.  First
of all, some process-global state remains shared:</p>
<ul class="simple">
<li>file descriptors</li>
<li>builtin types (e.g. dict, bytes)</li>
<li>singletons (e.g. None)</li>
<li>underlying static module data (e.g. functions) for
builtin/extension/frozen modules</li>
</ul>
<p>There are no plans to change this.</p>
<p>Second, some isolation is faulty due to bugs or implementations that did
not take subinterpreters into account.  This includes things like
extension modules that rely on C globals. <a class="citation-reference" href="#cryptography" id="id7">[cryptography]</a>  In these
cases bugs should be opened (some are already):</p>
<ul class="simple">
<li>readline module hook functions (<a class="reference external" href="http://bugs.python.org/issue4202">http://bugs.python.org/issue4202</a>)</li>
<li>memory leaks on re-init (<a class="reference external" href="http://bugs.python.org/issue21387">http://bugs.python.org/issue21387</a>)</li>
</ul>
<p>Finally, some potential isolation is missing due to the current design
of CPython.  Improvements are currently going on to address gaps in this
area:</p>
<ul class="simple">
<li>interpreters share the GIL</li>
<li>interpreters share memory management (e.g. allocators, gc)</li>
<li>GC is not run per-interpreter <a class="citation-reference" href="#global-gc" id="id8">[global-gc]</a></li>
<li>at-exit handlers are not run per-interpreter <a class="citation-reference" href="#global-atexit" id="id9">[global-atexit]</a></li>
<li>extensions using the <tt class="docutils literal">PyGILState_*</tt> API are incompatible <a class="citation-reference" href="#gilstate" id="id10">[gilstate]</a></li>
</ul>
</div>
<div class="section" id="existing-usage">
<h2><a class="toc-backref" href="#id40">Existing Usage</a></h2>
<p>Subinterpreters are not a widely used feature.  In fact, the only
documented cases of wide-spread usage are
<a class="reference external" href="https://github.com/GrahamDumpleton/mod_wsgi">mod_wsgi</a> and
<a class="reference external" href="https://github.com/ninia/jep">JEP</a>.  On the one hand, this case
provides confidence that existing subinterpreter support is relatively
stable.  On the other hand, there isn't much of a sample size from which
to judge the utility of the feature.</p>
</div>
</div>
<div class="section" id="provisional-status">
<h1><a class="toc-backref" href="#id41">Provisional Status</a></h1>
<p>The new <tt class="docutils literal">interpreters</tt> module will be added with &quot;provisional&quot; status
(see <a class="reference external" href="/dev/peps/pep-0411">PEP 411</a>).  This allows Python users to experiment with the feature
and provide feedback while still allowing us to adjust to that feedback.
The module will be provisional in Python 3.7 and we will make a decision
before the 3.8 release whether to keep it provisional, graduate it, or
remove it.</p>
</div>
<div class="section" id="alternate-python-implementations">
<h1><a class="toc-backref" href="#id42">Alternate Python Implementations</a></h1>
<p>I'll be soliciting feedback from the different Python implementors about
subinterpreter support.</p>
<p>Multiple-interpter support in the major Python implementations:</p>
<p>TBD</p>
<ul class="simple">
<li>jython: yes <a class="citation-reference" href="#jython" id="id11">[jython]</a></li>
<li>ironpython: yes?</li>
<li>pypy: maybe not? <a class="citation-reference" href="#pypy" id="id12">[pypy]</a></li>
<li>micropython: ???</li>
</ul>
</div>
<div class="section" id="interpreters-module-api">
<h1><a class="toc-backref" href="#id43">&quot;interpreters&quot; Module API</a></h1>
<p>The module provides the following functions:</p>
<p><tt class="docutils literal">list_all()</tt>:</p>
<pre class="literal-block">
Return a list of all existing interpreters.
</pre>
<p><tt class="docutils literal">get_current()</tt>:</p>
<pre class="literal-block">
Return the currently running interpreter.
</pre>
<p><tt class="docutils literal">create()</tt>:</p>
<pre class="literal-block">
Initialize a new Python interpreter and return it.  The
interpreter will be created in the current thread and will remain
idle until something is run in it.  The interpreter may be used
in any thread and will run in whichever thread calls
``interp.run()``.
</pre>
<p>The module also provides the following class:</p>
<p><tt class="docutils literal">Interpreter(id)</tt>:</p>
<pre class="literal-block">
id:

   The interpreter's ID (read-only).

is_running():

   Return whether or not the interpreter is currently executing code.
   Calling this on the current interpreter will always return True.

destroy():

   Finalize and destroy the interpreter.

   This may not be called on an already running interpreter.  Doing
   so results in a RuntimeError.

run(source_str, /, *, channels=None):

   Run the provided Python source code in the interpreter.  If the
   &quot;channels&quot; keyword argument is provided (and is a mapping of
   attribute names to channels) then it is added to the interpreter's
   execution namespace (the interpreter's &quot;__main__&quot; module).  If any
   of the values are not are not RecvChannel or SendChannel instances
   then ValueError gets raised.

   This may not be called on an already running interpreter.  Doing
   so results in a RuntimeError.

   A &quot;run()&quot; call is similar to a function call.  Once it completes,
   the code that called &quot;run()&quot; continues executing (in the original
   interpreter).  Likewise, if there is any uncaught exception then
   it effectively (see below) propagates into the code where
   ``run()`` was called.  However, unlike function calls (but like
   threads), there is no return value.  If any value is needed, pass
   it out via a channel.

   The big difference is that &quot;run()&quot; executes the code in an
   entirely different interpreter, with entirely separate state.
   The state of the current interpreter in the current OS thread
   is swapped out with the state of the target interpreter (the one
   that will execute the code).  When the target finishes executing,
   the original interpreter gets swapped back in and its execution
   resumes.

   So calling &quot;run()&quot; will effectively cause the current Python
   thread to pause.  Sometimes you won't want that pause, in which
   case you should make the &quot;run()&quot; call in another thread.  To do
   so, add a function that calls &quot;run()&quot; and then run that function
   in a normal &quot;threading.Thread&quot;.

   Note that the interpreter's state is never reset, neither before
   &quot;run()&quot; executes the code nor after.  Thus the interpreter
   state is preserved between calls to &quot;run()&quot;.  This includes
   &quot;sys.modules&quot;, the &quot;builtins&quot; module, and the internal state
   of C extension modules.

   Also note that &quot;run()&quot; executes in the namespace of the &quot;__main__&quot;
   module, just like scripts, the REPL, &quot;-m&quot;, and &quot;-c&quot;.  Just as
   the interpreter's state is not ever reset, the &quot;__main__&quot; module
   is never reset.  You can imagine concatenating the code from each
   &quot;run()&quot; call into one long script.  This is the same as how the
   REPL operates.

   Regarding uncaught exceptions, we noted that they are
   &quot;effectively&quot; propagated into the code where ``run()`` was called.
   To prevent leaking exceptions (and tracebacks) between
   interpreters, we create a surrogate of the exception and its
   traceback (see ``traceback.TracebackException``), wrap it in a
   RuntimeError, and raise that.

   Supported code: source text.
</pre>
<div class="section" id="api-for-sharing-data">
<h2><a class="toc-backref" href="#id44">API for sharing data</a></h2>
<p>Subinterpreters are less useful without a mechanism for sharing data
between them.  Sharing actual Python objects between interpreters,
however, has enough potential problems that we are avoiding support
for that here.  Instead, only mimimum set of types will be supported.
Initially this will include <tt class="docutils literal">bytes</tt> and channels.  Further types may
be supported later.</p>
<p>The <tt class="docutils literal">interpreters</tt> module provides a way for users to determine
whether an object is shareable or not:</p>
<p><tt class="docutils literal">is_shareable(obj)</tt>:</p>
<pre class="literal-block">
Return True if the object may be shared between interpreters.  This
does not necessarily mean that the actual objects will be shared.
Insead, it means that the objects' underlying data will be shared in
a cross-interpreter way, whether via a proxy, a copy, or some other
means.
</pre>
<p>This proposal provides two ways to do share such objects between
interpreters.</p>
<p>First, shareable objects may be passed to <tt class="docutils literal">run()</tt> as keyword arguments,
where they are effectively injected into the target interpreter's
<tt class="docutils literal">__main__</tt> module.  This is mainly intended for sharing meta-objects
(e.g. channels) between interpreters, as it is less useful to pass other
objects (like <tt class="docutils literal">bytes</tt>) to <tt class="docutils literal">run</tt>.</p>
<p>Second, the main mechanism for sharing objects (i.e. their data) between
interpreters is through channels.  A channel is a simplex FIFO similar
to a pipe.  The main difference is that channels can be associated with
zero or more interpreters on either end.  Unlike queues, which are also
many-to-many, channels have no buffer.</p>
<p><tt class="docutils literal">create_channel()</tt>:</p>
<pre class="literal-block">
Create a new channel and return (recv, send), the RecvChannel and
SendChannel corresponding to the ends of the channel.  The channel
is not closed and destroyed (i.e. garbage-collected) until the number
of associated interpreters returns to 0.

An interpreter gets associated with a channel by calling its &quot;send()&quot;
or &quot;recv()&quot; method.  That association gets dropped by calling
&quot;close()&quot; on the channel.

Both ends of the channel are supported &quot;shared&quot; objects (i.e. may be
safely shared by different interpreters.  Thus they may be passed as
keyword arguments to &quot;Interpreter.run()&quot;.
</pre>
<p><tt class="docutils literal">list_all_channels()</tt>:</p>
<pre class="literal-block">
Return a list of all open (RecvChannel, SendChannel) pairs.
</pre>
<p><tt class="docutils literal">RecvChannel(id)</tt>:</p>
<pre class="literal-block">
The receiving end of a channel.  An interpreter may use this to
receive objects from another interpreter.  At first only bytes will
be supported.

id:

   The channel's unique ID.

interpreters:

   The list of associated interpreters: those that have called
   the &quot;recv()&quot; or &quot;__next__()&quot; methods and haven't called &quot;close()&quot;.

recv():

   Return the next object (i.e. the data from the sent object) from
   the channel.  If none have been sent then wait until the next
   send.  This associates the current interpreter with the channel.

   If the channel is already closed (see the close() method)
   then raise EOFError.  If the channel isn't closed, but the current
   interpreter already called the &quot;close()&quot; method (which drops its
   association with the channel) then raise ValueError.

recv_nowait(default=None):

   Return the next object from the channel.  If none have been sent
   then return the default.  Otherwise, this is the same as the
   &quot;recv()&quot; method.

close():

   No longer associate the current interpreter with the channel (on
   the receiving end) and block future association (via the &quot;recv()&quot;
   method.  If the interpreter was never associated with the channel
   then still block future association.  Once an interpreter is no
   longer associated with the channel, subsequent (or current) send()
   and recv() calls from that interpreter will raise ValueError
   (or EOFError if the channel is actually marked as closed).

   Once the number of associated interpreters on both ends drops
   to 0, the channel is actually marked as closed.  The Python
   runtime will garbage collect all closed channels, though it may
   not be immediately.  Note that &quot;close()&quot; is automatically called
   in behalf of the current interpreter when the channel is no longer
   used (i.e. has no references) in that interpreter.

   This operation is idempotent.  Return True if &quot;close()&quot; has not
   been called before by the current interpreter.
</pre>
<p><tt class="docutils literal">SendChannel(id)</tt>:</p>
<pre class="literal-block">
The sending end of a channel.  An interpreter may use this to send
objects to another interpreter.  At first only bytes will be
supported.

id:

   The channel's unique ID.

interpreters:

   The list of associated interpreters (those that have called
   the &quot;send()&quot; method).

send(obj):

   Send the object (i.e. its data) to the receiving end of the
   channel.  Wait until the object is received.  If the the
   object is not shareable then ValueError is raised.  Currently
   only bytes are supported.

   If the channel is already closed (see the close() method)
   then raise EOFError.  If the channel isn't closed, but the current
   interpreter already called the &quot;close()&quot; method (which drops its
   association with the channel) then raise ValueError.

send_nowait(obj):

   Send the object to the receiving end of the channel.  If the other
   end is not currently receiving then raise RuntimeError.  Otherwise
   this is the same as &quot;send()&quot;.

send_buffer(obj):

   Send a MemoryView of the object rather than the object.  Otherwise
   this is the same as send().  Note that the object must implement
   the PEP 3118 buffer protocol.

send_buffer_nowait(obj):

   Send a MemoryView of the object rather than the object.  If the
   other end is not currently receiving then raise RuntimeError.
   Otherwise this is the same as &quot;send_buffer()&quot;.

close():

   This is the same as &quot;RecvChannel.close(), but applied to the
   sending end of the channel.
</pre>
<p>Note that <tt class="docutils literal">send_buffer()</tt> is similar to how
<tt class="docutils literal">multiprocessing.Connection</tt> works. <a class="citation-reference" href="#mp-conn" id="id13">[mp-conn]</a></p>
</div>
</div>
<div class="section" id="open-questions">
<h1><a class="toc-backref" href="#id45">Open Questions</a></h1>
<p>None</p>
</div>
<div class="section" id="open-implementation-questions">
<h1><a class="toc-backref" href="#id46">Open Implementation Questions</a></h1>
<div class="section" id="does-every-interpreter-think-that-their-thread-is-the-main-thread">
<h2><a class="toc-backref" href="#id47">Does every interpreter think that their thread is the &quot;main&quot; thread?</a></h2>
<p>(This is more of an implementation detail that an issue for the PEP.)</p>
<p>CPython's interpreter implementation identifies the OS thread in which
it was started as the &quot;main&quot; thread.  The interpreter the has slightly
different behavior depending on if the current thread is the main one
or not.  This presents a problem in cases where &quot;main thread&quot; is meant
to imply &quot;main thread in the main interpreter&quot; <a class="citation-reference" href="#main-thread" id="id14">[main-thread]</a>, where
the main interpreter is the initial one.</p>
</div>
<div class="section" id="disallow-subinterpreters-in-the-main-thread">
<h2><a class="toc-backref" href="#id48">Disallow subinterpreters in the main thread?</a></h2>
<p>(This is more of an implementation detail that an issue for the PEP.)</p>
<p>This is a specific case of the above issue.  Currently in CPython,
&quot;we need a main *thread* in order to sensibly manage the way signal
handling works across different platforms&quot;.  <a class="citation-reference" href="#main-thread" id="id15">[main-thread]</a></p>
<p>Since signal handlers are part of the interpreter state, running a
subinterpreter in the main thread means that the main interpreter
can no longer properly handle signals (since it's effectively paused).</p>
<p>Furthermore, running a subinterpreter in the main thread would
conceivably allow setting signal handlers on that interpreter, which
would likewise impact signal handling when that interpreter isn't
running or is running in a different thread.</p>
<p>Ultimately, running subinterpreters in the main OS thread introduces
complications to the signal handling implementation.  So it may make
the most sense to disallow running subinterpreters in the main thread.
Support for it could be considered later.  The downside is that folks
wanting to try out subinterpreters would be required to take the extra
step of using threads.  This could slow adoption and experimentation,
whereas without the restriction there's less of an obstacle.</p>
</div>
</div>
<div class="section" id="deferred-functionality">
<h1><a class="toc-backref" href="#id49">Deferred Functionality</a></h1>
<p>In the interest of keeping this proposal minimal, the following
functionality has been left out for future consideration.  Note that
this is not a judgement against any of said capability, but rather a
deferment.  That said, each is arguably valid.</p>
<div class="section" id="interpreter-call">
<h2><a class="toc-backref" href="#id50">Interpreter.call()</a></h2>
<p>It would be convenient to run existing functions in subinterpreters
directly.  <tt class="docutils literal">Interpreter.run()</tt> could be adjusted to support this or
a <tt class="docutils literal">call()</tt> method could be added:</p>
<pre class="literal-block">
Interpreter.call(f, *args, **kwargs)
</pre>
<p>This suffers from the same problem as sharing objects between
interpreters via queues.  The minimal solution (running a source string)
is sufficient for us to get the feature out where it can be explored.</p>
</div>
<div class="section" id="timeout-arg-to-recv-and-send">
<h2><a class="toc-backref" href="#id51">timeout arg to recv() and send()</a></h2>
<p>Typically functions that have a <tt class="docutils literal">block</tt> argument also have a
<tt class="docutils literal">timeout</tt> argument.  It sometimes makes sense to do likewise for
functions that otherwise block, like the channel <tt class="docutils literal">recv()</tt> and
<tt class="docutils literal">send()</tt> methods.  We can add it later if needed.</p>
</div>
<div class="section" id="get-main">
<h2><a class="toc-backref" href="#id52">get_main()</a></h2>
<p>CPython has a concept of a &quot;main&quot; interpreter.  This is the initial
interpreter created during CPython's runtime initialization.  It may
be useful to identify the main interpreter.  For instance, the main
interpreter should not be destroyed.  However, for the basic
functionality of a high-level API a <tt class="docutils literal">get_main()</tt> function is not
necessary.  Furthermore, there is no requirement that a Python
implementation have a concept of a main interpreter.  So until there's
a clear need we'll leave <tt class="docutils literal">get_main()</tt> out.</p>
</div>
<div class="section" id="interpreter-run-in-thread">
<h2><a class="toc-backref" href="#id53">Interpreter.run_in_thread()</a></h2>
<p>This method would make a <tt class="docutils literal">run()</tt> call for you in a thread.  Doing this
using only <tt class="docutils literal">threading.Thread</tt> and <tt class="docutils literal">run()</tt> is relatively trivial so
we've left it out.</p>
</div>
<div class="section" id="synchronization-primitives">
<h2><a class="toc-backref" href="#id54">Synchronization Primitives</a></h2>
<p>The <tt class="docutils literal">threading</tt> module provides a number of synchronization primitives
for coordinating concurrent operations.  This is especially necessary
due to the shared-state nature of threading.  In contrast,
subinterpreters do not share state.  Data sharing is restricted to
channels, which do away with the need for explicit synchronization.  If
any sort of opt-in shared state support is added to subinterpreters in
the future, that same effort can introduce synchronization primitives
to meet that need.</p>
</div>
<div class="section" id="csp-library">
<h2><a class="toc-backref" href="#id55">CSP Library</a></h2>
<p>A <tt class="docutils literal">csp</tt> module would not be a large step away from the functionality
provided by this PEP.  However, adding such a module is outside the
minimalist goals of this proposal.</p>
</div>
<div class="section" id="syntactic-support">
<h2><a class="toc-backref" href="#id56">Syntactic Support</a></h2>
<p>The <tt class="docutils literal">Go</tt> language provides a concurrency model based on CSP, so
it's similar to the concurrency model that subinterpreters support.
<tt class="docutils literal">Go</tt> provides syntactic support, as well several builtin concurrency
primitives, to make concurrency a first-class feature.  Conceivably,
similar syntactic (and builtin) support could be added to Python using
subinterpreters.  However, that is <em>way</em> outside the scope of this PEP!</p>
</div>
<div class="section" id="multiprocessing">
<h2><a class="toc-backref" href="#id57">Multiprocessing</a></h2>
<p>The <tt class="docutils literal">multiprocessing</tt> module could support subinterpreters in the same
way it supports threads and processes.  In fact, the module's
maintainer, Davin Potts, has indicated this is a reasonable feature
request.  However, it is outside the narrow scope of this PEP.</p>
</div>
<div class="section" id="c-extension-opt-in-opt-out">
<h2><a class="toc-backref" href="#id58">C-extension opt-in/opt-out</a></h2>
<p>By using the <tt class="docutils literal">PyModuleDef_Slot</tt> introduced by <a class="reference external" href="/dev/peps/pep-0489">PEP 489</a>, we could easily
add a mechanism by which C-extension modules could opt out of support
for subinterpreters.  Then the import machinery, when operating in
a subinterpreter, would need to check the module for support.  It would
raise an ImportError if unsupported.</p>
<p>Alternately we could support opting in to subinterpreter support.
However, that would probably exclude many more modules (unnecessarily)
than the opt-out approach.</p>
<p>The scope of adding the ModuleDef slot and fixing up the import
machinery is non-trivial, but could be worth it.  It all depends on
how many extension modules break under subinterpreters.  Given the
relatively few cases we know of through mod_wsgi, we can leave this
for later.</p>
</div>
<div class="section" id="poisoning-channels">
<h2><a class="toc-backref" href="#id59">Poisoning channels</a></h2>
<p>CSP has the concept of poisoning a channel.  Once a channel has been
poisoned, and <tt class="docutils literal">send()</tt> or <tt class="docutils literal">recv()</tt> call on it will raise a special
exception, effectively ending execution in the interpreter that tried
to use the poisoned channel.</p>
<p>This could be accomplished by adding a <tt class="docutils literal">poison()</tt> method to both ends
of the channel.  The <tt class="docutils literal">close()</tt> method could work if it had a <tt class="docutils literal">force</tt>
option to force the channel closed.  Regardless, these semantics are
relatively specialized and can wait.</p>
</div>
<div class="section" id="sending-channels-over-channels">
<h2><a class="toc-backref" href="#id60">Sending channels over channels</a></h2>
<p>Some advanced usage of subinterpreters could take advantage of the
ability to send channels over channels, in addition to bytes.  Given
that channels will already be multi-interpreter safe, supporting then
in <tt class="docutils literal">RecvChannel.recv()</tt> wouldn't be a big change.  However, this can
wait until the basic functionality has been ironed out.</p>
</div>
<div class="section" id="reseting-main">
<h2><a class="toc-backref" href="#id61">Reseting __main__</a></h2>
<p>As proposed, every call to <tt class="docutils literal">Interpreter.run()</tt> will execute in the
namespace of the interpreter's existing <tt class="docutils literal">__main__</tt> module.  This means
that data persists there between <tt class="docutils literal">run()</tt> calls.  Sometimes this isn't
desireable and you want to execute in a fresh <tt class="docutils literal">__main__</tt>.  Also,
you don't necessarily want to leak objects there that you aren't using
any more.</p>
<p>Note that the following won't work right because it will clear too much
(e.g. <tt class="docutils literal">__name__</tt> and the other &quot;__dunder__&quot; attributes:</p>
<pre class="literal-block">
interp.run('globals().clear()')
</pre>
<p>Possible solutions include:</p>
<ul class="simple">
<li>a <tt class="docutils literal">create()</tt> arg to indicate resetting <tt class="docutils literal">__main__</tt> after each
<tt class="docutils literal">run</tt> call</li>
<li>an <tt class="docutils literal">Interpreter.reset_main</tt> flag to support opting in or out
after the fact</li>
<li>an <tt class="docutils literal">Interpreter.reset_main()</tt> method to opt in when desired</li>
<li><tt class="docutils literal">importlib.util.reset_globals()</tt> <a class="citation-reference" href="#reset-globals" id="id16">[reset_globals]</a></li>
</ul>
<p>Also note that reseting <tt class="docutils literal">__main__</tt> does nothing about state stored
in other modules.  So any solution would have to be clear about the
scope of what is being reset.  Conceivably we could invent a mechanism
by which any (or every) module could be reset, unlike <tt class="docutils literal">reload()</tt>
which does not clear the module before loading into it.  Regardless,
since <tt class="docutils literal">__main__</tt> is the execution namespace of the interpreter,
resetting it has a much more direct correlation to interpreters and
their dynamic state than does resetting other modules.  So a more
generic module reset mechanism may prove unnecessary.</p>
<p>This isn't a critical feature initially.  It can wait until later
if desirable.</p>
</div>
<div class="section" id="support-passing-ints-in-channels">
<h2><a class="toc-backref" href="#id62">Support passing ints in channels</a></h2>
<p>Passing ints around should be fine and ultimately is probably
desirable.  However, we can get by with serializing them as bytes
for now.  The goal is a minimal API for the sake of basic
functionality at first.</p>
</div>
<div class="section" id="file-descriptors-and-sockets-in-channels">
<h2><a class="toc-backref" href="#id63">File descriptors and sockets in channels</a></h2>
<p>Given that file descriptors and sockets are process-global resources,
support for passing them through channels is a reasonable idea.  They
would be a good candidate for the first effort at expanding the types
that channels support.  They aren't strictly necessary for the initial
API.</p>
</div>
<div class="section" id="integration-with-async">
<h2><a class="toc-backref" href="#id64">Integration with async</a></h2>
<p>Per Antoine Pitrou <a class="citation-reference" href="#async" id="id17">[async]</a>:</p>
<pre class="literal-block">
Has any thought been given to how FIFOs could integrate with async
code driven by an event loop (e.g. asyncio)?  I think the model of
executing several asyncio (or Tornado) applications each in their
own subinterpreter may prove quite interesting to reconcile multi-
core concurrency with ease of programming.  That would require the
FIFOs to be able to synchronize on something an event loop can wait
on (probably a file descriptor?).
</pre>
<p>A possible solution is to provide async implementations of the blocking
channel methods (<tt class="docutils literal">__next__()</tt>, <tt class="docutils literal">recv()</tt>, and <tt class="docutils literal">send()</tt>).  However,
the basic functionality of subinterpreters does not depend on async and
can be added later.</p>
</div>
<div class="section" id="support-for-iteration">
<h2><a class="toc-backref" href="#id65">Support for iteration</a></h2>
<p>Supporting iteration on <tt class="docutils literal">RecvChannel</tt> (via <tt class="docutils literal">__iter__()</tt> or
<tt class="docutils literal">_next__()</tt>) may be useful.  A trivial implementation would use the
<tt class="docutils literal">recv()</tt> method, similar to how files do iteration.  Since this isn't
a fundamental capability and has a simple analog, adding iteration
support can wait until later.</p>
</div>
<div class="section" id="channel-context-managers">
<h2><a class="toc-backref" href="#id66">Channel context managers</a></h2>
<p>Context manager support on <tt class="docutils literal">RecvChannel</tt> and <tt class="docutils literal">SendChannel</tt> may be
helpful.  The implementation would be simple, wrapping a call to
<tt class="docutils literal">close()</tt> like files do.  As with iteration, this can wait.</p>
</div>
<div class="section" id="pipes-and-queues">
<h2><a class="toc-backref" href="#id67">Pipes and Queues</a></h2>
<p>With the proposed object passing machanism of &quot;channels&quot;, other similar
basic types aren't required to achieve the minimal useful functionality
of subinterpreters.  Such types include pipes (like channels, but
one-to-one) and queues (like channels, but buffered).  See below in
<cite>Rejected Ideas</cite> for more information.</p>
<p>Even though these types aren't part of this proposal, they may still
be useful in the context of concurrency.  Adding them later is entirely
reasonable.  The could be trivially implemented as wrappers around
channels.  Alternatively they could be implemented for efficiency at the
same low level as channels.</p>
</div>
<div class="section" id="interpreters-runfailederror">
<h2><a class="toc-backref" href="#id68">interpreters.RunFailedError</a></h2>
<p>As currently proposed, <tt class="docutils literal">Interpreter.run()</tt> offers you no way to
distinguish an error coming from the subinterpreter from any other
error in the current interpreter.  Your only option would be to
explicitly wrap your <tt class="docutils literal">run()</tt> call in a
<tt class="docutils literal">try: ... except RuntimeError:</tt> (since we wrap a proxy of the original
exception in a RuntimeError and raise that).</p>
<p>If this is a problem in practice then would could add something like
<tt class="docutils literal">interpreters.RunFailedError</tt> (subclassing RuntimeError) and raise that
in <tt class="docutils literal">run()</tt>.</p>
</div>
<div class="section" id="return-a-lock-from-send">
<h2><a class="toc-backref" href="#id69">Return a lock from send()</a></h2>
<p>When sending an object through a channel, you don't have a way of knowing
when the object gets received on the other end.  One way to work around
this is to return a locked <tt class="docutils literal">threading.Lock</tt> from <tt class="docutils literal">SendChannel.send()</tt>
that unlocks once the object is received.</p>
<p>This matters for buffered channels (i.e. queues).  For unbuffered
channels it is a non-issue.  So this can be dealt with once channels
support buffering.</p>
</div>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id70">Rejected Ideas</a></h1>
<div class="section" id="explicit-channel-association">
<h2><a class="toc-backref" href="#id71">Explicit channel association</a></h2>
<p>Interpreters are implicitly associated with channels upon <tt class="docutils literal">recv()</tt> and
<tt class="docutils literal">send()</tt> calls.  They are de-associated with <tt class="docutils literal">close()</tt> calls.  The
alternative would be explicit methods.  It would be either
<tt class="docutils literal">add_channel()</tt> and <tt class="docutils literal">remove_channel()</tt> methods on <tt class="docutils literal">Interpreter</tt>
objects or something similar on channel objects.</p>
<p>In practice, this level of management shouldn't be necessary for users.
So adding more explicit support would only add clutter to the API.</p>
</div>
<div class="section" id="use-pipes-instead-of-channels">
<h2><a class="toc-backref" href="#id72">Use pipes instead of channels</a></h2>
<p>A pipe would be a simplex FIFO between exactly two interpreters.  For
most use cases this would be sufficient.  It could potentially simplify
the implementation as well.  However, it isn't a big step to supporting
a many-to-many simplex FIFO via channels.  Also, with pipes the API
ends up being slightly more complicated, requiring naming the pipes.</p>
</div>
<div class="section" id="use-queues-instead-of-channels">
<h2><a class="toc-backref" href="#id73">Use queues instead of channels</a></h2>
<p>The main difference between queues and channels is that queues support
buffering.  This would complicate the blocking semantics of <tt class="docutils literal">recv()</tt>
and <tt class="docutils literal">send()</tt>.  Also, queues can be built on top of channels.</p>
</div>
<div class="section" id="enumerate">
<h2><a class="toc-backref" href="#id74">&quot;enumerate&quot;</a></h2>
<p>The <tt class="docutils literal">list_all()</tt> function provides the list of all interpreters.
In the threading module, which partly inspired the proposed API, the
function is called <tt class="docutils literal">enumerate()</tt>.  The name is different here to
avoid confusing Python users that are not already familiar with the
threading API.  For them &quot;enumerate&quot; is rather unclear, whereas
&quot;list_all&quot; is clear.</p>
</div>
<div class="section" id="alternate-solutions-to-prevent-leaking-exceptions-across-interpreters">
<h2><a class="toc-backref" href="#id75">Alternate solutions to prevent leaking exceptions across interpreters</a></h2>
<p>In function calls, uncaught exceptions propagate to the calling frame.
The same approach could be taken with <tt class="docutils literal">run()</tt>.  However, this would
mean that exception objects would leak across the inter-interpreter
boundary.  Likewise, the frames in the traceback would potentially leak.</p>
<p>While that might not be a problem currently, it would be a problem once
interpreters get better isolation relative to memory management (which
is necessary to stop sharing the GIL between interpreters).  We've
resolved the semantics of how the exceptions propagate by raising a
RuntimeError instead, which wraps a safe proxy for the original
exception and traceback.</p>
<p>Rejected possible solutions:</p>
<ul class="simple">
<li>set the RuntimeError's __cause__ to the proxy of the original
exception</li>
<li>reproduce the exception and traceback in the original interpreter
and raise that.</li>
<li>convert at the boundary (a la <tt class="docutils literal">subprocess.CalledProcessError</tt>)
(requires a cross-interpreter representation)</li>
<li>support customization via <tt class="docutils literal">Interpreter.excepthook</tt>
(requires a cross-interpreter representation)</li>
<li>wrap in a proxy at the boundary (including with support for
something like <tt class="docutils literal">err.raise()</tt> to propagate the traceback).</li>
<li>return the exception (or its proxy) from <tt class="docutils literal">run()</tt> instead of
raising it</li>
<li>return a result object (like <tt class="docutils literal">subprocess</tt> does) <a class="citation-reference" href="#result-object" id="id18">[result-object]</a>
(unecessary complexity?)</li>
<li>throw the exception away and expect users to deal with unhandled
exceptions explicitly in the script they pass to <tt class="docutils literal">run()</tt>
(they can pass error info out via channels); with threads you have
to do something similar</li>
</ul>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id76">References</a></h1>
<table class="docutils citation" frame="void" id="c-api" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[c-api]</a></td><td><a class="reference external" href="https://docs.python.org/3/c-api/init.html#sub-interpreter-support">https://docs.python.org/3/c-api/init.html#sub-interpreter-support</a></td></tr>
</tbody>
</table>
<span class="target" id="communicating-sequential-processes"></span><table class="docutils citation" frame="void" id="csp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[CSP]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">https://en.wikipedia.org/wiki/Communicating_sequential_processes</a>
<a class="reference external" href="https://github.com/futurecore/python-csp">https://github.com/futurecore/python-csp</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="fifo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[fifo]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe">https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe</a>
<a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue">https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue</a>
<a class="reference external" href="https://docs.python.org/3/library/queue.html#module-queue">https://docs.python.org/3/library/queue.html#module-queue</a>
<a class="reference external" href="http://stackless.readthedocs.io/en/2.7-slp/library/stackless/channels.html">http://stackless.readthedocs.io/en/2.7-slp/library/stackless/channels.html</a>
<a class="reference external" href="https://golang.org/doc/effective_go.html#sharing">https://golang.org/doc/effective_go.html#sharing</a>
<a class="reference external" href="http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-feel-bad/">http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-feel-bad/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="caveats" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[caveats]</a></td><td><a class="reference external" href="https://docs.python.org/3/c-api/init.html#bugs-and-caveats">https://docs.python.org/3/c-api/init.html#bugs-and-caveats</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="petr-c-ext" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[petr-c-ext]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/import-sig/2016-June/001062.html">https://mail.python.org/pipermail/import-sig/2016-June/001062.html</a>
<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-April/039748.html">https://mail.python.org/pipermail/python-ideas/2016-April/039748.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="cryptography" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[cryptography]</a></td><td><a class="reference external" href="https://github.com/pyca/cryptography/issues/2299">https://github.com/pyca/cryptography/issues/2299</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="global-gc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[global-gc]</a></td><td><a class="reference external" href="http://bugs.python.org/issue24554">http://bugs.python.org/issue24554</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gilstate" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[gilstate]</a></td><td><a class="reference external" href="https://bugs.python.org/issue10915">https://bugs.python.org/issue10915</a>
<a class="reference external" href="http://bugs.python.org/issue15751">http://bugs.python.org/issue15751</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="global-atexit" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[global-atexit]</a></td><td><a class="reference external" href="https://bugs.python.org/issue6531">https://bugs.python.org/issue6531</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="mp-conn" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[mp-conn]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Connection">https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Connection</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bug-rate" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[bug-rate]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-September/047094.html">https://mail.python.org/pipermail/python-ideas/2017-September/047094.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="benefits" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[benefits]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-September/047122.html">https://mail.python.org/pipermail/python-ideas/2017-September/047122.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="main-thread" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[main-thread]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id15">2</a>)</em> <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-September/047144.html">https://mail.python.org/pipermail/python-ideas/2017-September/047144.html</a>
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-September/149566.html">https://mail.python.org/pipermail/python-dev/2017-September/149566.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="reset-globals" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[reset_globals]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-September/149545.html">https://mail.python.org/pipermail/python-dev/2017-September/149545.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="async" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[async]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-September/149420.html">https://mail.python.org/pipermail/python-dev/2017-September/149420.html</a>
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-September/149585.html">https://mail.python.org/pipermail/python-dev/2017-September/149585.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="result-object" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[result-object]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-September/149562.html">https://mail.python.org/pipermail/python-dev/2017-September/149562.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="jython" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[jython]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-May/045771.html">https://mail.python.org/pipermail/python-ideas/2017-May/045771.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pypy" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[pypy]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-September/046973.html">https://mail.python.org/pipermail/python-ideas/2017-September/046973.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id77">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

