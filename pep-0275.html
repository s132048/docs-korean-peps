<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">275</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Switching on Multiple Values</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0275.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">mal&#32;&#97;t&#32;lemburg.com (Marc-André Lemburg)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">10-Nov-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection-notice" id="id5">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#problem" id="id7">Problem</a></li>
<li><a class="reference internal" href="#proposed-solutions" id="id8">Proposed Solutions</a><ul>
<li><a class="reference internal" href="#solution-1-optimizing-if-elif-else" id="id9">Solution 1: Optimizing if-elif-else</a></li>
<li><a class="reference internal" href="#solution-2-adding-a-switch-statement-to-python" id="id10">Solution 2: Adding a switch statement to Python</a><ul>
<li><a class="reference internal" href="#new-syntax" id="id11">New Syntax</a></li>
<li><a class="reference internal" href="#implementation" id="id12">Implementation</a></li>
<li><a class="reference internal" href="#issues" id="id13">Issues</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id14">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scope" id="id15">Scope</a></li>
<li><a class="reference internal" href="#credits" id="id16">Credits</a></li>
<li><a class="reference internal" href="#references" id="id17">References</a></li>
<li><a class="reference internal" href="#copyright" id="id18">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id5">Rejection Notice</a></h1>
<p>A similar PEP for Python 3000, <a class="reference external" href="/dev/peps/pep-3103">PEP 3103</a> <a class="footnote-reference" href="#id4" id="id1">[2]</a>, was already rejected,
so this proposal has no chance of being accepted either.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>This PEP proposes strategies to enhance Python's performance
with respect to handling switching on a single variable having
one of multiple possible values.</p>
</div>
<div class="section" id="problem">
<h1><a class="toc-backref" href="#id7">Problem</a></h1>
<p>Up to Python 2.5, the typical way of writing multi-value switches
has been to use long switch constructs of the following type:</p>
<pre class="literal-block">
if x == 'first state':
    ...
elif x == 'second state':
    ...
elif x == 'third state':
    ...
elif x == 'fourth state':
    ...
else:
    # default handling
    ...
</pre>
<p>This works fine for short switch constructs, since the overhead of
repeated loading of a local (the variable x in this case) and
comparing it to some constant is low (it has a complexity of O(n)
on average). However, when using such a construct to write a state
machine such as is needed for writing parsers the number of
possible states can easily reach 10 or more cases.</p>
<p>The current solution to this problem lies in using a dispatch
table to find the case implementing method to execute depending on
the value of the switch variable (this can be tuned to have a
complexity of O(1) on average, e.g. by using perfect hash
tables). This works well for state machines which require complex
and lengthy processing in the different case methods. It does not
perform well for ones which only process one or two instructions
per case, e.g.</p>
<pre class="literal-block">
def handle_data(self, data):
    self.stack.append(data)
</pre>
<p>A nice example of this is the state machine implemented in
pickle.py which is used to serialize Python objects. Other
prominent cases include XML SAX parsers and Internet protocol
handlers.</p>
</div>
<div class="section" id="proposed-solutions">
<h1><a class="toc-backref" href="#id8">Proposed Solutions</a></h1>
<p>This PEP proposes two different but not necessarily conflicting
solutions:</p>
<ol class="arabic simple">
<li>Adding an optimization to the Python compiler and VM
which detects the above if-elif-else construct and
generates special opcodes for it which use a read-only
dictionary for storing jump offsets.</li>
<li>Adding new syntax to Python which mimics the C style
switch statement.</li>
</ol>
<p>The first solution has the benefit of not relying on adding new
keywords to the language, while the second looks cleaner. Both
involve some run-time overhead to assure that the switching
variable is immutable and hashable.</p>
<p>Both solutions use a dictionary lookup to find the right
jump location, so they both share the same problem space in
terms of requiring that both the switch variable and the
constants need to be compatible to the dictionary implementation
(hashable, comparable, a==b =&gt; hash(a)==hash(b)).</p>
<div class="section" id="solution-1-optimizing-if-elif-else">
<h2><a class="toc-backref" href="#id9">Solution 1: Optimizing if-elif-else</a></h2>
<p>Implementation:</p>
<p>It should be possible for the compiler to detect an
if-elif-else construct which has the following signature:</p>
<pre class="literal-block">
if x == 'first':...
elif x == 'second':...
else:...
</pre>
<p>i.e. the left hand side always references the same variable,
the right hand side a hashable immutable builtin type.  The
right hand sides need not be all of the same type, but they
should be comparable to the type of the left hand switch
variable.</p>
<p>The compiler could then setup a read-only (perfect) hash
table, store it in the constants and add an opcode SWITCH in
front of the standard if-elif-else byte code stream which
triggers the following run-time behaviour:</p>
<p>At runtime, SWITCH would check x for being one of the
well-known immutable types (strings, unicode, numbers) and
use the hash table for finding the right opcode snippet. If
this condition is not met, the interpreter should revert to
the standard if-elif-else processing by simply skipping the
SWITCH opcode and procedding with the usual if-elif-else byte
code stream.</p>
<p>Issues:</p>
<p>The new optimization should not change the current Python
semantics (by reducing the number of <tt class="docutils literal">__cmp__</tt> calls and adding
<tt class="docutils literal">__hash__</tt> calls in if-elif-else constructs which are affected
by the optimiztation). To assure this, switching can only
safely be implemented either if a &quot;from __future__&quot; style
flag is used, or the switching variable is one of the builtin
immutable types: int, float, string, unicode, etc. (not
subtypes, since it's not clear whether these are still
immutable or not)</p>
<p>To prevent post-modifications of the jump-table dictionary
(which could be used to reach protected code), the jump-table
will have to be a read-only type (e.g. a read-only
dictionary).</p>
<p>The optimization should only be used for if-elif-else
constructs which have a minimum number of n cases (where n is
a number which has yet to be defined depending on performance
tests).</p>
</div>
<div class="section" id="solution-2-adding-a-switch-statement-to-python">
<h2><a class="toc-backref" href="#id10">Solution 2: Adding a switch statement to Python</a></h2>
<div class="section" id="new-syntax">
<h3><a class="toc-backref" href="#id11">New Syntax</a></h3>
<pre class="literal-block">
switch EXPR:
    case CONSTANT:
        SUITE
    case CONSTANT:
        SUITE
    ...
    else:
        SUITE
</pre>
<p>(modulo indentation variations)</p>
<p>The &quot;else&quot; part is optional. If no else part is given and
none of the defined cases matches, no action is taken and
the switch statement is ignored. This is in line with the
current if-behaviour. A user who wants to signal this
situation using an exception can define an else-branch
which then implements the intended action.</p>
<p>Note that the constants need not be all of the same type, but
they should be comparable to the type of the switch variable.</p>
</div>
<div class="section" id="implementation">
<h3><a class="toc-backref" href="#id12">Implementation</a></h3>
<p>The compiler would have to compile this into byte code
similar to this:</p>
<pre class="literal-block">
def whatis(x):
    switch(x):
        case 'one':
            print '1'
        case 'two':
            print '2'
        case 'three':
            print '3'
        else:
            print &quot;D'oh!&quot;
</pre>
<p>into (omitting POP_TOP's and SET_LINENO's):</p>
<pre class="literal-block">
   6  LOAD_FAST         0 (x)
   9  LOAD_CONST        1 (switch-table-1)
  12  SWITCH            26 (to 38)

  14  LOAD_CONST        2 ('1')
  17  PRINT_ITEM
  18  PRINT_NEWLINE
  19  JUMP 43

  22  LOAD_CONST        3 ('2')
  25  PRINT_ITEM
  26  PRINT_NEWLINE
  27  JUMP 43

  30  LOAD_CONST        4 ('3')
  33  PRINT_ITEM
  34  PRINT_NEWLINE
  35  JUMP 43

  38  LOAD_CONST        5 (&quot;D'oh!&quot;)
  41  PRINT_ITEM
  42  PRINT_NEWLINE

&gt;&gt;43  LOAD_CONST        0 (None)
  46  RETURN_VALUE
</pre>
<p>Where the 'SWITCH' opcode would jump to 14, 22, 30 or 38
depending on 'x'.</p>
<p>Thomas Wouters has written a patch which demonstrates the
above. You can download it from <a class="footnote-reference" href="#id3" id="id2">[1]</a>.</p>
</div>
<div class="section" id="issues">
<h3><a class="toc-backref" href="#id13">Issues</a></h3>
<p>The switch statement should not implement fall-through
behaviour (as does the switch statement in C). Each case
defines a complete and independent suite; much like in a
if-elif-else statement. This also enables using break in
switch statements inside loops.</p>
<p>If the interpreter finds that the switch variable x is
not hashable, it should raise a TypeError at run-time
pointing out the problem.</p>
<p>There have been other proposals for the syntax which reuse
existing keywords and avoid adding two new ones (&quot;switch&quot; and
&quot;case&quot;). Others have argued that the keywords should use new
terms to avoid confusion with the C keywords of the same name
but slightly different semantics (e.g. fall-through without
break). Some of the proposed variants:</p>
<pre class="literal-block">
case EXPR:
    of CONSTANT:
        SUITE
    of CONSTANT:
        SUITE
    else:
        SUITE

case EXPR:
    if CONSTANT:
         SUITE
    if CONSTANT:
        SUITE
    else:
        SUITE

when EXPR:
    in CONSTANT_TUPLE:
        SUITE
    in CONSTANT_TUPLE:
        SUITE
    ...
else:
     SUITE
</pre>
<p>The switch statement could be extended to allow multiple
values for one section (e.g. case 'a', 'b', 'c': ...). Another
proposed extension would allow ranges of values (e.g. case
10..14: ...). These should probably be post-poned, but already
kept in mind when designing and implementing a first version.</p>
</div>
</div>
<div class="section" id="examples">
<h2><a class="toc-backref" href="#id14">Examples</a></h2>
<p>The following examples all use a new syntax as proposed by
solution 2. However, all of these examples would work with
solution 1 as well.</p>
<pre class="literal-block">
switch EXPR:                   switch x:
    case CONSTANT:                 case &quot;first&quot;:
        SUITE                          print x
    case CONSTANT:                 case &quot;second&quot;:
        SUITE                          x = x**2
    ...                                print x
    else:                          else:
        SUITE                          print &quot;whoops!&quot;


case EXPR:                     case x:
    of CONSTANT:                   of &quot;first&quot;:
        SUITE                          print x
    of CONSTANT:                   of &quot;second&quot;:
        SUITE                          print x**2
    else:                          else:
        SUITE                          print &quot;whoops!&quot;


case EXPR:                     case state:
    if CONSTANT:                   if &quot;first&quot;:
         SUITE                         state = &quot;second&quot;
    if CONSTANT:                   if &quot;second&quot;:
        SUITE                          state = &quot;third&quot;
    else:                          else:
        SUITE                          state = &quot;first&quot;


when EXPR:                     when state:
    in CONSTANT_TUPLE:             in (&quot;first&quot;, &quot;second&quot;):
        SUITE                          print state
    in CONSTANT_TUPLE:                 state = next_state(state)
        SUITE                      in (&quot;seventh&quot;,):
    ...                                print &quot;done&quot;
else:                                  break    # out of loop!
     SUITE                     else:
                                   print &quot;middle state&quot;
                                   state = next_state(state)
</pre>
<p>Here's another nice application found by Jack Jansen (switching
on argument types):</p>
<pre class="literal-block">
switch type(x).__name__:
    case 'int':
        SUITE
    case 'string':
        SUITE
</pre>
</div>
</div>
<div class="section" id="scope">
<h1><a class="toc-backref" href="#id15">Scope</a></h1>
<p>XXX Explain &quot;from __future__ import switch&quot;</p>
</div>
<div class="section" id="credits">
<h1><a class="toc-backref" href="#id16">Credits</a></h1>
<ul class="simple">
<li>Martin von Löwis (issues with the optimization idea)</li>
<li>Thomas Wouters (switch statement + byte code compiler example)</li>
<li>Skip Montanaro (dispatching ideas, examples)</li>
<li>Donald Beaudry (switch syntax)</li>
<li>Greg Ewing (switch syntax)</li>
<li>Jack Jansen (type switching examples)</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id17">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="https://sourceforge.net/tracker/index.php?func=detail&amp;aid=481118&amp;group_id=5470&amp;atid=305470">https://sourceforge.net/tracker/index.php?func=detail&amp;aid=481118&amp;group_id=5470&amp;atid=305470</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td><a class="reference external" href="http://www.python.org/dev/peps/pep-3103">http://www.python.org/dev/peps/pep-3103</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id18">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

