<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">550</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Execution Context</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0550.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Yury Selivanov &lt;yury&#32;&#97;t&#32;magic.io&gt;,
Elvis Pranskevichus &lt;elvis&#32;&#97;t&#32;magic.io&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-Aug-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">11-Aug-2017, 15-Aug-2017, 18-Aug-2017, 25-Aug-2017,
01-Sep-2017</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id62">Abstract</a></li>
<li><a class="reference internal" href="#pep-status" id="id63">PEP Status</a></li>
<li><a class="reference internal" href="#rationale" id="id64">Rationale</a></li>
<li><a class="reference internal" href="#goals" id="id65">Goals</a></li>
<li><a class="reference internal" href="#high-level-specification" id="id66">High-Level Specification</a><ul>
<li><a class="reference internal" href="#regular-single-threaded-code" id="id67">Regular Single-threaded Code</a></li>
<li><a class="reference internal" href="#multithreaded-code" id="id68">Multithreaded Code</a></li>
<li><a class="reference internal" href="#generators" id="id69">Generators</a></li>
<li><a class="reference internal" href="#coroutines-and-asynchronous-tasks" id="id70">Coroutines and Asynchronous Tasks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-specification" id="id71">Detailed Specification</a><ul>
<li><a class="reference internal" href="#id5" id="id72">Generators</a></li>
<li><a class="reference internal" href="#contextlib-contextmanager" id="id73">contextlib.contextmanager</a></li>
<li><a class="reference internal" href="#enumerating-context-vars" id="id74">Enumerating context vars</a></li>
<li><a class="reference internal" href="#coroutines" id="id75">coroutines</a></li>
<li><a class="reference internal" href="#asynchronous-generators" id="id76">Asynchronous Generators</a></li>
<li><a class="reference internal" href="#asyncio" id="id77">asyncio</a></li>
<li><a class="reference internal" href="#generators-transformed-into-iterators" id="id78">Generators Transformed into Iterators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id79">Implementation</a><ul>
<li><a class="reference internal" href="#logical-context" id="id80">Logical Context</a></li>
<li><a class="reference internal" href="#context-variables" id="id81">Context Variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-considerations" id="id82">Performance Considerations</a></li>
<li><a class="reference internal" href="#summary-of-the-new-apis" id="id83">Summary of the New APIs</a><ul>
<li><a class="reference internal" href="#python" id="id84">Python</a></li>
<li><a class="reference internal" href="#c-api" id="id85">C API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-considerations" id="id86">Design Considerations</a><ul>
<li><a class="reference internal" href="#should-yield-from-leak-context-changes" id="id87">Should &quot;yield from&quot; leak context changes?</a></li>
<li><a class="reference internal" href="#should-pythreadstate-getdict-use-the-execution-context" id="id88">Should <tt class="docutils literal">PyThreadState_GetDict()</tt> use the execution context?</a></li>
<li><a class="reference internal" href="#pep-521" id="id89">PEP 521</a></li>
<li><a class="reference internal" href="#can-execution-context-be-implemented-without-modifying-cpython" id="id90">Can Execution Context be implemented without modifying CPython?</a></li>
<li><a class="reference internal" href="#should-we-update-sys-displayhook-and-other-apis-to-use-ec" id="id91">Should we update sys.displayhook and other APIs to use EC?</a></li>
<li><a class="reference internal" href="#greenlets" id="id92">Greenlets</a></li>
<li><a class="reference internal" href="#context-manager-as-the-interface-for-modifications" id="id93">Context manager as the interface for modifications</a></li>
<li><a class="reference internal" href="#setting-and-restoring-context-variables" id="id94">Setting and restoring context variables</a></li>
<li><a class="reference internal" href="#alternative-designs-for-contextvar-api" id="id95">Alternative Designs for ContextVar API</a><ul>
<li><a class="reference internal" href="#logical-context-with-stacked-values" id="id96">Logical Context with stacked values</a></li>
<li><a class="reference internal" href="#contextvar-set-reset" id="id97">ContextVar &quot;set/reset&quot;</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id98">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id99">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#replication-of-threading-local-interface" id="id100">Replication of threading.local() interface</a></li>
<li><a class="reference internal" href="#coroutines-not-leaking-context-changes-by-default" id="id101">Coroutines not leaking context changes by default</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-hamt-performance-analysis" id="id102">Appendix: HAMT Performance Analysis</a></li>
<li><a class="reference internal" href="#acknowledgments" id="id103">Acknowledgments</a></li>
<li><a class="reference internal" href="#version-history" id="id104">Version History</a></li>
<li><a class="reference internal" href="#references" id="id105">References</a></li>
<li><a class="reference internal" href="#copyright" id="id106">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id62">Abstract</a></h1>
<p>This PEP adds a new generic mechanism of ensuring consistent access
to non-local state in the context of out-of-order execution, such
as in Python generators and coroutines.</p>
<p>Thread-local storage, such as <tt class="docutils literal">threading.local()</tt>, is inadequate for
programs that execute concurrently in the same OS thread.  This PEP
proposes a solution to this problem.</p>
</div>
<div class="section" id="pep-status">
<h1><a class="toc-backref" href="#id63">PEP Status</a></h1>
<p>Due to its breadth and the lack of general consensus on some aspects, this
PEP has been withdrawn and superceded by a simpler <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a>, which has
been accepted and included in Python 3.7.</p>
<p><a class="reference external" href="/dev/peps/pep-0567">PEP 567</a> implements the same core idea, but limits the ContextVar support
to asynchronous tasks while leaving the generator behavior untouched.
The latter may be revisited in a future PEP.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id64">Rationale</a></h1>
<p>Prior to the advent of asynchronous programming in Python, programs
used OS threads to achieve concurrency.  The need for thread-specific
state was solved by <tt class="docutils literal">threading.local()</tt> and its C-API equivalent,
<tt class="docutils literal">PyThreadState_GetDict()</tt>.</p>
<p>A few examples of where Thread-local storage (TLS) is commonly
relied upon:</p>
<ul class="simple">
<li>Context managers like decimal contexts, <tt class="docutils literal">numpy.errstate</tt>,
and <tt class="docutils literal">warnings.catch_warnings</tt>.</li>
<li>Request-related data, such as security tokens and request
data in web applications, language context for <tt class="docutils literal">gettext</tt> etc.</li>
<li>Profiling, tracing, and logging in large code bases.</li>
</ul>
<p>Unfortunately, TLS does not work well for programs which execute
concurrently in a single thread.  A Python generator is the simplest
example of a concurrent program.  Consider the following:</p>
<pre class="literal-block">
def fractions(precision, x, y):
    with decimal.localcontext() as ctx:
        ctx.prec = precision
        yield Decimal(x) / Decimal(y)
        yield Decimal(x) / Decimal(y ** 2)

g1 = fractions(precision=2, x=1, y=3)
g2 = fractions(precision=6, x=2, y=3)

items = list(zip(g1, g2))
</pre>
<p>The intuitively expected value of <tt class="docutils literal">items</tt> is:</p>
<pre class="literal-block">
[(Decimal('0.33'), Decimal('0.666667')),
 (Decimal('0.11'), Decimal('0.222222'))]
</pre>
<p>Rather surprisingly, the actual result is:</p>
<pre class="literal-block">
[(Decimal('0.33'), Decimal('0.666667')),
 (Decimal('0.111111'), Decimal('0.222222'))]
</pre>
<p>This is because implicit Decimal context is stored as a thread-local,
so concurrent iteration of the <tt class="docutils literal">fractions()</tt> generator would
corrupt the state.  For Decimal, specifically, the only current
workaround is to use explicit context method calls for all arithmetic
operations <a class="footnote-reference" href="#id56" id="id1">[28]</a>.  Arguably, this defeats the usefulness of overloaded
operators and makes even simple formulas hard to read and write.</p>
<p>Coroutines are another class of Python code where TLS unreliability
is a significant issue.</p>
<p>The inadequacy of TLS in asynchronous code has lead to the
proliferation of ad-hoc solutions, which are limited in scope and
do not support all required use cases.</p>
<p>The current status quo is that any library (including the standard
library), which relies on TLS, is likely to be broken when used in
asynchronous code or with generators (see <a class="footnote-reference" href="#id31" id="id2">[3]</a> as an example issue.)</p>
<p>Some languages, that support coroutines or generators, recommend
passing the context manually as an argument to every function, see
<a class="footnote-reference" href="#id29" id="id3">[1]</a> for an example.  This approach, however, has limited use for
Python, where there is a large ecosystem that was built to work with
a TLS-like context.  Furthermore, libraries like <tt class="docutils literal">decimal</tt> or
<tt class="docutils literal">numpy</tt> rely on context implicitly in overloaded operator
implementations.</p>
<p>The .NET runtime, which has support for async/await, has a generic
solution for this problem, called <tt class="docutils literal">ExecutionContext</tt> (see <a class="footnote-reference" href="#id30" id="id4">[2]</a>).</p>
</div>
<div class="section" id="goals">
<h1><a class="toc-backref" href="#id65">Goals</a></h1>
<p>The goal of this PEP is to provide a more reliable
<tt class="docutils literal">threading.local()</tt> alternative, which:</p>
<ul class="simple">
<li>provides the mechanism and the API to fix non-local state issues
with coroutines and generators;</li>
<li>implements TLS-like semantics for synchronous code, so that
users like <tt class="docutils literal">decimal</tt> and <tt class="docutils literal">numpy</tt> can switch to the new
mechanism with minimal risk of breaking backwards compatibility;</li>
<li>has no or negligible performance impact on the existing code or
the code that will be using the new mechanism, including
C extensions.</li>
</ul>
</div>
<div class="section" id="high-level-specification">
<h1><a class="toc-backref" href="#id66">High-Level Specification</a></h1>
<p>The full specification of this PEP is broken down into three parts:</p>
<ul class="simple">
<li>High-Level Specification (this section): the description of the
overall solution.  We show how it applies to generators and
coroutines in user code, without delving into implementation
details.</li>
<li>Detailed Specification: the complete description of new concepts,
APIs, and related changes to the standard library.</li>
<li>Implementation Details: the description and analysis of data
structures and algorithms used to implement this PEP, as well as
the necessary changes to CPython.</li>
</ul>
<p>For the purpose of this section, we define <em>execution context</em> as an
opaque container of non-local state that allows consistent access to
its contents in the concurrent execution environment.</p>
<p>A <em>context variable</em> is an object representing a value in the
execution context.  A call to <tt class="docutils literal">contextvars.ContextVar(name)</tt>
creates a new context variable object.  A context variable object has
three methods:</p>
<ul class="simple">
<li><tt class="docutils literal">get()</tt>: returns the value of the variable in the current
execution context;</li>
<li><tt class="docutils literal">set(value)</tt>: sets the value of the variable in the current
execution context;</li>
<li><tt class="docutils literal">delete()</tt>: can be used for restoring variable state, it's
purpose and semantics are explained in
<a class="reference internal" href="#setting-and-restoring-context-variables">Setting and restoring context variables</a>.</li>
</ul>
<div class="section" id="regular-single-threaded-code">
<h2><a class="toc-backref" href="#id67">Regular Single-threaded Code</a></h2>
<p>In regular, single-threaded code that doesn't involve generators or
coroutines, context variables behave like globals:</p>
<pre class="literal-block">
var = contextvars.ContextVar('var')

def sub():
    assert var.get() == 'main'
    var.set('sub')

def main():
    var.set('main')
    sub()
    assert var.get() == 'sub'
</pre>
</div>
<div class="section" id="multithreaded-code">
<h2><a class="toc-backref" href="#id68">Multithreaded Code</a></h2>
<p>In multithreaded code, context variables behave like thread locals:</p>
<pre class="literal-block">
var = contextvars.ContextVar('var')

def sub():
    assert var.get() is None  # The execution context is empty
                              # for each new thread.
    var.set('sub')

def main():
    var.set('main')

    thread = threading.Thread(target=sub)
    thread.start()
    thread.join()

    assert var.get() == 'main'
</pre>
</div>
<div class="section" id="generators">
<h2><a class="toc-backref" href="#id69">Generators</a></h2>
<p>Unlike regular function calls, generators can cooperatively yield
their control of execution to the caller.  Furthermore, a generator
does not control <em>where</em> the execution would continue after it yields.
It may be resumed from an arbitrary code location.</p>
<p>For these reasons, the least surprising behaviour of generators is
as follows:</p>
<ul class="simple">
<li>changes to context variables are always local and are not visible
in the outer context, but are visible to the code called by the
generator;</li>
<li>once set in the generator, the context variable is guaranteed not
to change between iterations;</li>
<li>changes to context variables in outer context (where the generator
is being iterated) are visible to the generator, unless these
variables were also modified inside the generator.</li>
</ul>
<p>Let's review:</p>
<pre class="literal-block">
var1 = contextvars.ContextVar('var1')
var2 = contextvars.ContextVar('var2')

def gen():
    var1.set('gen')
    assert var1.get() == 'gen'
    assert var2.get() == 'main'
    yield 1

    # Modification to var1 in main() is shielded by
    # gen()'s local modification.
    assert var1.get() == 'gen'

    # But modifications to var2 are visible
    assert var2.get() == 'main modified'
    yield 2

def main():
    g = gen()

    var1.set('main')
    var2.set('main')
    next(g)

    # Modification of var1 in gen() is not visible.
    assert var1.get() == 'main'

    var1.set('main modified')
    var2.set('main modified')
    next(g)
</pre>
<p>Now, let's revisit the decimal precision example from the <a class="reference internal" href="#rationale">Rationale</a>
section, and see how the execution context can improve the situation:</p>
<pre class="literal-block">
import decimal

# create a new context var
decimal_ctx = contextvars.ContextVar('decimal context')

# Pre-PEP 550 Decimal relies on TLS for its context.
# For illustration purposes, we monkey-patch the decimal
# context functions to use the execution context.
# A real working fix would need to properly update the
# C implementation as well.
def patched_setcontext(context):
    decimal_ctx.set(context)

def patched_getcontext():
    ctx = decimal_ctx.get()
    if ctx is None:
        ctx = decimal.Context()
        decimal_ctx.set(ctx)
    return ctx

decimal.setcontext = patched_setcontext
decimal.getcontext = patched_getcontext

def fractions(precision, x, y):
    with decimal.localcontext() as ctx:
        ctx.prec = precision
        yield MyDecimal(x) / MyDecimal(y)
        yield MyDecimal(x) / MyDecimal(y ** 2)

g1 = fractions(precision=2, x=1, y=3)
g2 = fractions(precision=6, x=2, y=3)

items = list(zip(g1, g2))
</pre>
<p>The value of <tt class="docutils literal">items</tt> is:</p>
<pre class="literal-block">
[(Decimal('0.33'), Decimal('0.666667')),
 (Decimal('0.11'), Decimal('0.222222'))]
</pre>
<p>which matches the expected result.</p>
</div>
<div class="section" id="coroutines-and-asynchronous-tasks">
<h2><a class="toc-backref" href="#id70">Coroutines and Asynchronous Tasks</a></h2>
<p>Like generators, coroutines can yield and regain control.  The major
difference from generators is that coroutines do not yield to the
immediate caller.  Instead, the entire coroutine call stack
(coroutines chained by <tt class="docutils literal">await</tt>) switches to another coroutine call
stack.  In this regard, <tt class="docutils literal">await</tt>-ing on a coroutine is conceptually
similar to a regular function call, and a coroutine chain
(or a &quot;task&quot;, e.g. an <tt class="docutils literal">asyncio.Task</tt>) is conceptually similar to a
thread.</p>
<p>From this similarity we conclude that context variables in coroutines
should behave like &quot;task locals&quot;:</p>
<ul class="simple">
<li>changes to context variables in a coroutine are visible to the
coroutine that awaits on it;</li>
<li>changes to context variables made in the caller prior to awaiting
are visible to the awaited coroutine;</li>
<li>changes to context variables made in one task are not visible in
other tasks;</li>
<li>tasks spawned by other tasks inherit the execution context from the
parent task, but any changes to context variables made in the
parent task <em>after</em> the child task was spawned are <em>not</em> visible.</li>
</ul>
<p>The last point shows behaviour that is different from OS threads.
OS threads do not inherit the execution context by default.
There are two reasons for this: <em>common usage intent</em> and backwards
compatibility.</p>
<p>The main reason for why tasks inherit the context, and threads do
not, is the common usage intent.  Tasks are often used for relatively
short-running operations which are logically tied to the code that
spawned the task (like running a coroutine with a timeout in
asyncio).  OS threads, on the other hand, are normally used for
long-running, logically separate code.</p>
<p>With respect to backwards compatibility, we want the execution context
to behave like <tt class="docutils literal">threading.local()</tt>.  This is so that libraries can
start using the execution context in place of TLS with a lesser risk
of breaking compatibility with existing code.</p>
<p>Let's review a few examples to illustrate the semantics we have just
defined.</p>
<p>Context variable propagation in a single task:</p>
<pre class="literal-block">
import asyncio

var = contextvars.ContextVar('var')

async def main():
    var.set('main')
    await sub()
    # The effect of sub() is visible.
    assert var.get() == 'sub'

async def sub():
    assert var.get() == 'main'
    var.set('sub')
    assert var.get() == 'sub'

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</pre>
<p>Context variable propagation between tasks:</p>
<pre class="literal-block">
import asyncio

var = contextvars.ContextVar('var')

async def main():
    var.set('main')
    loop.create_task(sub())  # schedules asynchronous execution
                             # of sub().
    assert var.get() == 'main'
    var.set('main changed')

async def sub():
    # Sleeping will make sub() run after
    # &quot;var&quot; is modified in main().
    await asyncio.sleep(1)

    # The value of &quot;var&quot; is inherited from main(), but any
    # changes to &quot;var&quot; made in main() after the task
    # was created are *not* visible.
    assert var.get() == 'main'

    # This change is local to sub() and will not be visible
    # to other tasks, including main().
    var.set('sub')

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</pre>
<p>As shown above, changes to the execution context are local to the
task, and tasks get a snapshot of the execution context at the point
of creation.</p>
<p>There is one narrow edge case when this can lead to surprising
behaviour.  Consider the following example where we modify the
context variable in a nested coroutine:</p>
<pre class="literal-block">
async def sub(var_value):
    await asyncio.sleep(1)
    var.set(var_value)

async def main():
    var.set('main')

    # waiting for sub() directly
    await sub('sub-1')

    # var change is visible
    assert var.get() == 'sub-1'

    # waiting for sub() with a timeout;
    await asyncio.wait_for(sub('sub-2'), timeout=2)

    # wait_for() creates an implicit task, which isolates
    # context changes, which means that the below assertion
    # will fail.
    assert var.get() == 'sub-2'  #  AssertionError!
</pre>
<p>However, relying on context changes leaking to the caller is
ultimately a bad pattern.  For this reason, the behaviour shown in
the above example is not considered a major issue and can be
addressed with proper documentation.</p>
</div>
</div>
<div class="section" id="detailed-specification">
<h1><a class="toc-backref" href="#id71">Detailed Specification</a></h1>
<p>Conceptually, an <em>execution context</em> (EC) is a stack of logical
contexts.  There is always exactly one active EC per Python thread.</p>
<p>A <em>logical context</em> (LC) is a mapping of context variables to their
values in that particular LC.</p>
<p>A <em>context variable</em> is an object representing a value in the
execution context.  A new context variable object is created by
calling <tt class="docutils literal">contextvars.ContextVar(name: str)</tt>.  The value of the
required <tt class="docutils literal">name</tt> argument is not used by the EC machinery, but may
be used for debugging and introspection.</p>
<p>The context variable object has the following methods and attributes:</p>
<ul class="simple">
<li><tt class="docutils literal">name</tt>: the value passed to <tt class="docutils literal">ContextVar()</tt>.</li>
<li><tt class="docutils literal"><span class="pre">get(*,</span> topmost=False, default=None)</tt>, if <em>topmost</em> is <tt class="docutils literal">False</tt>
(the default), traverses the execution context top-to-bottom, until
the variable value is found.  If <em>topmost</em> is <tt class="docutils literal">True</tt>, returns
the value of the variable in the topmost logical context.
If the variable value was not found, returns the value of <em>default</em>.</li>
<li><tt class="docutils literal">set(value)</tt>: sets the value of the variable in the topmost
logical context.</li>
<li><tt class="docutils literal">delete()</tt>: removes the variable from the topmost logical context.
Useful when restoring the logical context to the state prior to the
<tt class="docutils literal">set()</tt> call, for example, in a context manager, see
<a class="reference internal" href="#setting-and-restoring-context-variables">Setting and restoring context variables</a> for more information.</li>
</ul>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id72">Generators</a></h2>
<p>When created, each generator object has an empty logical context
object stored in its <tt class="docutils literal">__logical_context__</tt> attribute.  This logical
context is pushed onto the execution context at the beginning of each
generator iteration and popped at the end:</p>
<pre class="literal-block">
var1 = contextvars.ContextVar('var1')
var2 = contextvars.ContextVar('var2')

def gen():
    var1.set('var1-gen')
    var2.set('var2-gen')

    # EC = [
    #     outer_LC(),
    #     gen_LC({var1: 'var1-gen', var2: 'var2-gen'})
    # ]
    n = nested_gen()  # nested_gen_LC is created
    next(n)
    # EC = [
    #     outer_LC(),
    #     gen_LC({var1: 'var1-gen', var2: 'var2-gen'})
    # ]

    var1.set('var1-gen-mod')
    var2.set('var2-gen-mod')
    # EC = [
    #     outer_LC(),
    #     gen_LC({var1: 'var1-gen-mod', var2: 'var2-gen-mod'})
    # ]
    next(n)

def nested_gen():
    # EC = [
    #     outer_LC(),
    #     gen_LC({var1: 'var1-gen', var2: 'var2-gen'}),
    #     nested_gen_LC()
    # ]
    assert var1.get() == 'var1-gen'
    assert var2.get() == 'var2-gen'

    var1.set('var1-nested-gen')
    # EC = [
    #     outer_LC(),
    #     gen_LC({var1: 'var1-gen', var2: 'var2-gen'}),
    #     nested_gen_LC({var1: 'var1-nested-gen'})
    # ]
    yield

    # EC = [
    #     outer_LC(),
    #     gen_LC({var1: 'var1-gen-mod', var2: 'var2-gen-mod'}),
    #     nested_gen_LC({var1: 'var1-nested-gen'})
    # ]
    assert var1.get() == 'var1-nested-gen'
    assert var2.get() == 'var2-gen-mod'

    yield

# EC = [outer_LC()]

g = gen()  # gen_LC is created for the generator object `g`
list(g)

# EC = [outer_LC()]
</pre>
<p>The snippet above shows the state of the execution context stack
throughout the generator lifespan.</p>
</div>
<div class="section" id="contextlib-contextmanager">
<h2><a class="toc-backref" href="#id73">contextlib.contextmanager</a></h2>
<p>The <tt class="docutils literal">contextlib.contextmanager()</tt> decorator can be used to turn
a generator into a context manager.  A context manager that
temporarily modifies the value of a context variable could be defined
like this:</p>
<pre class="literal-block">
var = contextvars.ContextVar('var')

&#64;contextlib.contextmanager
def var_context(value):
    original_value = var.get()

    try:
        var.set(value)
        yield
    finally:
        var.set(original_value)
</pre>
<p>Unfortunately, this would not work straight away, as the modification
to the <tt class="docutils literal">var</tt> variable is contained to the <tt class="docutils literal">var_context()</tt>
generator, and therefore will not be visible inside the <tt class="docutils literal">with</tt>
block:</p>
<pre class="literal-block">
def func():
    # EC = [{}, {}]

    with var_context(10):
        # EC becomes [{}, {}, {var: 10}] in the
        # *precision_context()* generator,
        # but here the EC is still [{}, {}]

        assert var.get() == 10  # AssertionError!
</pre>
<p>The way to fix this is to set the generator's <tt class="docutils literal">__logical_context__</tt>
attribute to <tt class="docutils literal">None</tt>.  This will cause the generator to avoid
modifying the execution context stack.</p>
<p>We modify the <tt class="docutils literal">contextlib.contextmanager()</tt> decorator to
set <tt class="docutils literal">genobj.__logical_context__</tt> to <tt class="docutils literal">None</tt> to produce
well-behaved context managers:</p>
<pre class="literal-block">
def func():
    # EC = [{}, {}]

    with var_context(10):
        # EC = [{}, {var: 10}]
        assert var.get() == 10

    # EC becomes [{}, {var: None}]
</pre>
</div>
<div class="section" id="enumerating-context-vars">
<h2><a class="toc-backref" href="#id74">Enumerating context vars</a></h2>
<p>The <tt class="docutils literal">ExecutionContext.vars()</tt> method returns a list of
<tt class="docutils literal">ContextVar</tt> objects, that have values in the execution context.
This method is mostly useful for introspection and logging.</p>
</div>
<div class="section" id="coroutines">
<h2><a class="toc-backref" href="#id75">coroutines</a></h2>
<p>In CPython, coroutines share the implementation with generators.
The difference is that in coroutines <tt class="docutils literal">__logical_context__</tt> defaults
to <tt class="docutils literal">None</tt>.  This affects both the <tt class="docutils literal">async def</tt> coroutines and the
old-style generator-based coroutines (generators decorated with
<tt class="docutils literal">&#64;types.coroutine</tt>).</p>
</div>
<div class="section" id="asynchronous-generators">
<h2><a class="toc-backref" href="#id76">Asynchronous Generators</a></h2>
<p>The execution context semantics in asynchronous generators does not
differ from that of regular generators.</p>
</div>
<div class="section" id="asyncio">
<h2><a class="toc-backref" href="#id77">asyncio</a></h2>
<p><tt class="docutils literal">asyncio</tt> uses <tt class="docutils literal">Loop.call_soon</tt>, <tt class="docutils literal">Loop.call_later</tt>,
and <tt class="docutils literal">Loop.call_at</tt> to schedule the asynchronous execution of a
function.  <tt class="docutils literal">asyncio.Task</tt> uses <tt class="docutils literal">call_soon()</tt> to run the
wrapped coroutine.</p>
<p>We modify <tt class="docutils literal">Loop.call_{at,later,soon}</tt> to accept the new
optional <em>execution_context</em> keyword argument, which defaults to
the copy of the current execution context:</p>
<pre class="literal-block">
def call_soon(self, callback, *args, execution_context=None):
    if execution_context is None:
        execution_context = contextvars.get_execution_context()

    # ... some time later

    contextvars.run_with_execution_context(
        execution_context, callback, args)
</pre>
<p>The <tt class="docutils literal">contextvars.get_execution_context()</tt> function returns a
shallow copy of the current execution context.  By shallow copy here
we mean such a new execution context that:</p>
<ul class="simple">
<li>lookups in the copy provide the same results as in the original
execution context, and</li>
<li>any changes in the original execution context do not affect the
copy, and</li>
<li>any changes to the copy do not affect the original execution
context.</li>
</ul>
<p>Either of the following satisfy the copy requirements:</p>
<ul class="simple">
<li>a new stack with shallow copies of logical contexts;</li>
<li>a new stack with one squashed logical context.</li>
</ul>
<p>The <tt class="docutils literal">contextvars.run_with_execution_context(ec, func, *args,
**kwargs)</tt> function runs <tt class="docutils literal"><span class="pre">func(*args,</span> **kwargs)</tt> with <em>ec</em> as the
execution context.  The function performs the following steps:</p>
<ol class="arabic simple">
<li>Set <em>ec</em> as the current execution context stack in the current
thread.</li>
<li>Push an empty logical context onto the stack.</li>
<li>Run <tt class="docutils literal"><span class="pre">func(*args,</span> **kwargs)</tt>.</li>
<li>Pop the logical context from the stack.</li>
<li>Restore the original execution context stack.</li>
<li>Return or raise the <tt class="docutils literal">func()</tt> result.</li>
</ol>
<p>These steps ensure that <em>ec</em> cannot be modified by <em>func</em>,
which makes <tt class="docutils literal">run_with_execution_context()</tt> idempotent.</p>
<p><tt class="docutils literal">asyncio.Task</tt> is modified as follows:</p>
<pre class="literal-block">
class Task:
    def __init__(self, coro):
        ...
        # Get the current execution context snapshot.
        self._exec_context = contextvars.get_execution_context()

        # Create an empty Logical Context that will be
        # used by coroutines run in the task.
        coro.__logical_context__ = contextvars.LogicalContext()

        self._loop.call_soon(
            self._step,
            execution_context=self._exec_context)

    def _step(self, exc=None):
        ...
        self._loop.call_soon(
            self._step,
            execution_context=self._exec_context)
        ...
</pre>
</div>
<div class="section" id="generators-transformed-into-iterators">
<h2><a class="toc-backref" href="#id78">Generators Transformed into Iterators</a></h2>
<p>Any Python generator can be represented as an equivalent iterator.
Compilers like Cython rely on this axiom.  With respect to the
execution context, such iterator should behave the same way as the
generator it represents.</p>
<p>This means that there needs to be a Python API to create new logical
contexts and run code with a given logical context.</p>
<p>The <tt class="docutils literal">contextvars.LogicalContext()</tt> function creates a new empty
logical context.</p>
<p>The <tt class="docutils literal">contextvars.run_with_logical_context(lc, func, *args,
**kwargs)</tt> function can be used to run functions in the specified
logical context.  The <em>lc</em> can be modified as a result of the call.</p>
<p>The <tt class="docutils literal">contextvars.run_with_logical_context()</tt> function performs the
following steps:</p>
<ol class="arabic simple">
<li>Push <em>lc</em> onto the current execution context stack.</li>
<li>Run <tt class="docutils literal"><span class="pre">func(*args,</span> **kwargs)</tt>.</li>
<li>Pop <em>lc</em> from the execution context stack.</li>
<li>Return or raise the <tt class="docutils literal">func()</tt> result.</li>
</ol>
<p>By using <tt class="docutils literal">LogicalContext()</tt> and <tt class="docutils literal">run_with_logical_context()</tt>,
we can replicate the generator behaviour like this:</p>
<pre class="literal-block">
class Generator:

    def __init__(self):
        self.logical_context = contextvars.LogicalContext()

    def __iter__(self):
        return self

    def __next__(self):
        return contextvars.run_with_logical_context(
            self.logical_context, self._next_impl)

    def _next_impl(self):
        # Actual __next__ implementation.
        ...
</pre>
<p>Let's see how this pattern can be applied to an example generator:</p>
<pre class="literal-block">
# create a new context variable
var = contextvars.ContextVar('var')

def gen_series(n):
    var.set(10)

    for i in range(1, n):
        yield var.get() * i

# gen_series is equivalent to the following iterator:

class CompiledGenSeries:

    # This class is what the `gen_series()` generator can
    # be transformed to by a compiler like Cython.

    def __init__(self, n):
        # Create a new empty logical context,
        # like the generators do.
        self.logical_context = contextvars.LogicalContext()

        # Initialize the generator in its LC.
        # Otherwise `var.set(10)` in the `_init` method
        # would leak.
        contextvars.run_with_logical_context(
            self.logical_context, self._init, n)

    def _init(self, n):
        self.i = 1
        self.n = n
        var.set(10)

    def __iter__(self):
        return self

    def __next__(self):
        # Run the actual implementation of __next__ in our LC.
        return contextvars.run_with_logical_context(
            self.logical_context, self._next_impl)

    def _next_impl(self):
        if self.i == self.n:
            raise StopIteration

        result = var.get() * self.i
        self.i += 1
        return result
</pre>
<p>For hand-written iterators such approach to context management is
normally not necessary, and it is easier to set and restore
context variables directly in <tt class="docutils literal">__next__</tt>:</p>
<pre class="literal-block">
class MyIterator:

    # ...

    def __next__(self):
        old_val = var.get()
        try:
            var.set(new_val)
            # ...
        finally:
            var.set(old_val)
</pre>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id79">Implementation</a></h1>
<p>Execution context is implemented as an immutable linked list of
logical contexts, where each logical context is an immutable weak key
mapping.  A pointer to the currently active execution context is
stored in the OS thread state:</p>
<pre class="literal-block">
                  +-----------------+
                  |                 |     ec
                  |  PyThreadState  +-------------+
                  |                 |             |
                  +-----------------+             |
                                                  |
ec_node             ec_node             ec_node   v
+------+------+     +------+------+     +------+------+
| NULL |  lc  |&lt;----| prev |  lc  |&lt;----| prev |  lc  |
+------+--+---+     +------+--+---+     +------+--+---+
          |                   |                   |
LC        v         LC        v         LC        v
+-------------+     +-------------+     +-------------+
| var1: obj1  |     |    EMPTY    |     | var1: obj4  |
| var2: obj2  |     +-------------+     +-------------+
| var3: obj3  |
+-------------+
</pre>
<p>The choice of the immutable list of immutable mappings as a
fundamental data structure is motivated by the need to efficiently
implement <tt class="docutils literal">contextvars.get_execution_context()</tt>, which is to be
frequently used by asynchronous tasks and callbacks.  When the EC is
immutable, <tt class="docutils literal">get_execution_context()</tt> can simply copy the current
execution context <em>by reference</em>:</p>
<pre class="literal-block">
def get_execution_context(self):
    return PyThreadState_Get().ec
</pre>
<p>Let's review all possible context modification scenarios:</p>
<ul>
<li><p class="first">The <tt class="docutils literal">ContextVariable.set()</tt> method is called:</p>
<pre class="literal-block">
def ContextVar_set(self, val):
    # See a more complete set() definition
    # in the `Context Variables` section.

    tstate = PyThreadState_Get()
    top_ec_node = tstate.ec
    top_lc = top_ec_node.lc
    new_top_lc = top_lc.set(self, val)
    tstate.ec = ec_node(
        prev=top_ec_node.prev,
        lc=new_top_lc)
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">contextvars.run_with_logical_context()</tt> is called, in which
case the passed logical context object is appended to the execution
context:</p>
<pre class="literal-block">
def run_with_logical_context(lc, func, *args, **kwargs):
    tstate = PyThreadState_Get()

    old_top_ec_node = tstate.ec
    new_top_ec_node = ec_node(prev=old_top_ec_node, lc=lc)

    try:
        tstate.ec = new_top_ec_node
        return func(*args, **kwargs)
    finally:
        tstate.ec = old_top_ec_node
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">contextvars.run_with_execution_context()</tt> is called, in which
case the current execution context is set to the passed execution
context with a new empty logical context appended to it:</p>
<pre class="literal-block">
def run_with_execution_context(ec, func, *args, **kwargs):
    tstate = PyThreadState_Get()

    old_top_ec_node = tstate.ec
    new_lc = contextvars.LogicalContext()
    new_top_ec_node = ec_node(prev=ec, lc=new_lc)

    try:
        tstate.ec = new_top_ec_node
        return func(*args, **kwargs)
    finally:
        tstate.ec = old_top_ec_node
</pre>
</li>
<li><p class="first">Either <tt class="docutils literal">genobj.send()</tt>, <tt class="docutils literal">genobj.throw()</tt>, <tt class="docutils literal">genobj.close()</tt>
are called on a <tt class="docutils literal">genobj</tt> generator, in which case the logical
context recorded in <tt class="docutils literal">genobj</tt> is pushed onto the stack:</p>
<pre class="literal-block">
PyGen_New(PyGenObject *gen):
    if (gen.gi_code.co_flags &amp;
            (CO_COROUTINE | CO_ITERABLE_COROUTINE)):
        # gen is an 'async def' coroutine, or a generator
        # decorated with &#64;types.coroutine.
        gen.__logical_context__ = None
    else:
        # Non-coroutine generator
        gen.__logical_context__ = contextvars.LogicalContext()

gen_send(PyGenObject *gen, ...):
    tstate = PyThreadState_Get()

    if gen.__logical_context__ is not None:
        old_top_ec_node = tstate.ec
        new_top_ec_node = ec_node(
            prev=old_top_ec_node,
            lc=gen.__logical_context__)

        try:
            tstate.ec = new_top_ec_node
            return _gen_send_impl(gen, ...)
        finally:
            gen.__logical_context__ = tstate.ec.lc
            tstate.ec = old_top_ec_node
    else:
        return _gen_send_impl(gen, ...)
</pre>
</li>
<li><p class="first">Coroutines and asynchronous generators share the implementation
with generators, and the above changes apply to them as well.</p>
</li>
</ul>
<p>In certain scenarios the EC may need to be squashed to limit the
size of the chain.  For example, consider the following corner case:</p>
<pre class="literal-block">
async def repeat(coro, delay):
    await coro()
    await asyncio.sleep(delay)
    loop.create_task(repeat(coro, delay))

async def ping():
    print('ping')

loop = asyncio.get_event_loop()
loop.create_task(repeat(ping, 1))
loop.run_forever()
</pre>
<p>In the above code, the EC chain will grow as long as <tt class="docutils literal">repeat()</tt> is
called. Each new task will call
<tt class="docutils literal">contextvars.run_with_execution_context()</tt>, which will append a new
logical context to the chain.  To prevent unbounded growth,
<tt class="docutils literal">contextvars.get_execution_context()</tt> checks if the chain
is longer than a predetermined maximum, and if it is, squashes the
chain into a single LC:</p>
<pre class="literal-block">
def get_execution_context():
    tstate = PyThreadState_Get()

    if tstate.ec_len &gt; EC_LEN_MAX:
        squashed_lc = contextvars.LogicalContext()

        ec_node = tstate.ec
        while ec_node:
            # The LC.merge() method does not replace
            # existing keys.
            squashed_lc = squashed_lc.merge(ec_node.lc)
            ec_node = ec_node.prev

        return ec_node(prev=NULL, lc=squashed_lc)
    else:
        return tstate.ec
</pre>
<div class="section" id="logical-context">
<h2><a class="toc-backref" href="#id80">Logical Context</a></h2>
<p>Logical context is an immutable weak key mapping which has the
following properties with respect to garbage collection:</p>
<ul class="simple">
<li><tt class="docutils literal">ContextVar</tt> objects are strongly-referenced only from the
application code, not from any of the execution context machinery
or values they point to.  This means that there are no reference
cycles that could extend their lifespan longer than necessary, or
prevent their collection by the GC.</li>
<li>Values put in the execution context are guaranteed to be kept
alive while there is a <tt class="docutils literal">ContextVar</tt> key referencing them in
the thread.</li>
<li>If a <tt class="docutils literal">ContextVar</tt> is garbage collected, all of its values will
be removed from all contexts, allowing them to be GCed if needed.</li>
<li>If an OS thread has ended its execution, its thread state will be
cleaned up along with its execution context, cleaning
up all values bound to all context variables in the thread.</li>
</ul>
<p>As discussed earlier, we need <tt class="docutils literal">contextvars.get_execution_context()</tt>
to be consistently fast regardless of the size of the execution
context, so logical context is necessarily an immutable mapping.</p>
<p>Choosing <tt class="docutils literal">dict</tt> for the underlying implementation is suboptimal,
because <tt class="docutils literal">LC.set()</tt> will cause <tt class="docutils literal">dict.copy()</tt>, which is an O(N)
operation, where <em>N</em> is the number of items in the LC.</p>
<p><tt class="docutils literal">get_execution_context()</tt>, when squashing the EC, is an O(M)
operation, where <em>M</em> is the total number of context variable values
in the EC.</p>
<p>So, instead of <tt class="docutils literal">dict</tt>, we choose Hash Array Mapped Trie (HAMT)
as the underlying implementation of logical contexts.  (Scala and
Clojure use HAMT to implement high performance immutable collections
<a class="footnote-reference" href="#id33" id="id6">[5]</a>, <a class="footnote-reference" href="#id34" id="id7">[6]</a>.)</p>
<p>With HAMT <tt class="docutils literal">.set()</tt> becomes an O(log N) operation, and
<tt class="docutils literal">get_execution_context()</tt> squashing is more efficient on average due
to structural sharing in HAMT.</p>
<p>See <a class="reference internal" href="#appendix-hamt-performance-analysis">Appendix: HAMT Performance Analysis</a> for a more elaborate
analysis of HAMT performance compared to <tt class="docutils literal">dict</tt>.</p>
</div>
<div class="section" id="context-variables">
<h2><a class="toc-backref" href="#id81">Context Variables</a></h2>
<p>The <tt class="docutils literal">ContextVar.get()</tt> and <tt class="docutils literal">ContextVar.set()</tt> methods are
implemented as follows (in pseudo-code):</p>
<pre class="literal-block">
class ContextVar:

    def get(self, *, default=None, topmost=False):
        tstate = PyThreadState_Get()

        ec_node = tstate.ec
        while ec_node:
            if self in ec_node.lc:
                return ec_node.lc[self]
            if topmost:
                break
            ec_node = ec_node.prev

        return default

    def set(self, value):
        tstate = PyThreadState_Get()
        top_ec_node = tstate.ec

        if top_ec_node is not None:
            top_lc = top_ec_node.lc
            new_top_lc = top_lc.set(self, value)
            tstate.ec = ec_node(
                prev=top_ec_node.prev,
                lc=new_top_lc)
        else:
            # First ContextVar.set() in this OS thread.
            top_lc = contextvars.LogicalContext()
            new_top_lc = top_lc.set(self, value)
            tstate.ec = ec_node(
                prev=NULL,
                lc=new_top_lc)

    def delete(self):
        tstate = PyThreadState_Get()
        top_ec_node = tstate.ec

        if top_ec_node is None:
            raise LookupError

        top_lc = top_ec_node.lc
        if self not in top_lc:
            raise LookupError

        new_top_lc = top_lc.delete(self)

        tstate.ec = ec_node(
            prev=top_ec_node.prev,
            lc=new_top_lc)
</pre>
<p>For efficient access in performance-sensitive code paths, such as in
<tt class="docutils literal">numpy</tt> and <tt class="docutils literal">decimal</tt>, we cache lookups in <tt class="docutils literal">ContextVar.get()</tt>,
making it an O(1) operation when the cache is hit.  The cache key is
composed from the following:</p>
<ul class="simple">
<li>The new <tt class="docutils literal">uint64_t <span class="pre">PyThreadState-&gt;unique_id</span></tt>, which is a globally
unique thread state identifier.  It is computed from the new
<tt class="docutils literal">uint64_t <span class="pre">PyInterpreterState-&gt;ts_counter</span></tt>, which is incremented
whenever a new thread state is created.</li>
<li>The new <tt class="docutils literal">uint64_t <span class="pre">PyThreadState-&gt;stack_version</span></tt>, which is a
thread-specific counter, which is incremented whenever a non-empty
logical context is pushed onto the stack or popped from the stack.</li>
<li>The <tt class="docutils literal">uint64_t <span class="pre">ContextVar-&gt;version</span></tt> counter, which is incremented
whenever the context variable value is changed in any logical
context in any OS thread.</li>
</ul>
<p>The cache is then implemented as follows:</p>
<pre class="literal-block">
class ContextVar:

    def set(self, value):
        ...  # implementation
        self.version += 1

    def get(self, *, default=None, topmost=False):
        if topmost:
            return self._get_uncached(
                default=default, topmost=topmost)

        tstate = PyThreadState_Get()
        if (self.last_tstate_id == tstate.unique_id and
                self.last_stack_ver == tstate.stack_version and
                self.last_version == self.version):
            return self.last_value

        value = self._get_uncached(default=default)

        self.last_value = value  # borrowed ref
        self.last_tstate_id = tstate.unique_id
        self.last_stack_version = tstate.stack_version
        self.last_version = self.version

        return value
</pre>
<p>Note that <tt class="docutils literal">last_value</tt> is a borrowed reference.  We assume that
if the version checks are fine, the value object will be alive.
This allows the values of context variables to be properly garbage
collected.</p>
<p>This generic caching approach is similar to what the current C
implementation of <tt class="docutils literal">decimal</tt> does to cache the the current decimal
context, and has similar performance characteristics.</p>
</div>
</div>
<div class="section" id="performance-considerations">
<h1><a class="toc-backref" href="#id82">Performance Considerations</a></h1>
<p>Tests of the reference implementation based on the prior
revisions of this PEP have shown 1-2% slowdown on generator
microbenchmarks and no noticeable difference in macrobenchmarks.</p>
<p>The performance of non-generator and non-async code is not
affected by this PEP.</p>
</div>
<div class="section" id="summary-of-the-new-apis">
<h1><a class="toc-backref" href="#id83">Summary of the New APIs</a></h1>
<div class="section" id="python">
<h2><a class="toc-backref" href="#id84">Python</a></h2>
<p>The following new Python APIs are introduced by this PEP:</p>
<ol class="arabic simple">
<li>The new <tt class="docutils literal">contextvars.ContextVar(name: <span class="pre">str='...')</span></tt> class,
instances of which have the following:<ul>
<li>the read-only <tt class="docutils literal">.name</tt> attribute,</li>
<li>the <tt class="docutils literal">.get()</tt> method, which returns the value of the variable
in the current execution context;</li>
<li>the <tt class="docutils literal">.set()</tt> method, which sets the value of the variable in
the current logical context;</li>
<li>the <tt class="docutils literal">.delete()</tt> method, which removes the value of the variable
from the current logical context.</li>
</ul>
</li>
<li>The new <tt class="docutils literal">contextvars.ExecutionContext()</tt> class, which represents
an execution context.</li>
<li>The new <tt class="docutils literal">contextvars.LogicalContext()</tt> class, which represents
a logical context.</li>
<li>The new <tt class="docutils literal">contextvars.get_execution_context()</tt> function, which
returns an <tt class="docutils literal">ExecutionContext</tt> instance representing a copy of
the current execution context.</li>
<li>The <tt class="docutils literal">contextvars.run_with_execution_context(ec: ExecutionContext,
func, *args, **kwargs)</tt> function, which runs <em>func</em> with the
provided execution context.</li>
<li>The <tt class="docutils literal">contextvars.run_with_logical_context(lc: LogicalContext,
func, *args, **kwargs)</tt> function, which runs <em>func</em> with the
provided logical context on top of the current execution context.</li>
</ol>
</div>
<div class="section" id="c-api">
<h2><a class="toc-backref" href="#id85">C API</a></h2>
<ol class="arabic simple">
<li><tt class="docutils literal">PyContextVar * PyContext_NewVar(char *desc)</tt>: create a
<tt class="docutils literal">PyContextVar</tt> object.</li>
<li><tt class="docutils literal">PyObject * PyContext_GetValue(PyContextVar *, int topmost)</tt>:
return the value of the variable in the current execution context.</li>
<li><tt class="docutils literal">int PyContext_SetValue(PyContextVar *, PyObject *)</tt>: set
the value of the variable in the current logical context.</li>
<li><tt class="docutils literal">int PyContext_DelValue(PyContextVar *)</tt>: delete the value of
the variable from the current logical context.</li>
<li><tt class="docutils literal">PyLogicalContext * PyLogicalContext_New()</tt>: create a new empty
<tt class="docutils literal">PyLogicalContext</tt>.</li>
<li><tt class="docutils literal">PyExecutionContext * PyExecutionContext_New()</tt>: create a new
empty <tt class="docutils literal">PyExecutionContext</tt>.</li>
<li><tt class="docutils literal">PyExecutionContext * PyExecutionContext_Get()</tt>: return the
current execution context.</li>
<li><tt class="docutils literal">int PyContext_SetCurrent(
PyExecutionContext *, PyLogicalContext *)</tt>: set the
passed EC object as the current execution context for the active
thread state, and/or set the passed LC object as the current
logical context.</li>
</ol>
</div>
</div>
<div class="section" id="design-considerations">
<h1><a class="toc-backref" href="#id86">Design Considerations</a></h1>
<div class="section" id="should-yield-from-leak-context-changes">
<h2><a class="toc-backref" href="#id87">Should &quot;yield from&quot; leak context changes?</a></h2>
<p>No.  It may be argued that <tt class="docutils literal">yield from</tt> is semantically
equivalent to calling a function, and should leak context changes.
However, it is not possible to satisfy the following at the same time:</p>
<ul class="simple">
<li><tt class="docutils literal">next(gen)</tt> <em>does not</em> leak context changes made in <tt class="docutils literal">gen</tt>, and</li>
<li><tt class="docutils literal">yield from gen</tt> <em>leaks</em> context changes made in <tt class="docutils literal">gen</tt>.</li>
</ul>
<p>The reason is that <tt class="docutils literal">yield from</tt> can be used with a partially
iterated generator, which already has local context changes:</p>
<pre class="literal-block">
var = contextvars.ContextVar('var')

def gen():
    for i in range(10):
        var.set('gen')
        yield i

def outer_gen():
    var.set('outer_gen')
    g = gen()

    yield next(g)
    # Changes not visible during partial iteration,
    # the goal of this PEP:
    assert var.get() == 'outer_gen'

    yield from g
    assert var.get() == 'outer_gen'  # or 'gen'?
</pre>
<p>Another example would be refactoring of an explicit <tt class="docutils literal"><span class="pre">for..in</span> yield</tt>
construct to a <tt class="docutils literal">yield from</tt> expression.  Consider the following
code:</p>
<pre class="literal-block">
def outer_gen():
    var.set('outer_gen')

    for i in gen():
        yield i
    assert var.get() == 'outer_gen'
</pre>
<p>which we want to refactor to use <tt class="docutils literal">yield from</tt>:</p>
<pre class="literal-block">
def outer_gen():
    var.set('outer_gen')

    yield from gen()
    assert var.get() == 'outer_gen'  # or 'gen'?
</pre>
<p>The above examples illustrate that it is unsafe to refactor
generator code using <tt class="docutils literal">yield from</tt> when it can leak context changes.</p>
<p>Thus, the only well-defined and consistent behaviour is to
<strong>always</strong> isolate context changes in generators, regardless of
how they are being iterated.</p>
</div>
<div class="section" id="should-pythreadstate-getdict-use-the-execution-context">
<h2><a class="toc-backref" href="#id88">Should <tt class="docutils literal">PyThreadState_GetDict()</tt> use the execution context?</a></h2>
<p>No. <tt class="docutils literal">PyThreadState_GetDict</tt> is based on TLS, and changing its
semantics will break backwards compatibility.</p>
</div>
<div class="section" id="pep-521">
<h2><a class="reference external" href="/dev/peps/pep-0521">PEP 521</a></h2>
<p><a class="reference external" href="/dev/peps/pep-0521">PEP 521</a> proposes an alternative solution to the problem, which
extends the context manager protocol with two new methods:
<tt class="docutils literal">__suspend__()</tt> and <tt class="docutils literal">__resume__()</tt>.  Similarly, the asynchronous
context manager protocol is also extended with <tt class="docutils literal">__asuspend__()</tt> and
<tt class="docutils literal">__aresume__()</tt>.</p>
<p>This allows implementing context managers that manage non-local state,
which behave correctly in generators and coroutines.</p>
<p>For example, consider the following context manager, which uses
execution state:</p>
<pre class="literal-block">
class Context:

    def __init__(self):
        self.var = contextvars.ContextVar('var')

    def __enter__(self):
        self.old_x = self.var.get()
        self.var.set('something')

    def __exit__(self, *err):
        self.var.set(self.old_x)
</pre>
<p>An equivalent implementation with <a class="reference external" href="/dev/peps/pep-0521">PEP 521</a>:</p>
<pre class="literal-block">
local = threading.local()

class Context:

    def __enter__(self):
        self.old_x = getattr(local, 'x', None)
        local.x = 'something'

    def __suspend__(self):
        local.x = self.old_x

    def __resume__(self):
        local.x = 'something'

    def __exit__(self, *err):
        local.x = self.old_x
</pre>
<p>The downside of this approach is the addition of significant new
complexity to the context manager protocol and the interpreter
implementation.  This approach is also likely to negatively impact
the performance of generators and coroutines.</p>
<p>Additionally, the solution in <a class="reference external" href="/dev/peps/pep-0521">PEP 521</a> is limited to context
managers, and does not provide any mechanism to propagate state in
asynchronous tasks and callbacks.</p>
</div>
<div class="section" id="can-execution-context-be-implemented-without-modifying-cpython">
<h2><a class="toc-backref" href="#id90">Can Execution Context be implemented without modifying CPython?</a></h2>
<p>No.</p>
<p>It is true that the concept of &quot;task-locals&quot; can be implemented
for coroutines in libraries (see, for example, <a class="footnote-reference" href="#id57" id="id8">[29]</a> and <a class="footnote-reference" href="#id58" id="id9">[30]</a>).
On the other hand, generators are managed by the Python interpreter
directly, and so their context must also be managed by the
interpreter.</p>
<p>Furthermore, execution context cannot be implemented in a third-party
module at all, otherwise the standard library, including <tt class="docutils literal">decimal</tt>
would not be able to rely on it.</p>
</div>
<div class="section" id="should-we-update-sys-displayhook-and-other-apis-to-use-ec">
<h2><a class="toc-backref" href="#id91">Should we update sys.displayhook and other APIs to use EC?</a></h2>
<p>APIs like redirecting stdout by overwriting <tt class="docutils literal">sys.stdout</tt>, or
specifying new exception display hooks by overwriting the
<tt class="docutils literal">sys.displayhook</tt> function are affecting the whole Python process
<strong>by design</strong>.  Their users assume that the effect of changing
them will be visible across OS threads.  Therefore we cannot
just make these APIs to use the new Execution Context.</p>
<p>That said we think it is possible to design new APIs that will
be context aware, but that is outside of the scope of this PEP.</p>
</div>
<div class="section" id="greenlets">
<h2><a class="toc-backref" href="#id92">Greenlets</a></h2>
<p>Greenlet is an alternative implementation of cooperative
scheduling for Python.  Although greenlet package is not part of
CPython, popular frameworks like gevent rely on it, and it is
important that greenlet can be modified to support execution
contexts.</p>
<p>Conceptually, the behaviour of greenlets is very similar to that of
generators, which means that similar changes around greenlet entry
and exit can be done to add support for execution context.  This
PEP provides the necessary C APIs to do that.</p>
</div>
<div class="section" id="context-manager-as-the-interface-for-modifications">
<h2><a class="toc-backref" href="#id93">Context manager as the interface for modifications</a></h2>
<p>This PEP concentrates on the low-level mechanics and the minimal
API that enables fundamental operations with execution context.</p>
<p>For developer convenience, a high-level context manager interface
may be added to the <tt class="docutils literal">contextvars</tt> module.  For example:</p>
<pre class="literal-block">
with contextvars.set_var(var, 'foo'):
    # ...
</pre>
</div>
<div class="section" id="setting-and-restoring-context-variables">
<h2><a class="toc-backref" href="#id94">Setting and restoring context variables</a></h2>
<p>The <tt class="docutils literal">ContextVar.delete()</tt> method removes the context variable from
the topmost logical context.</p>
<p>If the variable is not found in the topmost logical context, a
<tt class="docutils literal">LookupError</tt> is raised, similarly to <tt class="docutils literal">del var</tt> raising
<tt class="docutils literal">NameError</tt> when <tt class="docutils literal">var</tt> is not in scope.</p>
<p>This method is useful when there is a (rare) need to correctly restore
the state of a logical context, such as when a nested generator
wants to modify the logical context <em>temporarily</em>:</p>
<pre class="literal-block">
var = contextvars.ContextVar('var')

def gen():
    with some_var_context_manager('gen'):
        # EC = [{var: 'main'}, {var: 'gen'}]
        assert var.get() == 'gen'
        yield

    # EC = [{var: 'main modified'}, {}]
    assert var.get() == 'main modified'
    yield

def main():
    var.set('main')
    g = gen()
    next(g)
    var.set('main modified')
    next(g)
</pre>
<p>The above example would work correctly only if there is a way to
delete <tt class="docutils literal">var</tt> from the logical context in <tt class="docutils literal">gen()</tt>.  Setting it
to a &quot;previous value&quot; in <tt class="docutils literal">__exit__()</tt> would mask changes made
in <tt class="docutils literal">main()</tt> between the iterations.</p>
</div>
<div class="section" id="alternative-designs-for-contextvar-api">
<h2><a class="toc-backref" href="#id95">Alternative Designs for ContextVar API</a></h2>
<div class="section" id="logical-context-with-stacked-values">
<h3><a class="toc-backref" href="#id96">Logical Context with stacked values</a></h3>
<p>By the design presented in this PEP, logical context is a simple
<tt class="docutils literal"><span class="pre">LC({ContextVar:</span> value, <span class="pre">...})</span></tt> mapping.  An alternative
representation is to store a stack of values for each context
variable: <tt class="docutils literal"><span class="pre">LC({ContextVar:</span> [val1, val2, <span class="pre">...],</span> <span class="pre">...})</span></tt>.</p>
<p>The <tt class="docutils literal">ContextVar</tt> methods would then be:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">get(*,</span> default=None)</tt> -- traverses the stack
of logical contexts, and returns the top value from the
first non-empty logical context;</li>
<li><tt class="docutils literal">push(val)</tt> -- pushes <em>val</em> onto the stack of values in the
current logical context;</li>
<li><tt class="docutils literal">pop()</tt> -- pops the top value from the stack of values in
the current logical context.</li>
</ul>
<p>Compared to the single-value design with the <tt class="docutils literal">set()</tt> and
<tt class="docutils literal">delete()</tt> methods, the stack-based approach allows for a simpler
implementation of the set/restore pattern.  However, the mental
burden of this approach is considered to be higher, since there
would be <em>two</em> stacks to consider: a stack of LCs and a stack of
values in each LC.</p>
<p>(This idea was suggested by Nathaniel Smith.)</p>
</div>
<div class="section" id="contextvar-set-reset">
<h3><a class="toc-backref" href="#id97">ContextVar &quot;set/reset&quot;</a></h3>
<p>Yet another approach is to return a special object from
<tt class="docutils literal">ContextVar.set()</tt>, which would represent the modification of
the context variable in the current logical context:</p>
<pre class="literal-block">
var = contextvars.ContextVar('var')

def foo():
    mod = var.set('spam')

    # ... perform work

    mod.reset()  # Reset the value of var to the original value
                 # or remove it from the context.
</pre>
<p>The critical flaw in this approach is that it becomes possible to
pass context var &quot;modification objects&quot; into code running in a
different execution context, which leads to undefined side effects.</p>
</div>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id98">Backwards Compatibility</a></h1>
<p>This proposal preserves 100% backwards compatibility.</p>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id99">Rejected Ideas</a></h1>
<div class="section" id="replication-of-threading-local-interface">
<h2><a class="toc-backref" href="#id100">Replication of threading.local() interface</a></h2>
<p>Choosing the <tt class="docutils literal">threading.local()</tt>-like interface for context
variables was considered and rejected for the following reasons:</p>
<ul>
<li><p class="first">A survery of the standard library and Django has shown that the
vast majority of <tt class="docutils literal">threading.local()</tt> uses involve a single
attribute, which indicates that the namespace approach is not
as helpful in the field.</p>
</li>
<li><p class="first">Using <tt class="docutils literal">__getattr__()</tt> instead of <tt class="docutils literal">.get()</tt> for value lookup
does not provide any way to specify the depth of the lookup
(i.e. search only the top logical context).</p>
</li>
<li><p class="first">Single-value <tt class="docutils literal">ContextVar</tt> is easier to reason about in terms
of visibility.  Suppose <tt class="docutils literal">ContextVar()</tt> is a namespace,
and the consider the following:</p>
<pre class="literal-block">
ns = contextvars.ContextVar('ns')

def gen():
    ns.a = 2
    yield
    assert ns.b == 'bar' # ??

def main():
    ns.a = 1
    ns.b = 'foo'
    g = gen()
    next(g)
    # should not see the ns.a modification in gen()
    assert ns.a == 1
    # but should gen() see the ns.b modification made here?
    ns.b = 'bar'
    yield
</pre>
<p>The above example demonstrates that reasoning about the visibility
of different attributes of the same context var is not trivial.</p>
</li>
<li><p class="first">Single-value <tt class="docutils literal">ContextVar</tt> allows straightforward implementation
of the lookup cache;</p>
</li>
<li><p class="first">Single-value <tt class="docutils literal">ContextVar</tt> interface allows the C-API to be
simple and essentially the same as the Python API.</p>
</li>
</ul>
<p>See also the mailing list discussion: <a class="footnote-reference" href="#id54" id="id10">[26]</a>, <a class="footnote-reference" href="#id55" id="id11">[27]</a>.</p>
</div>
<div class="section" id="coroutines-not-leaking-context-changes-by-default">
<h2><a class="toc-backref" href="#id101">Coroutines not leaking context changes by default</a></h2>
<p>In V4 (<a class="reference internal" href="#version-history">Version History</a>) of this PEP, coroutines were considered to
behave exactly like generators with respect to the execution context:
changes in awaited coroutines were not visible in the outer coroutine.</p>
<p>This idea was rejected on the grounds that is breaks the semantic
similarity of the task and thread models, and, more specifically,
makes it impossible to reliably implement asynchronous context
managers that modify context vars, since <tt class="docutils literal">__aenter__</tt> is a
coroutine.</p>
</div>
</div>
<div class="section" id="appendix-hamt-performance-analysis">
<h1><a class="toc-backref" href="#id102">Appendix: HAMT Performance Analysis</a></h1>
<div class="figure align-center">
<img alt="pep-0550-hamt_vs_dict-v2.png" src="pep-0550-hamt_vs_dict-v2.png" style="width: 100%;" />
<p class="caption">Figure 1.  Benchmark code can be found here: <a class="footnote-reference" href="#id37" id="id12">[9]</a>.</p>
</div>
<p>The above chart demonstrates that:</p>
<ul class="simple">
<li>HAMT displays near O(1) performance for all benchmarked
dictionary sizes.</li>
<li><tt class="docutils literal">dict.copy()</tt> becomes very slow around 100 items.</li>
</ul>
<div class="figure align-center">
<img alt="pep-0550-lookup_hamt.png" src="pep-0550-lookup_hamt.png" style="width: 100%;" />
<p class="caption">Figure 2.  Benchmark code can be found here: <a class="footnote-reference" href="#id38" id="id13">[10]</a>.</p>
</div>
<p>Figure 2 compares the lookup costs of <tt class="docutils literal">dict</tt> versus a HAMT-based
immutable mapping.  HAMT lookup time is 30-40% slower than Python dict
lookups on average, which is a very good result, considering that the
latter is very well optimized.</p>
<p>There is research <a class="footnote-reference" href="#id36" id="id14">[8]</a> showing that there are further possible
improvements to the performance of HAMT.</p>
<p>The reference implementation of HAMT for CPython can be found here:
<a class="footnote-reference" href="#id35" id="id15">[7]</a>.</p>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id103">Acknowledgments</a></h1>
<p>Thanks to Victor Petrovykh for countless discussions around the topic
and PEP proofreading and edits.</p>
<p>Thanks to Nathaniel Smith for proposing the <tt class="docutils literal">ContextVar</tt> design
<a class="footnote-reference" href="#id45" id="id16">[17]</a> <a class="footnote-reference" href="#id46" id="id17">[18]</a>, for pushing the PEP towards a more complete design, and
coming up with the idea of having a stack of contexts in the thread
state.</p>
<p>Thanks to Nick Coghlan for numerous suggestions and ideas on the
mailing list, and for coming up with a case that cause the complete
rewrite of the initial PEP version <a class="footnote-reference" href="#id47" id="id18">[19]</a>.</p>
</div>
<div class="section" id="version-history">
<h1><a class="toc-backref" href="#id104">Version History</a></h1>
<ol class="arabic">
<li><p class="first">Initial revision, posted on 11-Aug-2017 <a class="footnote-reference" href="#id48" id="id19">[20]</a>.</p>
</li>
<li><p class="first">V2 posted on 15-Aug-2017 <a class="footnote-reference" href="#id49" id="id20">[21]</a>.</p>
<p>The fundamental limitation that caused a complete redesign of the
first version was that it was not possible to implement an iterator
that would interact with the EC in the same way as generators
(see <a class="footnote-reference" href="#id47" id="id21">[19]</a>.)</p>
<p>Version 2 was a complete rewrite, introducing new terminology
(Local Context, Execution Context, Context Item) and new APIs.</p>
</li>
<li><p class="first">V3 posted on 18-Aug-2017 <a class="footnote-reference" href="#id50" id="id22">[22]</a>.</p>
<p>Updates:</p>
<ul class="simple">
<li>Local Context was renamed to Logical Context.  The term &quot;local&quot;
was ambiguous and conflicted with local name scopes.</li>
<li>Context Item was renamed to Context Key, see the thread with Nick
Coghlan, Stefan Krah, and Yury Selivanov <a class="footnote-reference" href="#id51" id="id23">[23]</a> for details.</li>
<li>Context Item get cache design was adjusted, per Nathaniel Smith's
idea in <a class="footnote-reference" href="#id53" id="id24">[25]</a>.</li>
<li>Coroutines are created without a Logical Context; ceval loop
no longer needs to special case the <tt class="docutils literal">await</tt> expression
(proposed by Nick Coghlan in <a class="footnote-reference" href="#id52" id="id25">[24]</a>.)</li>
</ul>
</li>
<li><p class="first">V4 posted on 25-Aug-2017 <a class="footnote-reference" href="#id59" id="id26">[31]</a>.</p>
<ul class="simple">
<li>The specification section has been completely rewritten.</li>
<li>Coroutines now have their own Logical Context.  This means
there is no difference between coroutines, generators, and
asynchronous generators w.r.t. interaction with the Execution
Context.</li>
<li>Context Key renamed to Context Var.</li>
<li>Removed the distinction between generators and coroutines with
respect to logical context isolation.</li>
</ul>
</li>
<li><p class="first">V5 posted on 01-Sep-2017: the current version.</p>
<ul>
<li><p class="first">Coroutines have no logical context by default (a revert to the V3
semantics).  Read about the motivation in the
<a class="reference internal" href="#coroutines-not-leaking-context-changes-by-default">Coroutines not leaking context changes by default</a> section.</p>
<p>The <a class="reference internal" href="#high-level-specification">High-Level Specification</a> section was also updated
(specifically Generators and Coroutines subsections).</p>
</li>
<li><p class="first">All APIs have been placed to the <tt class="docutils literal">contextvars</tt> module, and
the factory functions were changed to class constructors
(<tt class="docutils literal">ContextVar</tt>, <tt class="docutils literal">ExecutionContext</tt>, and <tt class="docutils literal">LogicalContext</tt>).
Thanks to Nick for the idea <a class="footnote-reference" href="#id61" id="id27">[33]</a>.</p>
</li>
<li><p class="first"><tt class="docutils literal">ContextVar.lookup()</tt> got renamed back to <tt class="docutils literal">ContextVar.get()</tt>
and gained the <tt class="docutils literal">topmost</tt> and <tt class="docutils literal">default</tt> keyword arguments.
Added <tt class="docutils literal">ContextVar.delete()</tt>.</p>
<p>See Guido's comment in <a class="footnote-reference" href="#id60" id="id28">[32]</a>.</p>
</li>
<li><p class="first">New <tt class="docutils literal">ExecutionContext.vars()</tt> method.  Read about it in
the <a class="reference internal" href="#enumerating-context-vars">Enumerating context vars</a> section.</p>
</li>
<li><p class="first">Fixed <tt class="docutils literal">ContextVar.get()</tt> cache bug (thanks Nathaniel!).</p>
</li>
<li><p class="first">New <a class="reference internal" href="#rejected-ideas">Rejected Ideas</a>,
<a class="reference internal" href="#should-yield-from-leak-context-changes">Should &quot;yield from&quot; leak context changes?</a>,
<a class="reference internal" href="#alternative-designs-for-contextvar-api">Alternative Designs for ContextVar API</a>,
<a class="reference internal" href="#setting-and-restoring-context-variables">Setting and restoring context variables</a>, and
<a class="reference internal" href="#context-manager-as-the-interface-for-modifications">Context manager as the interface for modifications</a> sections.</p>
</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id105">References</a></h1>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><a class="reference external" href="https://blog.golang.org/context">https://blog.golang.org/context</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td><a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.threading.executioncontext.aspx">https://msdn.microsoft.com/en-us/library/system.threading.executioncontext.aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td><a class="reference external" href="https://github.com/numpy/numpy/issues/9444">https://github.com/numpy/numpy/issues/9444</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><a class="reference external" href="http://bugs.python.org/issue31179">http://bugs.python.org/issue31179</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">https://en.wikipedia.org/wiki/Hash_array_mapped_trie</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td><a class="reference external" href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[7]</a></td><td><a class="reference external" href="https://github.com/1st1/cpython/tree/hamt">https://github.com/1st1/cpython/tree/hamt</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[8]</a></td><td><a class="reference external" href="https://michael.steindorfer.name/publications/oopsla15.pdf">https://michael.steindorfer.name/publications/oopsla15.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[9]</a></td><td><a class="reference external" href="https://gist.github.com/1st1/9004813d5576c96529527d44c5457dcd">https://gist.github.com/1st1/9004813d5576c96529527d44c5457dcd</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[10]</a></td><td><a class="reference external" href="https://gist.github.com/1st1/dbe27f2e14c30cce6f0b5fddfc8c437e">https://gist.github.com/1st1/dbe27f2e14c30cce6f0b5fddfc8c437e</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><a class="reference external" href="https://github.com/1st1/cpython/tree/pep550">https://github.com/1st1/cpython/tree/pep550</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td><a class="reference external" href="https://www.python.org/dev/peps/pep-0492/#async-await">https://www.python.org/dev/peps/pep-0492/#async-await</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[13]</td><td><a class="reference external" href="https://github.com/MagicStack/uvloop/blob/master/examples/bench/echoserver.py">https://github.com/MagicStack/uvloop/blob/master/examples/bench/echoserver.py</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[14]</td><td><a class="reference external" href="https://github.com/MagicStack/pgbench">https://github.com/MagicStack/pgbench</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id43" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[15]</td><td><a class="reference external" href="https://github.com/python/performance">https://github.com/python/performance</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id44" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[16]</td><td><a class="reference external" href="https://gist.github.com/1st1/6b7a614643f91ead3edf37c4451a6b4c">https://gist.github.com/1st1/6b7a614643f91ead3edf37c4451a6b4c</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[17]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046752.html">https://mail.python.org/pipermail/python-ideas/2017-August/046752.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id46" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[18]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046772.html">https://mail.python.org/pipermail/python-ideas/2017-August/046772.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id47" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[19]</td><td><em>(<a class="fn-backref" href="#id18">1</a>, <a class="fn-backref" href="#id21">2</a>)</em> <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046775.html">https://mail.python.org/pipermail/python-ideas/2017-August/046775.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id48" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[20]</a></td><td><a class="reference external" href="https://github.com/python/peps/blob/e8a06c9a790f39451d9e99e203b13b3ad73a1d01/pep-0550.rst">https://github.com/python/peps/blob/e8a06c9a790f39451d9e99e203b13b3ad73a1d01/pep-0550.rst</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id49" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[21]</a></td><td><a class="reference external" href="https://github.com/python/peps/blob/e3aa3b2b4e4e9967d28a10827eed1e9e5960c175/pep-0550.rst">https://github.com/python/peps/blob/e3aa3b2b4e4e9967d28a10827eed1e9e5960c175/pep-0550.rst</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id50" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[22]</a></td><td><a class="reference external" href="https://github.com/python/peps/blob/287ed87bb475a7da657f950b353c71c1248f67e7/pep-0550.rst">https://github.com/python/peps/blob/287ed87bb475a7da657f950b353c71c1248f67e7/pep-0550.rst</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id51" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[23]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046801.html">https://mail.python.org/pipermail/python-ideas/2017-August/046801.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id52" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[24]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046790.html">https://mail.python.org/pipermail/python-ideas/2017-August/046790.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id53" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[25]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046786.html">https://mail.python.org/pipermail/python-ideas/2017-August/046786.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id54" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[26]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046888.html">https://mail.python.org/pipermail/python-ideas/2017-August/046888.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id55" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[27]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2017-August/046889.html">https://mail.python.org/pipermail/python-ideas/2017-August/046889.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id56" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[28]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/decimal.html#decimal.Context.abs">https://docs.python.org/3/library/decimal.html#decimal.Context.abs</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id57" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[29]</a></td><td><a class="reference external" href="https://curio.readthedocs.io/en/latest/reference.html#task-local-storage">https://curio.readthedocs.io/en/latest/reference.html#task-local-storage</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id58" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[30]</a></td><td><a class="reference external" href="https://docs.atlassian.com/aiolocals/latest/usage.html">https://docs.atlassian.com/aiolocals/latest/usage.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id59" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[31]</a></td><td><a class="reference external" href="https://github.com/python/peps/blob/1b8728ded7cde9df0f9a24268574907fafec6d5e/pep-0550.rst">https://github.com/python/peps/blob/1b8728ded7cde9df0f9a24268574907fafec6d5e/pep-0550.rst</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id60" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id28">[32]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-August/149020.html">https://mail.python.org/pipermail/python-dev/2017-August/149020.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id61" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[33]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-August/149043.html">https://mail.python.org/pipermail/python-dev/2017-August/149043.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id106">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

